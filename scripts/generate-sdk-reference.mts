import { writeFileSync, readdirSync, readFileSync, mkdirSync } from 'fs';
import { join } from 'path';
import { Project } from 'ts-morph';

interface MethodInfo {
  name: string;
  parameters: string[];
  returnType: string;
  description?: string;
  category: string;
  example?: string;
}

interface TypeInfo {
  name: string;
  properties: string[];
  description?: string;
  category: string;
  example?: string;
}

const IGNORED_TYPES = [
  'RequestArgs',
  'ServerMap',
  'ConfigurationParameters',
  'AxiosRequestConfig',
  'RawAxiosRequestConfig',
  'AxiosResponse',
  'AxiosError',
  'AxiosInstance',
  'AxiosStatic',
  'AxiosRequestTransformer',
  'AxiosResponseTransformer',
  'AxiosAdapter',
  'AxiosBasicCredentials',
  'AxiosProxyConfig',
  'AxiosProgressEvent'
];

const CATEGORIES = {
  BOTS: 'Bots',
  CALENDARS: 'Calendars',
  WEBHOOKS: 'Webhooks',
  COMMON: 'Common'
};

const METHOD_EXAMPLES: Record<string, string> = {
  joinMeeting: `// Join a meeting with a bot
const botId = await client.joinMeeting({
  botName: "Meeting Assistant",
  meetingUrl: "https://meet.google.com/abc-def-ghi",
  reserved: true,
});`,
  getMeetingData: `// Get meeting data
const meetingData = await client.getMeetingData(botId);
console.log("Meeting data:", meetingData);`,
  createCalendar: `// Create a calendar integration
const calendar = await client.createCalendar({
  oauthClientId: "your-oauth-client-id",
  oauthClientSecret: "your-oauth-client-secret",
  oauthRefreshToken: "your-oauth-refresh-token",
  platform: Provider.Google,
});`,
  listEvents: `// List events from a calendar
const events = await client.listEvents(calendar.uuid, {
  startDateGte: "2024-01-01T00:00:00Z",
  status: "upcoming"
});`
};

function writeMethodFile(method: MethodInfo, outputDir: string) {
  const content = `---
title: ${method.name}
full: true
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

${method.description ? `${method.description}\n\n` : ''}

\`\`\`typescript
${method.name}(${method.parameters.join(', ')}): ${method.returnType}
\`\`\`

${method.example ? `
<Callout type="info">
  Example:
  
  \`\`\`typescript
  ${method.example}
  \`\`\`
</Callout>
` : ''}
`;

  const fileName = method.name.toLowerCase().replace(/[^a-z0-9]/g, '_') + '.mdx';
  writeFileSync(join(outputDir, fileName), content);
}

function writeTypeFile(type: TypeInfo, outputDir: string) {
  const content = `---
title: ${type.name}
full: true
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

${type.description ? `${type.description}\n\n` : ''}

\`\`\`typescript
interface ${type.name} {
  ${type.properties.join('\n  ')}
}
\`\`\`
`;

  const fileName = type.name.toLowerCase().replace(/[^a-z0-9]/g, '_') + '.mdx';
  writeFileSync(join(outputDir, fileName), content);
}

function writeMetaJson(category: string, items: { name: string }[], outputDir: string) {
  const content = {
    title: category,
    icon: getCategoryIcon(category),
    pages: items.map(item => item.name.toLowerCase().replace(/[^a-z0-9]/g, '_'))
  };

  writeFileSync(join(outputDir, 'meta.json'), JSON.stringify(content, null, 2));
}

function getCategoryIcon(category: string): string {
  switch (category) {
    case 'Bots':
      return 'Bot';
    case 'Calendars':
      return 'Calendar';
    case 'Webhooks':
      return 'Webhook';
    default:
      return 'Code';
  }
}

function writeIndexFile(category: string, items: { name: string }[], outputDir: string) {
  const content = `---
title: ${category}
description: ${category} API Reference
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

${items.map(item => `- [${item.name}](./${item.name.toLowerCase().replace(/[^a-z0-9]/g, '_')}.mdx)`).join('\n')}
`;

  writeFileSync(join(outputDir, 'index.mdx'), content);
}

export async function generateSDKReference() {
  try {
    const project = new Project();
    const sdkPath = join(process.cwd(), 'node_modules', '@meeting-baas', 'sdk', 'dist', 'baas');
    const outputBaseDir = join(process.cwd(), 'content', 'docs', 'typescript-sdk', 'reference');
    const mainMetaPath = join(process.cwd(), 'content', 'docs', 'typescript-sdk', 'meta.json');
    
    console.log('Looking for TypeScript files in:', sdkPath);
    
    // Add all TypeScript files
    const files = readdirSync(sdkPath, { recursive: true, withFileTypes: true })
      .filter(file => {
        const fullPath = join(file.path, file.name);
        return file.isFile() && file.name.endsWith('.d.ts') && 
               (fullPath.includes('/api/') || !fullPath.includes('/api/'));
      })
      .map(file => join(file.path, file.name));
    
    project.addSourceFilesAtPaths([
      join(sdkPath, 'api', '*.d.ts'),
      join(sdkPath, '*.d.ts'),
      join(sdkPath, 'models', '*.d.ts')
    ]);

    const methods: MethodInfo[] = [];
    const types: TypeInfo[] = [];

    // Process each file
    for (const file of project.getSourceFiles()) {
      const fileName = file.getBaseName();
      
      // Determine category based on file name
      let category = CATEGORIES.COMMON;
      if (fileName.includes('calendars-api')) {
        category = CATEGORIES.CALENDARS;
      } else if (fileName.includes('default-api')) {
        category = CATEGORIES.BOTS;
      } else if (fileName.includes('webhook')) {
        category = CATEGORIES.WEBHOOKS;
      }

      // Extract methods from API classes
      const classes = file.getClasses();
      classes.forEach(cls => {
        if (cls.getName()?.includes('Api')) {
          const classMethods = cls.getMethods();
          classMethods.forEach(method => {
            if (!method.getName().startsWith('_')) {
              methods.push({
                name: method.getName(),
                parameters: method.getParameters().map(p => {
                  const type = p.getType().getText();
                  const cleanType = type.replace(/import\(".*?node_modules\/@meeting-baas\/sdk\/dist\/baas\//, 'import("@meeting-baas/sdk/');
                  return `${p.getName()}: ${cleanType}`;
                }),
                returnType: method.getReturnType().getText().replace(/import\(".*?node_modules\/@meeting-baas\/sdk\/dist\/baas\//, 'import("@meeting-baas/sdk/'),
                description: method.getJsDocs()[0]?.getDescription()?.split('\n')[0],
                category,
                example: METHOD_EXAMPLES[method.getName()]
              });
            }
          });
        }
      });

      // Extract types
      const interfaces = file.getInterfaces();
      interfaces.forEach(iface => {
        if (!IGNORED_TYPES.includes(iface.getName())) {
          const description = iface.getJsDocs()[0]?.getDescription();
          const cleanDescription = description?.includes('Meeting BaaS API') ? undefined : description?.split('\n')[0];
          
          types.push({
            name: iface.getName(),
            properties: iface.getProperties().map(p => {
              const type = p.getType().getText();
              const cleanType = type.replace(/import\(".*?node_modules\/@meeting-baas\/sdk\/dist\/baas\//, 'import("@meeting-baas/sdk/');
              return `${p.getName()}: ${cleanType}`;
            }),
            description: cleanDescription,
            category
          });
        }
      });
    }

    // Create output directories
    const categories = Object.values(CATEGORIES);
    categories.forEach(category => {
      const categoryDir = join(outputBaseDir, category.toLowerCase());
      mkdirSync(categoryDir, { recursive: true });
    });

    // Write method files
    methods.forEach(method => {
      const categoryDir = join(outputBaseDir, method.category.toLowerCase());
      writeMethodFile(method, categoryDir);
    });

    // Write type files
    types.forEach(type => {
      const categoryDir = join(outputBaseDir, type.category.toLowerCase());
      writeTypeFile(type, categoryDir);
    });

    // Write index files and meta.json for each category
    categories.forEach(category => {
      const categoryDir = join(outputBaseDir, category.toLowerCase());
      const categoryMethods = methods.filter(m => m.category === category);
      const categoryTypes = types.filter(t => t.category === category);
      writeIndexFile(category, [...categoryMethods, ...categoryTypes], categoryDir);
      writeMetaJson(category, [...categoryMethods, ...categoryTypes], categoryDir);
    });

    // Write main index file and meta.json
    const mainIndexContent = `---
title: SDK Reference
description: Complete reference of all methods and types in the Meeting BaaS TypeScript SDK
icon: Code
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

${categories.map(category => `## ${category}

- [${category}](./${category.toLowerCase()}/index.mdx)`).join('\n\n')}
`;

    writeFileSync(join(outputBaseDir, 'index.mdx'), mainIndexContent);

    // Update main meta.json
    const mainMetaContent = {
      title: "Typescript SDK",
      icon: "Code",
      description: "Typescript SDK for MeetingBaas.",
      root: true,
      pages: [
        "index",
        "getting-started",
        "reference",
        "updates"
      ]
    };

    writeFileSync(mainMetaPath, JSON.stringify(mainMetaContent, null, 2));

    console.log('Generated SDK reference documentation');
  } catch (error) {
    console.error('Failed to generate SDK reference:', error);
    process.exit(1);
  }
}

// Call the function
generateSDKReference(); 