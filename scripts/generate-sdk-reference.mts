import { writeFileSync, readdirSync, readFileSync, mkdirSync, existsSync, unlinkSync } from 'fs';
import { join } from 'path';
import { Project } from 'ts-morph';

interface MethodInfo {
  name: string;
  parameters: string[];
  returnType: string;
  description?: string;
  category: string;
  example?: string;
}

interface TypeInfo {
  name: string;
  properties: string[];
  description?: string;
  category: string;
  example?: string;
}

const IGNORED_TYPES = [
  'RequestArgs',
  'ServerMap',
  'ConfigurationParameters',
  'AxiosRequestConfig',
  'RawAxiosRequestConfig',
  'AxiosResponse',
  'AxiosError',
  'AxiosInstance',
  'AxiosStatic',
  'AxiosRequestTransformer',
  'AxiosResponseTransformer',
  'AxiosAdapter',
  'AxiosBasicCredentials',
  'AxiosProxyConfig',
  'AxiosProgressEvent'
];

const CATEGORIES = {
  COMMON: 'Common',
  BOTS: 'Bots',
  CALENDARS: 'Calendars',
  WEBHOOKS: 'Webhooks'
};

const METHOD_EXAMPLES: Record<string, string> = {
  join: `import { BaasClient } from "@meeting-baas/sdk";

// Create a BaaS client
const client = new BaasClient({
  apiKey: "your-api-key", // Get yours at https://meetingbaas.com
});

// Join a meeting with a bot
const botId = await client.join({
  botName: "Meeting Assistant",
  meetingUrl: "https://meet.google.com/abc-def-ghi",
  reserved: true,
});`,
  getMeetingData: `import { BaasClient } from "@meeting-baas/sdk";

// Create a BaaS client
const client = new BaasClient({
  apiKey: "your-api-key",
});

// Get meeting data
const meetingData = await client.getMeetingData(botId);
console.log("Meeting data:", meetingData);`,
  createCalendar: `import { BaasClient, Provider } from "@meeting-baas/sdk";

// Create a BaaS client
const client = new BaasClient({
  apiKey: "your-api-key",
});

// Create a calendar integration
const calendar = await client.createCalendar({
  oauthClientId: "your-oauth-client-id",
  oauthClientSecret: "your-oauth-client-secret",
  oauthRefreshToken: "your-oauth-refresh-token",
  platform: Provider.Google,
});`,
  listEvents: `import { BaasClient } from "@meeting-baas/sdk";

// Create a BaaS client
const client = new BaasClient({
  apiKey: "your-api-key",
});

// List events from a calendar
const events = await client.listEvents(calendar.uuid, {
  startDateGte: "2024-01-01T00:00:00Z",
  status: "upcoming"
});`
};

function writeMethodFile(method: MethodInfo, outputDir: string) {
  // Extract parameter details
  const parameterDetails = method.parameters.map(param => {
    const [name, type] = param.split(': ');
    return {
      name: name.trim(),
      type: type.trim(),
      description: method.description?.includes(name) ? method.description.split(name)[1]?.split('.')[0] : undefined
    };
  });

  // Get related methods based on category and name
  const relatedMethods = getRelatedMethods(method);

  const content = `---
title: ${method.name}
full: true
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

${method.description ? `${method.description}\n\n` : ''}

## Usage

\`\`\`typescript
${method.name}(${method.parameters.join(', ')}): ${method.returnType}
\`\`\`

## Parameters

${parameterDetails.map(param => `
### \`${param.name}\`

Type: \`${param.type}\`

${param.description ? `${param.description}\n` : ''}
`).join('\n')}

## Returns

\`${method.returnType}\`

${method.example ? `
## Example

<Callout type="info">
  Example:
  
  \`\`\`typescript
  ${method.example}
  \`\`\`
</Callout>
` : ''}

## Common Use Cases

${getCommonUseCases(method)}

## Related Methods

${relatedMethods.map(related => {
  const fileName = related.name.toLowerCase().replace(/[^a-z0-9]/g, '_');
  const categoryPath = related.category.toLowerCase();
  return `- [${related.name}](/docs/typescript-sdk/reference/${categoryPath}/${fileName})`;
}).join('\n')}
`;

  const fileName = method.name.toLowerCase().replace(/[^a-z0-9]/g, '_') + '.mdx';
  const filePath = join(outputDir, fileName);
  
  // Only write if file doesn't exist or if it's a new file
  if (!existsSync(filePath) || fileName.startsWith('new_')) {
    writeFileSync(filePath, content);
  }
}

function getRelatedMethods(method: MethodInfo): MethodInfo[] {
  // Define related methods based on category and name
  const relatedMap: Record<string, string[]> = {
    'join': ['leave', 'getMeetingData', 'deleteData'],
    'leave': ['join', 'getMeetingData'],
    'getMeetingData': ['join', 'leave', 'deleteData'],
    'deleteData': ['join', 'getMeetingData'],
    'createCalendar': ['listCalendars', 'getCalendar', 'updateCalendar', 'deleteCalendar'],
    'listCalendars': ['createCalendar', 'getCalendar', 'updateCalendar', 'deleteCalendar'],
    'getCalendar': ['createCalendar', 'listCalendars', 'updateCalendar', 'deleteCalendar'],
    'updateCalendar': ['createCalendar', 'listCalendars', 'getCalendar', 'deleteCalendar'],
    'deleteCalendar': ['createCalendar', 'listCalendars', 'getCalendar', 'updateCalendar'],
    'listEvents': ['getEvent', 'scheduleRecordEvent', 'unscheduleRecordEvent'],
    'getEvent': ['listEvents', 'scheduleRecordEvent', 'unscheduleRecordEvent'],
    'scheduleRecordEvent': ['listEvents', 'getEvent', 'unscheduleRecordEvent'],
    'unscheduleRecordEvent': ['listEvents', 'getEvent', 'scheduleRecordEvent']
  };

  return (relatedMap[method.name] || []).map(name => ({
    name,
    parameters: [],
    returnType: '',
    category: method.category
  }));
}

function getCommonUseCases(method: MethodInfo): string {
  const useCases: Record<string, string> = {
    'join': `- Joining a meeting with a bot for recording
- Setting up a bot with custom parameters
- Configuring webhook notifications for a specific bot
- Starting a meeting recording with automatic transcription`,
    'leave': `- Ending a bot's participation in a meeting
- Stopping a meeting recording
- Cleaning up bot resources after a meeting
- Handling meeting completion`,
    'getMeetingData': `- Retrieving meeting transcripts
- Accessing meeting metadata
- Getting bot status and configuration
- Downloading meeting recordings`,
    'deleteData': `- Removing meeting data for privacy
- Cleaning up old meeting records
- Managing storage usage
- Handling data retention policies`,
    'createCalendar': `- Setting up Google Calendar integration
- Connecting Microsoft Teams calendar
- Configuring calendar sync settings
- Managing calendar permissions`,
    'listCalendars': `- Viewing all connected calendars
- Checking calendar sync status
- Managing multiple calendar integrations
- Verifying calendar permissions`,
    'getCalendar': `- Viewing calendar details
- Checking calendar sync status
- Verifying calendar permissions
- Managing calendar settings`,
    'updateCalendar': `- Updating calendar credentials
- Changing calendar sync settings
- Modifying calendar permissions
- Refreshing calendar integration`,
    'deleteCalendar': `- Removing calendar integration
- Cleaning up unused calendars
- Managing calendar connections
- Handling calendar disconnection`,
    'listEvents': `- Viewing upcoming meetings
- Checking scheduled recordings
- Managing calendar events
- Filtering events by date or status`,
    'getEvent': `- Viewing event details
- Checking recording status
- Managing event settings
- Verifying event configuration`,
    'scheduleRecordEvent': `- Setting up automatic recording
- Configuring bot parameters for an event
- Managing recording schedules
- Setting up recurring recordings`,
    'unscheduleRecordEvent': `- Canceling scheduled recordings
- Removing bot from events
- Managing recording schedules
- Handling event changes`
  };

  return useCases[method.name] || 'No common use cases documented yet.';
}

function writeTypeFile(type: TypeInfo, outputDir: string) {
  const content = `---
title: ${type.name}
full: true
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

${type.description ? `${type.description}\n\n` : ''}

\`\`\`typescript
interface ${type.name} {
  ${type.properties.join('\n  ')}
}
\`\`\`
`;

  const fileName = type.name.toLowerCase().replace(/[^a-z0-9]/g, '_') + '.mdx';
  writeFileSync(join(outputDir, fileName), content);
}

function writeMetaJson(category: string, items: { name: string }[], outputDir: string) {
  const content = {
    title: category,
    icon: getCategoryIcon(category),
    pages: items.map(item => item.name.toLowerCase().replace(/[^a-z0-9]/g, '_'))
  };

  writeFileSync(join(outputDir, 'meta.json'), JSON.stringify(content, null, 2));
}

function getCategoryIcon(category: string): string {
  switch (category) {
    case 'Bots':
      return 'Bot';
    case 'Calendars':
      return 'Calendar';
    case 'Webhooks':
      return 'Webhook';
    default:
      return 'Code';
  }
}

function writeIndexFile(category: string, items: { name: string }[], outputDir: string) {
  const content = `---
title: ${category}
description: ${category} API Reference
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

${items.map(item => {
  const fileName = item.name.toLowerCase().replace(/[^a-z0-9]/g, '_');
  const categoryPath = category.toLowerCase();
  // Use clean URLs for navigation with reference path
  return `- [${item.name}](/docs/typescript-sdk/reference/${categoryPath}/${fileName})`;
}).join('\n')}
`;

  writeFileSync(join(outputDir, 'index.mdx'), content);
}

function extractExamplesFromJSDoc(method: MethodInfo) {
  // Extract examples from JSDoc comments
  const examples = method.description?.split('\n')
    .filter(line => line.includes('Example:'))
    .map(line => line.split('Example:')[1].trim());
  
  return examples || [];
}

function generateExampleForType(name: string, type: string): string {
  // Handle SDK-specific types first
  if (type.includes('JoinRequest')) {
    return `{
  botName: "Meeting Assistant",
  meetingUrl: "https://meet.google.com/abc-def-ghi",
  reserved: true,
  speech_to_text: {
    provider: "gladia"
  }
}`;
  }

  if (type.includes('JoinRequestSpeechToText')) {
    return `{
  provider: "gladia",
  api_key: "your-api-key"
}`;
  }

  if (type.includes('JoinRequestAutomaticLeave')) {
    return `{
  enabled: true,
  after_minutes: 60
}`;
  }

  if (type.includes('JoinRequestRecordingMode')) {
    return `{
  mode: "audio",
  quality: "high"
}`;
  }

  if (type.includes('JoinRequestStreaming')) {
    return `{
  enabled: true,
  url: "https://your-streaming-endpoint.com"
}`;
  }

  // Handle common types with context
  if (type.includes('string')) {
    if (name.toLowerCase().includes('url')) {
      if (name.toLowerCase().includes('webhook')) {
        return '"https://your-webhook-endpoint.com"';
      }
      if (name.toLowerCase().includes('streaming')) {
        return '"https://your-streaming-endpoint.com"';
      }
      if (name.toLowerCase().includes('meeting')) {
        return '"https://meet.google.com/abc-def-ghi"';
      }
      if (name.toLowerCase().includes('image')) {
        return '"https://example.com/bot-image.jpg"';
      }
      return '"https://example.com"';
    }
    if (name.toLowerCase().includes('id')) {
      if (name.toLowerCase().includes('bot')) {
        return '"bot_123"';
      }
      if (name.toLowerCase().includes('meeting')) {
        return '"meeting_456"';
      }
      return '"id_789"';
    }
    if (name.toLowerCase().includes('name')) {
      if (name.toLowerCase().includes('bot')) {
        return '"Meeting Assistant"';
      }
      if (name.toLowerCase().includes('speaker')) {
        return '"John Doe"';
      }
      return '"Example Name"';
    }
    if (name.toLowerCase().includes('date')) {
      return '"2024-01-01T00:00:00Z"';
    }
    if (name.toLowerCase().includes('message')) {
      return '"Hello, I am a meeting assistant bot."';
    }
    if (name.toLowerCase().includes('key')) {
      return '"your-api-key"';
    }
    return '"example"';
  }
  
  if (type.includes('number')) {
    if (name.toLowerCase().includes('time')) {
      return 'Date.now()';
    }
    if (name.toLowerCase().includes('minutes')) {
      return '60';
    }
    if (name.toLowerCase().includes('limit')) {
      return '10';
    }
    return '42';
  }
  
  if (type.includes('boolean')) {
    if (name.toLowerCase().includes('enabled')) {
      return 'true';
    }
    if (name.toLowerCase().includes('reserved')) {
      return 'true';
    }
    return 'false';
  }
  
  if (type.includes('array')) {
    return '[]';
  }
  
  if (type.includes('object')) {
    if (name.toLowerCase().includes('extra')) {
      return `{
  customField: "value",
  anotherField: 123
}`;
    }
    return '{}';
  }
  
  // Default case
  return 'null';
}

function generateTypeSafeExample(method: MethodInfo) {
  // Generate example based on parameter types
  const params = method.parameters.map(param => {
    const [name, type] = param.split(': ');
    return generateExampleForType(name, type);
  });
  
  return `// Example usage
const result = await client.${method.name}(${params.join(', ')});`;
}

export async function generateSDKReference() {
  try {
    const project = new Project();
    const sdkPath = join(process.cwd(), 'node_modules', '@meeting-baas', 'sdk', 'dist', 'baas');
    const outputBaseDir = join(process.cwd(), 'content', 'docs', 'typescript-sdk');
    const referenceDir = join(outputBaseDir, 'reference');
    const mainMetaPath = join(outputBaseDir, 'meta.json');
    
    console.log('Looking for TypeScript files in:', sdkPath);
    
    // Add all TypeScript files
    const files = readdirSync(sdkPath, { recursive: true, withFileTypes: true })
      .filter(file => {
        const fullPath = join(file.path, file.name);
        return file.isFile() && file.name.endsWith('.d.ts') && 
               (fullPath.includes('/api/') || !fullPath.includes('/api/'));
      })
      .map(file => join(file.path, file.name));
    
    project.addSourceFilesAtPaths([
      join(sdkPath, 'api', '*.d.ts'),
      join(sdkPath, '*.d.ts'),
      join(sdkPath, 'models', '*.d.ts')
    ]);

    const methods: MethodInfo[] = [];
    const types: TypeInfo[] = [];

    // Process each file
    for (const file of project.getSourceFiles()) {
      const fileName = file.getBaseName();
      
      // Determine category based on file name
      let category = CATEGORIES.COMMON;
      if (fileName.includes('calendars-api')) {
        category = CATEGORIES.CALENDARS;
      } else if (fileName.includes('default-api')) {
        category = CATEGORIES.BOTS;
      } else if (fileName.includes('webhook')) {
        category = CATEGORIES.WEBHOOKS;
      }

      // Extract methods from API classes
      const classes = file.getClasses();
      classes.forEach(cls => {
        if (cls.getName()?.includes('Api')) {
          const classMethods = cls.getMethods();
          classMethods.forEach(method => {
            if (!method.getName().startsWith('_')) {
              methods.push({
                name: method.getName(),
                parameters: method.getParameters().map(p => {
                  const type = p.getType().getText();
                  const cleanType = type.replace(/import\(".*?node_modules\/@meeting-baas\/sdk\/dist\/baas\//, 'import("@meeting-baas/sdk/');
                  return `${p.getName()}: ${cleanType}`;
                }),
                returnType: method.getReturnType().getText().replace(/import\(".*?node_modules\/@meeting-baas\/sdk\/dist\/baas\//, 'import("@meeting-baas/sdk/'),
                description: method.getJsDocs()[0]?.getDescription()?.split('\n')[0],
                category,
                example: METHOD_EXAMPLES[method.getName()]
              });
            }
          });
        }
      });

      // Extract types
      const interfaces = file.getInterfaces();
      interfaces.forEach(iface => {
        if (!IGNORED_TYPES.includes(iface.getName())) {
          const description = iface.getJsDocs()[0]?.getDescription();
          const cleanDescription = description?.includes('Meeting BaaS API') ? undefined : description?.split('\n')[0];
          
          types.push({
            name: iface.getName(),
            properties: iface.getProperties().map(p => {
              const type = p.getType().getText();
              const cleanType = type.replace(/import\(".*?node_modules\/@meeting-baas\/sdk\/dist\/baas\//, 'import("@meeting-baas/sdk/');
              return `${p.getName()}: ${cleanType}`;
            }),
            description: cleanDescription,
            category
          });
        }
      });
    }

    // Create output directories
    const categories = Object.values(CATEGORIES);
    categories.forEach(category => {
      const categoryDir = join(referenceDir, category.toLowerCase());
      mkdirSync(categoryDir, { recursive: true });
    });

    // Write method files
    methods.forEach(method => {
      const categoryDir = join(referenceDir, method.category.toLowerCase());
      writeMethodFile(method, categoryDir);
    });

    // Write type files
    types.forEach(type => {
      const categoryDir = join(referenceDir, type.category.toLowerCase());
      writeTypeFile(type, categoryDir);
    });

    // Write index files and meta.json for each category
    categories.forEach(category => {
      const categoryDir = join(referenceDir, category.toLowerCase());
      const categoryMethods = methods.filter(m => m.category === category);
      const categoryTypes = types.filter(t => t.category === category);
      writeIndexFile(category, [...categoryMethods, ...categoryTypes], categoryDir);
      writeMetaJson(category, [...categoryMethods, ...categoryTypes], categoryDir);
    });

    // Write main index file and meta.json
    const mainIndexContent = `---
title: SDK Reference
description: Complete reference of all methods and types in the Meeting BaaS TypeScript SDK
icon: Code
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

${categories.map(category => `## ${category}

- [${category}](./reference/${category.toLowerCase()})`).join('\n\n')}
`;

    // Write the index file to the reference directory
    const referenceIndexPath = join(referenceDir, 'index.mdx');
    // Delete the file first to ensure we're not appending to an existing file
    if (existsSync(referenceIndexPath)) {
      unlinkSync(referenceIndexPath);
    }
    writeFileSync(referenceIndexPath, mainIndexContent);

    // Update main meta.json
    const mainMetaContent = {
      title: "Typescript SDK",
      icon: "Code",
      description: "Typescript SDK for MeetingBaas.",
      root: true,
      pages: [
        "index",
        "getting-started",
        "reference",
        "updates"
      ]
    };

    writeFileSync(mainMetaPath, JSON.stringify(mainMetaContent, null, 2));

    console.log('Generated SDK reference documentation');
  } catch (error) {
    console.error('Failed to generate SDK reference:', error);
    process.exit(1);
  }
}

// Call the function
generateSDKReference(); 