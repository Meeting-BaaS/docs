#KEY#DATE# 2025-03-09
#KEY#MAX_DIFF_LINES# 100
#KEY#EXCLUDES# pnpm.lock, TypeScript build files, Rust build files

#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 89ff310b2aeaf364fec642c3168822d7719cc0a4
#KEY#COMMIT_DATE# 2025-03-09 19:03:32 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# Handle dynamic timeout
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- README.md

#KEY#DIFF_RANGE# FROM: d44c0c5baa0931414b166546bc45ac97d15ce460 TO: 89ff310b2aeaf364fec642c3168822d7719cc0a4
=================================================================

#KEY#GIT_DIFF#

diff --git a/README.md b/README.md
index 9ddc123..cd601cb 100644
--- a/README.md
+++ b/README.md
@@ -1,20 +1,20 @@
 # Run an MCP Server on Vercel
 
 ## Usage
 
 Update `api/server.ts` with your tools, prompts, and resources following the [MCP TypeScript SDK documentation](https://github.com/modelcontextprotocol/typescript-sdk/tree/main?tab=readme-ov-file#server).
 
 ## Notes for running on Vercel
 
-- Requires a Redis attached to the project under `process.env.REDIS_URL`
+- Requires a Redis attached to the project under process.env.REDIS_URL
 - Make sure you have [Fluid compute](https://vercel.com/docs/functions/fluid-compute) enabled for efficient execution
 - After enabling Fluid compute, open `vercel.json` and adjust max duration to 800 if you using a Vercel Pro or Enterprise account
 - [Deploy the MCP template](https://vercel.com/templates/other/model-context-protocol-mcp-with-vercel-functions)
 
 ## Sample Client
 
 `script/test-client.mjs` contains a sample client to try invocations.
 
 ```sh
 node scripts/test-client.mjs https://mcp-on-vercel.vercel.app
 ```
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 55c2416635fe2099e46e04b623bc2ba11e514ede
#KEY#COMMIT_DATE# 2025-03-09 18:59:51 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# Require REDIS_URL to be set
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: 89ff310b2aeaf364fec642c3168822d7719cc0a4 TO: 55c2416635fe2099e46e04b623bc2ba11e514ede
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index 87d97c6..cb39662 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,248 +1,245 @@
 import getRawBody from "raw-body";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { createClient } from "redis";
 import { Socket } from "net";
 import { Readable } from "stream";
 import { ServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
-import vercelJson from "../vercel.json";
 
 interface SerializedRequest {
   requestId: string;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer) => void,
   serverOptions: ServerOptions = {}
 ) {
-  const maxDuration =
-    vercelJson?.functions?.["api/server.ts"]?.maxDuration || 800;
   const redisUrl = process.env.REDIS_URL || process.env.KV_URL;
   if (!redisUrl) {
     throw new Error("REDIS_URL environment variable is not set");
   }
   const redis = createClient({
     url: redisUrl,
   });
   const redisPublisher = createClient({
     url: redisUrl,
   });
   redis.on("error", (err) => {
     console.error("Redis error", err);
   });
   redisPublisher.on("error", (err) => {
     console.error("Redis error", err);
   });
   const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 
   let servers: McpServer[] = [];
 
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript server on vercel",
           version: "0.1.0",
         },
         serverOptions
       );
       initializeServer(server);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       // Handles messages originally received via /message
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b: unknown) => {
           body = b as string;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         await redisPublisher.publish(
           `responses:${sessionId}:${request.requestId}`,
           JSON.stringify({
             status,
             body,
           })
         );
 
         if (status >= 200 && status < 300) {
           logInContext(
             "log",
             `Request ${sessionId}:${request.requestId} succeeded: ${body}`
           );
         } else {
           logInContext(
             "error",
             `Message for ${sessionId}:${request.requestId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
-        }, (maxDuration - 5) * 1000);
+        }, 795 * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
       const requestId = crypto.randomUUID();
       const serializedRequest: SerializedRequest = {
         requestId,
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Handles responses from the /sse endpoint.
       await redis.subscribe(
         `responses:${sessionId}:${requestId}`,
         (message) => {
           clearTimeout(timeout);
           const response = JSON.parse(message) as {
             status: number;
             body: string;
           };
           res.statusCode = response.status;
           res.end(response.body);
         }
       );
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await redisPublisher.publish(
         `requests:${sessionId}`,
         JSON.stringify(serializedRequest)
       );
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
       let timeout = setTimeout(async () => {
         await redis.unsubscribe(`responses:${sessionId}:${requestId}`);
         res.statusCode = 408;
         res.end("Request timed out");
       }, 10 * 1000);
 
       res.on("close", async () => {
         clearTimeout(timeout);
         await redis.unsubscribe(`responses:${sessionId}:${requestId}`);
       });
     } else if (url.pathname === "/") {
     } else if (url.pathname === "/") {
       res.statusCode = 200;
       res.end("Hello, world!");
     } else {
       res.statusCode = 404;
       res.end("Not found");
     }
   };
 }
 
 // Define the options interface
 interface FakeIncomingMessageOptions {
   method?: string;
   url?: string;
   headers?: IncomingHttpHeaders;
   body?: string | Buffer | Record<string, any> | null;
   socket?: Socket;
 }
 
 // Create a fake IncomingMessage
 function createFakeIncomingMessage(
   options: FakeIncomingMessageOptions = {}
 ): IncomingMessage {
   const {
     method = "GET",
     url = "/",
     headers = {},
     body = null,
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 6ea2177690e46b26f0d350f66b0c715111f4df84
#KEY#COMMIT_DATE# 2025-03-09 13:27:34 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# Update vercel.json
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: 55c2416635fe2099e46e04b623bc2ba11e514ede TO: 6ea2177690e46b26f0d350f66b0c715111f4df84
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index cb39662..ae6a278 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,141 +1,137 @@
 import getRawBody from "raw-body";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { createClient } from "redis";
 import { Socket } from "net";
 import { Readable } from "stream";
 import { ServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
 
 interface SerializedRequest {
   requestId: string;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
+const redis = createClient({
+  url: process.env.REDIS_URL || process.env.KV_URL,
+});
+const redisPublisher = createClient({
+  url: process.env.REDIS_URL || process.env.KV_URL,
+});
+redis.on("error", (err) => {
+  console.error("Redis error", err);
+});
+redisPublisher.on("error", (err) => {
+  console.error("Redis error", err);
+});
+const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
+
+let servers: McpServer[] = [];
+
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer) => void,
   serverOptions: ServerOptions = {}
 ) {
-  const redisUrl = process.env.REDIS_URL || process.env.KV_URL;
-  if (!redisUrl) {
-    throw new Error("REDIS_URL environment variable is not set");
-  }
-  const redis = createClient({
-    url: redisUrl,
-  });
-  const redisPublisher = createClient({
-    url: redisUrl,
-  });
-  redis.on("error", (err) => {
-    console.error("Redis error", err);
-  });
-  redisPublisher.on("error", (err) => {
-    console.error("Redis error", err);
-  });
-  const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
-
-  let servers: McpServer[] = [];
-
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript server on vercel",
           version: "0.1.0",
         },
         serverOptions
       );
       initializeServer(server);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       // Handles messages originally received via /message
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b: unknown) => {
           body = b as string;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         await redisPublisher.publish(
           `responses:${sessionId}:${request.requestId}`,
           JSON.stringify({
             status,
             body,
           })
         );
 
         if (status >= 200 && status < 300) {
           logInContext(
             "log",
             `Request ${sessionId}:${request.requestId} succeeded: ${body}`
           );
         } else {
           logInContext(
             "error",
             `Message for ${sessionId}:${request.requestId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 9487c4e8241c44a99ef3a3045520d74698cb8927
#KEY#COMMIT_DATE# 2025-03-09 12:44:55 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# Add pro/ent
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- vercel.json

#KEY#DIFF_RANGE# FROM: 6ea2177690e46b26f0d350f66b0c715111f4df84 TO: 9487c4e8241c44a99ef3a3045520d74698cb8927
=================================================================

#KEY#GIT_DIFF#

diff --git a/vercel.json b/vercel.json
index 360f051..c449b17 100644
--- a/vercel.json
+++ b/vercel.json
@@ -1,8 +1,8 @@
 {
   "rewrites": [{ "source": "/(.+)", "destination": "/api/server" }],
   "functions": {
     "api/server.ts": {
-      "maxDuration": 60
+      "maxDuration": 800
     }
   }
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# f06b1b03ed41a5cc377aa9b126e9f27eb9ea074a
#KEY#COMMIT_DATE# 2025-03-09 12:41:17 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# race
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- README.md

#KEY#DIFF_RANGE# FROM: 9487c4e8241c44a99ef3a3045520d74698cb8927 TO: f06b1b03ed41a5cc377aa9b126e9f27eb9ea074a
=================================================================

#KEY#GIT_DIFF#

diff --git a/README.md b/README.md
index cd601cb..29ccb91 100644
--- a/README.md
+++ b/README.md
@@ -1,20 +1,20 @@
 # Run an MCP Server on Vercel
 
 ## Usage
 
 Update `api/server.ts` with your tools, prompts, and resources following the [MCP TypeScript SDK documentation](https://github.com/modelcontextprotocol/typescript-sdk/tree/main?tab=readme-ov-file#server).
 
 ## Notes for running on Vercel
 
 - Requires a Redis attached to the project under process.env.REDIS_URL
 - Make sure you have [Fluid compute](https://vercel.com/docs/functions/fluid-compute) enabled for efficient execution
-- After enabling Fluid compute, open `vercel.json` and adjust max duration to 800 if you using a Vercel Pro or Enterprise account
+- After enabling Fluid compute, open `vercel.json` and adjust max duration to 800
 - [Deploy the MCP template](https://vercel.com/templates/other/model-context-protocol-mcp-with-vercel-functions)
 
 ## Sample Client
 
 `script/test-client.mjs` contains a sample client to try invocations.
 
 ```sh
 node scripts/test-client.mjs https://mcp-on-vercel.vercel.app
 ```
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 7851501904b8d64b8dd2b857be385708887bbd2f
#KEY#COMMIT_DATE# 2025-03-09 12:37:41 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# no-need-to-expire
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: f06b1b03ed41a5cc377aa9b126e9f27eb9ea074a TO: 7851501904b8d64b8dd2b857be385708887bbd2f
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index ae6a278..7c36109 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -81,196 +81,196 @@ export function initializeMcpApiHandler(
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b: unknown) => {
           body = b as string;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         await redisPublisher.publish(
           `responses:${sessionId}:${request.requestId}`,
           JSON.stringify({
             status,
             body,
           })
         );
 
         if (status >= 200 && status < 300) {
           logInContext(
             "log",
             `Request ${sessionId}:${request.requestId} succeeded: ${body}`
           );
         } else {
           logInContext(
             "error",
             `Message for ${sessionId}:${request.requestId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, 795 * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
       const requestId = crypto.randomUUID();
       const serializedRequest: SerializedRequest = {
         requestId,
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
-      // Handles responses from the /sse endpoint.
-      await redis.subscribe(
-        `responses:${sessionId}:${requestId}`,
-        (message) => {
-          clearTimeout(timeout);
-          const response = JSON.parse(message) as {
-            status: number;
-            body: string;
-          };
-          res.statusCode = response.status;
-          res.end(response.body);
-        }
-      );
-
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await redisPublisher.publish(
         `requests:${sessionId}`,
         JSON.stringify(serializedRequest)
       );
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
       let timeout = setTimeout(async () => {
         await redis.unsubscribe(`responses:${sessionId}:${requestId}`);
         res.statusCode = 408;
         res.end("Request timed out");
       }, 10 * 1000);
 
+      // Handles responses from the /sse endpoint.
+      await redis.subscribe(
+        `responses:${sessionId}:${requestId}`,
+        (message) => {
+          clearTimeout(timeout);
+          const response = JSON.parse(message) as {
+            status: number;
+            body: string;
+          };
+          res.statusCode = response.status;
+          res.end(response.body);
+        }
+      );
+
       res.on("close", async () => {
         clearTimeout(timeout);
         await redis.unsubscribe(`responses:${sessionId}:${requestId}`);
       });
     } else if (url.pathname === "/") {
     } else if (url.pathname === "/") {
       res.statusCode = 200;
       res.end("Hello, world!");
     } else {
       res.statusCode = 404;
       res.end("Not found");
     }
   };
 }
 
 // Define the options interface
 interface FakeIncomingMessageOptions {
   method?: string;
   url?: string;
   headers?: IncomingHttpHeaders;
   body?: string | Buffer | Record<string, any> | null;
   socket?: Socket;
 }
 
 // Create a fake IncomingMessage
 function createFakeIncomingMessage(
   options: FakeIncomingMessageOptions = {}
 ): IncomingMessage {
   const {
     method = "GET",
     url = "/",
     headers = {},
     body = null,
     socket = new Socket(),
   } = options;
 
   // Create a readable stream that will be used as the base for IncomingMessage
   const readable = new Readable();
   readable._read = (): void => {}; // Required implementation
 
   // Add the body content if provided
   if (body) {
     if (typeof body === "string") {
       readable.push(body);
     } else if (Buffer.isBuffer(body)) {
       readable.push(body);
     } else {
       readable.push(JSON.stringify(body));
     }
     readable.push(null); // Signal the end of the stream
   }
 
   // Create the IncomingMessage instance
   const req = new IncomingMessage(socket);
 
   // Set the properties
   req.method = method;
   req.url = url;
   req.headers = headers;
 
   // Copy over the stream methods
   req.push = readable.push.bind(readable);
   req.read = readable.read.bind(readable);
   req.on = readable.on.bind(readable);
   req.pipe = readable.pipe.bind(readable);
 
   return req;
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# b101f02c5e597a274baf427b3de84b06b44f76dd
#KEY#COMMIT_DATE# 2025-03-09 12:35:13 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# log
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: 7851501904b8d64b8dd2b857be385708887bbd2f TO: b101f02c5e597a274baf427b3de84b06b44f76dd
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index 7c36109..c1ed55d 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -4,273 +4,282 @@ import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { createClient } from "redis";
 import { Socket } from "net";
 import { Readable } from "stream";
 import { ServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
 
 interface SerializedRequest {
   requestId: string;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 const redis = createClient({
   url: process.env.REDIS_URL || process.env.KV_URL,
 });
 const redisPublisher = createClient({
   url: process.env.REDIS_URL || process.env.KV_URL,
 });
 redis.on("error", (err) => {
   console.error("Redis error", err);
 });
 redisPublisher.on("error", (err) => {
   console.error("Redis error", err);
 });
 const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 
 let servers: McpServer[] = [];
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer) => void,
   serverOptions: ServerOptions = {}
 ) {
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript server on vercel",
           version: "0.1.0",
         },
         serverOptions
       );
       initializeServer(server);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       // Handles messages originally received via /message
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b: unknown) => {
           body = b as string;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
-        await redisPublisher.publish(
-          `responses:${sessionId}:${request.requestId}`,
-          JSON.stringify({
-            status,
-            body,
-          })
-        );
+        await Promise.all([
+          redisPublisher.publish(
+            `responses:${sessionId}:${request.requestId}`,
+            JSON.stringify({
+              status,
+              body,
+            })
+          ),
+          redisPublisher.expire(
+            `responses:${sessionId}:${request.requestId}`,
+            60 * 60
+          ), // 1 hour
+        ]);
 
         if (status >= 200 && status < 300) {
           logInContext(
             "log",
             `Request ${sessionId}:${request.requestId} succeeded: ${body}`
           );
         } else {
           logInContext(
             "error",
             `Message for ${sessionId}:${request.requestId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, 795 * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
       const requestId = crypto.randomUUID();
       const serializedRequest: SerializedRequest = {
         requestId,
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
-      await redisPublisher.publish(
-        `requests:${sessionId}`,
-        JSON.stringify(serializedRequest)
-      );
+      await Promise.all([
+        redisPublisher.publish(
+          `requests:${sessionId}`,
+          JSON.stringify(serializedRequest)
+        ),
+        redisPublisher.expire(`requests:${sessionId}`, 60 * 60), // 1 hour
+      ]);
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
-      let timeout = setTimeout(async () => {
-        await redis.unsubscribe(`responses:${sessionId}:${requestId}`);
+      let timeout = setTimeout(() => {
+        redis.unsubscribe(`responses:${sessionId}:${requestId}`);
         res.statusCode = 408;
         res.end("Request timed out");
       }, 10 * 1000);
 
       // Handles responses from the /sse endpoint.
       await redis.subscribe(
         `responses:${sessionId}:${requestId}`,
         (message) => {
           clearTimeout(timeout);
           const response = JSON.parse(message) as {
             status: number;
             body: string;
           };
           res.statusCode = response.status;
           res.end(response.body);
         }
       );
 
-      res.on("close", async () => {
+      res.on("close", () => {
         clearTimeout(timeout);
-        await redis.unsubscribe(`responses:${sessionId}:${requestId}`);
+        redis.unsubscribe(`responses:${sessionId}:${requestId}`);
       });
     } else if (url.pathname === "/") {
     } else if (url.pathname === "/") {
       res.statusCode = 200;
       res.end("Hello, world!");
     } else {
       res.statusCode = 404;
       res.end("Not found");
     }
   };
 }
 
 // Define the options interface
 interface FakeIncomingMessageOptions {
   method?: string;
   url?: string;
   headers?: IncomingHttpHeaders;
   body?: string | Buffer | Record<string, any> | null;
   socket?: Socket;
 }
 
 // Create a fake IncomingMessage
 function createFakeIncomingMessage(
   options: FakeIncomingMessageOptions = {}
 ): IncomingMessage {
   const {
     method = "GET",
     url = "/",
     headers = {},
     body = null,
     socket = new Socket(),
   } = options;
 
   // Create a readable stream that will be used as the base for IncomingMessage
   const readable = new Readable();
   readable._read = (): void => {}; // Required implementation
 
   // Add the body content if provided
   if (body) {
     if (typeof body === "string") {
       readable.push(body);
     } else if (Buffer.isBuffer(body)) {
       readable.push(body);
     } else {
       readable.push(JSON.stringify(body));
     }
     readable.push(null); // Signal the end of the stream
   }
 
   // Create the IncomingMessage instance
   const req = new IncomingMessage(socket);
 
   // Set the properties
   req.method = method;
   req.url = url;
   req.headers = headers;
 
   // Copy over the stream methods
   req.push = readable.push.bind(readable);
   req.read = readable.read.bind(readable);
   req.on = readable.on.bind(readable);
   req.pipe = readable.pipe.bind(readable);
 
   return req;
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 2b14ea90c75b0b9710cea5cb2ed29ebee5b5e06a
#KEY#COMMIT_DATE# 2025-03-09 12:30:10 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# await-sub
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: b101f02c5e597a274baf427b3de84b06b44f76dd TO: 2b14ea90c75b0b9710cea5cb2ed29ebee5b5e06a
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index c1ed55d..5455674 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -12,215 +12,209 @@ interface SerializedRequest {
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 const redis = createClient({
   url: process.env.REDIS_URL || process.env.KV_URL,
 });
 const redisPublisher = createClient({
   url: process.env.REDIS_URL || process.env.KV_URL,
 });
 redis.on("error", (err) => {
   console.error("Redis error", err);
 });
 redisPublisher.on("error", (err) => {
   console.error("Redis error", err);
 });
 const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 
 let servers: McpServer[] = [];
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer) => void,
   serverOptions: ServerOptions = {}
 ) {
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript server on vercel",
           version: "0.1.0",
         },
         serverOptions
       );
       initializeServer(server);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       // Handles messages originally received via /message
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b: unknown) => {
           body = b as string;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         await Promise.all([
           redisPublisher.publish(
             `responses:${sessionId}:${request.requestId}`,
             JSON.stringify({
               status,
               body,
             })
           ),
-          redisPublisher.expire(
-            `responses:${sessionId}:${request.requestId}`,
-            60 * 60
-          ), // 1 hour
+          redisPublisher.expire(`responses:${sessionId}`, 60 * 60), // 1 hour
         ]);
 
         if (status >= 200 && status < 300) {
-          logInContext(
-            "log",
-            `Request ${sessionId}:${request.requestId} succeeded: ${body}`
-          );
+          logInContext("log", `Request ${sessionId} succeeded: ${body}`);
         } else {
           logInContext(
             "error",
-            `Message for ${sessionId}:${request.requestId} failed with status ${status}: ${body}`
+            `Message for ${sessionId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, 795 * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
       const requestId = crypto.randomUUID();
       const serializedRequest: SerializedRequest = {
         requestId,
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await Promise.all([
         redisPublisher.publish(
           `requests:${sessionId}`,
           JSON.stringify(serializedRequest)
         ),
         redisPublisher.expire(`requests:${sessionId}`, 60 * 60), // 1 hour
       ]);
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
       let timeout = setTimeout(() => {
         redis.unsubscribe(`responses:${sessionId}:${requestId}`);
         res.statusCode = 408;
         res.end("Request timed out");
       }, 10 * 1000);
 
       // Handles responses from the /sse endpoint.
       await redis.subscribe(
         `responses:${sessionId}:${requestId}`,
         (message) => {
           clearTimeout(timeout);
           const response = JSON.parse(message) as {
             status: number;
             body: string;
           };
           res.statusCode = response.status;
           res.end(response.body);
         }
       );
 
       res.on("close", () => {
         clearTimeout(timeout);
         redis.unsubscribe(`responses:${sessionId}:${requestId}`);
       });
     } else if (url.pathname === "/") {
     } else if (url.pathname === "/") {
       res.statusCode = 200;
       res.end("Hello, world!");
     } else {
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 07ae07f99d156f128a1d467374afa794c9b8baa9
#KEY#COMMIT_DATE# 2025-03-09 12:20:27 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# publish
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: 2b14ea90c75b0b9710cea5cb2ed29ebee5b5e06a TO: 07ae07f99d156f128a1d467374afa794c9b8baa9
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index 5455674..1fd68f6 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -96,184 +96,181 @@ export function initializeMcpApiHandler(
           return syntheticRes;
         };
         syntheticRes.end = (b: unknown) => {
           body = b as string;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         await Promise.all([
           redisPublisher.publish(
             `responses:${sessionId}:${request.requestId}`,
             JSON.stringify({
               status,
               body,
             })
           ),
           redisPublisher.expire(`responses:${sessionId}`, 60 * 60), // 1 hour
         ]);
 
         if (status >= 200 && status < 300) {
           logInContext("log", `Request ${sessionId} succeeded: ${body}`);
         } else {
           logInContext(
             "error",
             `Message for ${sessionId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, 795 * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
       const requestId = crypto.randomUUID();
       const serializedRequest: SerializedRequest = {
         requestId,
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await Promise.all([
         redisPublisher.publish(
           `requests:${sessionId}`,
           JSON.stringify(serializedRequest)
         ),
         redisPublisher.expire(`requests:${sessionId}`, 60 * 60), // 1 hour
       ]);
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
       let timeout = setTimeout(() => {
         redis.unsubscribe(`responses:${sessionId}:${requestId}`);
         res.statusCode = 408;
         res.end("Request timed out");
-      }, 10 * 1000);
+      }, 60 * 1000);
 
       // Handles responses from the /sse endpoint.
-      await redis.subscribe(
-        `responses:${sessionId}:${requestId}`,
-        (message) => {
-          clearTimeout(timeout);
-          const response = JSON.parse(message) as {
-            status: number;
-            body: string;
-          };
-          res.statusCode = response.status;
-          res.end(response.body);
-        }
-      );
+      redis.subscribe(`responses:${sessionId}:${requestId}`, (message) => {
+        clearTimeout(timeout);
+        const response = JSON.parse(message) as {
+          status: number;
+          body: string;
+        };
+        res.statusCode = response.status;
+        res.end(response.body);
+      });
 
       res.on("close", () => {
         clearTimeout(timeout);
         redis.unsubscribe(`responses:${sessionId}:${requestId}`);
       });
     } else if (url.pathname === "/") {
     } else if (url.pathname === "/") {
       res.statusCode = 200;
       res.end("Hello, world!");
     } else {
       res.statusCode = 404;
       res.end("Not found");
     }
   };
 }
 
 // Define the options interface
 interface FakeIncomingMessageOptions {
   method?: string;
   url?: string;
   headers?: IncomingHttpHeaders;
   body?: string | Buffer | Record<string, any> | null;
   socket?: Socket;
 }
 
 // Create a fake IncomingMessage
 function createFakeIncomingMessage(
   options: FakeIncomingMessageOptions = {}
 ): IncomingMessage {
   const {
     method = "GET",
     url = "/",
     headers = {},
     body = null,
     socket = new Socket(),
   } = options;
 
   // Create a readable stream that will be used as the base for IncomingMessage
   const readable = new Readable();
   readable._read = (): void => {}; // Required implementation
 
   // Add the body content if provided
   if (body) {
     if (typeof body === "string") {
       readable.push(body);
     } else if (Buffer.isBuffer(body)) {
       readable.push(body);
     } else {
       readable.push(JSON.stringify(body));
     }
     readable.push(null); // Signal the end of the stream
   }
 
   // Create the IncomingMessage instance
   const req = new IncomingMessage(socket);
 
   // Set the properties
   req.method = method;
   req.url = url;
   req.headers = headers;
 
   // Copy over the stream methods
   req.push = readable.push.bind(readable);
   req.read = readable.read.bind(readable);
   req.on = readable.on.bind(readable);
   req.pipe = readable.pipe.bind(readable);
 
   return req;
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 3520d7964f78810611cef2adad996691cb08deac
#KEY#COMMIT_DATE# 2025-03-09 12:14:44 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# kv-support
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: 07ae07f99d156f128a1d467374afa794c9b8baa9 TO: 3520d7964f78810611cef2adad996691cb08deac
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index 1fd68f6..185d9e5 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -84,193 +84,193 @@ export function initializeMcpApiHandler(
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b: unknown) => {
           body = b as string;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         await Promise.all([
           redisPublisher.publish(
             `responses:${sessionId}:${request.requestId}`,
             JSON.stringify({
               status,
               body,
             })
           ),
           redisPublisher.expire(`responses:${sessionId}`, 60 * 60), // 1 hour
         ]);
 
         if (status >= 200 && status < 300) {
           logInContext("log", `Request ${sessionId} succeeded: ${body}`);
         } else {
           logInContext(
             "error",
             `Message for ${sessionId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, 795 * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
       const requestId = crypto.randomUUID();
       const serializedRequest: SerializedRequest = {
         requestId,
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await Promise.all([
-        redisPublisher.publish(
+        redis.publish(
           `requests:${sessionId}`,
           JSON.stringify(serializedRequest)
         ),
-        redisPublisher.expire(`requests:${sessionId}`, 60 * 60), // 1 hour
+        redis.expire(`requests:${sessionId}`, 60 * 60), // 1 hour
       ]);
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
       let timeout = setTimeout(() => {
         redis.unsubscribe(`responses:${sessionId}:${requestId}`);
         res.statusCode = 408;
         res.end("Request timed out");
       }, 60 * 1000);
 
       // Handles responses from the /sse endpoint.
       redis.subscribe(`responses:${sessionId}:${requestId}`, (message) => {
         clearTimeout(timeout);
         const response = JSON.parse(message) as {
           status: number;
           body: string;
         };
         res.statusCode = response.status;
         res.end(response.body);
       });
 
       res.on("close", () => {
         clearTimeout(timeout);
         redis.unsubscribe(`responses:${sessionId}:${requestId}`);
       });
     } else if (url.pathname === "/") {
     } else if (url.pathname === "/") {
       res.statusCode = 200;
       res.end("Hello, world!");
     } else {
       res.statusCode = 404;
       res.end("Not found");
     }
   };
 }
 
 // Define the options interface
 interface FakeIncomingMessageOptions {
   method?: string;
   url?: string;
   headers?: IncomingHttpHeaders;
   body?: string | Buffer | Record<string, any> | null;
   socket?: Socket;
 }
 
 // Create a fake IncomingMessage
 function createFakeIncomingMessage(
   options: FakeIncomingMessageOptions = {}
 ): IncomingMessage {
   const {
     method = "GET",
     url = "/",
     headers = {},
     body = null,
     socket = new Socket(),
   } = options;
 
   // Create a readable stream that will be used as the base for IncomingMessage
   const readable = new Readable();
   readable._read = (): void => {}; // Required implementation
 
   // Add the body content if provided
   if (body) {
     if (typeof body === "string") {
       readable.push(body);
     } else if (Buffer.isBuffer(body)) {
       readable.push(body);
     } else {
       readable.push(JSON.stringify(body));
     }
     readable.push(null); // Signal the end of the stream
   }
 
   // Create the IncomingMessage instance
   const req = new IncomingMessage(socket);
 
   // Set the properties
   req.method = method;
   req.url = url;
   req.headers = headers;
 
   // Copy over the stream methods
   req.push = readable.push.bind(readable);
   req.read = readable.read.bind(readable);
   req.on = readable.on.bind(readable);
   req.pipe = readable.pipe.bind(readable);
 
   return req;
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# a9f768aa602baa9d956e453539dcd0cce88b3fe3
#KEY#COMMIT_DATE# 2025-03-09 12:14:11 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# max-duration
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: 3520d7964f78810611cef2adad996691cb08deac TO: a9f768aa602baa9d956e453539dcd0cce88b3fe3
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index 185d9e5..bd28170 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,123 +1,119 @@
 import getRawBody from "raw-body";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { createClient } from "redis";
 import { Socket } from "net";
 import { Readable } from "stream";
 import { ServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
 
 interface SerializedRequest {
   requestId: string;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
-const redis = createClient({
-  url: process.env.REDIS_URL || process.env.KV_URL,
-});
-const redisPublisher = createClient({
-  url: process.env.REDIS_URL || process.env.KV_URL,
-});
+const redis = createClient({ url: process.env.REDIS_URL });
+const redisPublisher = createClient({ url: process.env.REDIS_URL });
 redis.on("error", (err) => {
   console.error("Redis error", err);
 });
 redisPublisher.on("error", (err) => {
   console.error("Redis error", err);
 });
 const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 
 let servers: McpServer[] = [];
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer) => void,
   serverOptions: ServerOptions = {}
 ) {
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript server on vercel",
           version: "0.1.0",
         },
         serverOptions
       );
       initializeServer(server);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       // Handles messages originally received via /message
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b: unknown) => {
           body = b as string;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         await Promise.all([
           redisPublisher.publish(
             `responses:${sessionId}:${request.requestId}`,
             JSON.stringify({
               status,
               body,
             })
           ),
           redisPublisher.expire(`responses:${sessionId}`, 60 * 60), // 1 hour
         ]);
 
         if (status >= 200 && status < 300) {
           logInContext("log", `Request ${sessionId} succeeded: ${body}`);
         } else {
           logInContext(
             "error",
             `Message for ${sessionId} failed with status ${status}: ${body}`
           );
         }
       };
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 9a7818c5af5c5fcc3e13736feb79cef671aae8c6
#KEY#COMMIT_DATE# 2025-03-09 12:06:16 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# Update README.md
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- README.md

#KEY#DIFF_RANGE# FROM: a9f768aa602baa9d956e453539dcd0cce88b3fe3 TO: 9a7818c5af5c5fcc3e13736feb79cef671aae8c6
=================================================================

#KEY#GIT_DIFF#

diff --git a/README.md b/README.md
index 29ccb91..42dd386 100644
--- a/README.md
+++ b/README.md
@@ -1,20 +1,19 @@
 # Run an MCP Server on Vercel
 
 ## Usage
 
 Update `api/server.ts` with your tools, prompts, and resources following the [MCP TypeScript SDK documentation](https://github.com/modelcontextprotocol/typescript-sdk/tree/main?tab=readme-ov-file#server).
 
 ## Notes for running on Vercel
 
 - Requires a Redis attached to the project under process.env.REDIS_URL
 - Make sure you have [Fluid compute](https://vercel.com/docs/functions/fluid-compute) enabled for efficient execution
-- After enabling Fluid compute, open `vercel.json` and adjust max duration to 800
 - [Deploy the MCP template](https://vercel.com/templates/other/model-context-protocol-mcp-with-vercel-functions)
 
 ## Sample Client
 
 `script/test-client.mjs` contains a sample client to try invocations.
 
 ```sh
 node scripts/test-client.mjs https://mcp-on-vercel.vercel.app
 ```
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# d2060ccb586172a50c0fd7898513e84901e88a9f
#KEY#COMMIT_DATE# 2025-03-09 12:05:22 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# Link
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- README.md

#KEY#DIFF_RANGE# FROM: 9a7818c5af5c5fcc3e13736feb79cef671aae8c6 TO: d2060ccb586172a50c0fd7898513e84901e88a9f
=================================================================

#KEY#GIT_DIFF#

diff --git a/README.md b/README.md
index 42dd386..ec9ec0e 100644
--- a/README.md
+++ b/README.md
@@ -1,19 +1,18 @@
 # Run an MCP Server on Vercel
 
 ## Usage
 
 Update `api/server.ts` with your tools, prompts, and resources following the [MCP TypeScript SDK documentation](https://github.com/modelcontextprotocol/typescript-sdk/tree/main?tab=readme-ov-file#server).
 
 ## Notes for running on Vercel
 
 - Requires a Redis attached to the project under process.env.REDIS_URL
 - Make sure you have [Fluid compute](https://vercel.com/docs/functions/fluid-compute) enabled for efficient execution
-- [Deploy the MCP template](https://vercel.com/templates/other/model-context-protocol-mcp-with-vercel-functions)
 
 ## Sample Client
 
 `script/test-client.mjs` contains a sample client to try invocations.
 
 ```sh
 node scripts/test-client.mjs https://mcp-on-vercel.vercel.app
 ```
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 446347302ef28486debdb361b4108421709ac205
#KEY#COMMIT_DATE# 2025-03-09 11:58:33 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# Capability support
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- public/index.html
- scripts/test-client.mjs

#KEY#DIFF_RANGE# FROM: d2060ccb586172a50c0fd7898513e84901e88a9f TO: 446347302ef28486debdb361b4108421709ac205
=================================================================

#KEY#GIT_DIFF#

diff --git a/public/index.html b/public/index.html
index ee251a5..7db4a35 100644
--- a/public/index.html
+++ b/public/index.html
@@ -1,10 +1,3 @@
 <h1>MCP on Vercel</h1>
 
-<p>Protocol is mounted below /.</p>
-
-<p>
-  <a
-    href="https://vercel.com/templates/other/model-context-protocol-mcp-with-vercel-functions"
-    >Clone template on Vercel</a
-  >
-</p>
+<p>Protocol is mounted below /</p>
diff --git a/scripts/test-client.mjs b/scripts/test-client.mjs
index 4d6485b..5b00ceb 100644
--- a/scripts/test-client.mjs
+++ b/scripts/test-client.mjs
@@ -1,31 +1,31 @@
 import { Client } from "@modelcontextprotocol/sdk/client/index.js";
 import { SSEClientTransport } from "@modelcontextprotocol/sdk/client/sse.js";
 
 const origin = process.argv[2] || "https://mcp-on-vercel.vercel.app";
 
 async function main() {
   const transport = new SSEClientTransport(new URL(`${origin}/sse`));
 
   const client = new Client(
     {
       name: "example-client",
       version: "1.0.0",
     },
     {
       capabilities: {
         prompts: {},
         resources: {},
         tools: {},
       },
     }
   );
 
   await client.connect(transport);
 
-  console.log("Connected", client.getServerCapabilities());
+  console.log("Connected", client.getClientCapabilities());
 
   const result = await client.listTools();
   console.log(result);
 }
 
 main();
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# fd398850a9ca494068237cea4700d3968fe7812a
#KEY#COMMIT_DATE# 2025-03-09 11:57:35 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# Capability support
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- scripts/test-client.mjs

#KEY#DIFF_RANGE# FROM: 446347302ef28486debdb361b4108421709ac205 TO: fd398850a9ca494068237cea4700d3968fe7812a
=================================================================

#KEY#GIT_DIFF#

diff --git a/scripts/test-client.mjs b/scripts/test-client.mjs
index 5b00ceb..0f2da79 100644
--- a/scripts/test-client.mjs
+++ b/scripts/test-client.mjs
@@ -1,31 +1,31 @@
 import { Client } from "@modelcontextprotocol/sdk/client/index.js";
 import { SSEClientTransport } from "@modelcontextprotocol/sdk/client/sse.js";
 
 const origin = process.argv[2] || "https://mcp-on-vercel.vercel.app";
 
 async function main() {
   const transport = new SSEClientTransport(new URL(`${origin}/sse`));
 
   const client = new Client(
     {
       name: "example-client",
       version: "1.0.0",
     },
     {
       capabilities: {
         prompts: {},
         resources: {},
         tools: {},
       },
     }
   );
 
   await client.connect(transport);
 
-  console.log("Connected", client.getClientCapabilities());
+  console.log("Connected");
 
   const result = await client.listTools();
   console.log(result);
 }
 
 main();
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 88d3dcf9a8b6cdfee53b40ffc7a792748d71ef17
#KEY#COMMIT_DATE# 2025-03-09 11:41:08 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# Update index.html
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/server.ts
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: fd398850a9ca494068237cea4700d3968fe7812a TO: 88d3dcf9a8b6cdfee53b40ffc7a792748d71ef17
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/server.ts b/api/server.ts
index 3459a78..3872766 100644
--- a/api/server.ts
+++ b/api/server.ts
@@ -1,22 +1,11 @@
 import { z } from "zod";
 import { initializeMcpApiHandler } from "../lib/mcp-api-handler";
 
-const handler = initializeMcpApiHandler(
-  (server) => {
-    // Add more tools, resources, and prompts here
-    server.tool("echo", { message: z.string() }, async ({ message }) => ({
-      content: [{ type: "text", text: `Tool echo: ${message}` }],
-    }));
-  },
-  {
-    capabilities: {
-      tools: {
-        echo: {
-          description: "Echo a message",
-        },
-      },
-    },
-  }
-);
+const handler = initializeMcpApiHandler((server) => {
+  // Add more tools, resources, and prompts here
+  server.tool("echo", { message: z.string() }, async ({ message }) => ({
+    content: [{ type: "text", text: `Tool echo: ${message}` }],
+  }));
+});
 
 export default handler;
diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index bd28170..3d443c9 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,268 +1,271 @@
 import getRawBody from "raw-body";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { createClient } from "redis";
 import { Socket } from "net";
 import { Readable } from "stream";
-import { ServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
 
 interface SerializedRequest {
-  requestId: string;
+  requestId: number;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 const redis = createClient({ url: process.env.REDIS_URL });
 const redisPublisher = createClient({ url: process.env.REDIS_URL });
 redis.on("error", (err) => {
   console.error("Redis error", err);
 });
 redisPublisher.on("error", (err) => {
   console.error("Redis error", err);
 });
 const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 
 let servers: McpServer[] = [];
 
+// Used for Redis-backed RPC between SSE client and message server.
+let nextRequestId = 0;
+
 export function initializeMcpApiHandler(
-  initializeServer: (server: McpServer) => void,
-  serverOptions: ServerOptions = {}
+  initializeServer: (server: McpServer) => void
 ) {
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
-          name: "mcp-typescript server on vercel",
+          name: "mcp-typescript test server on vercel",
           version: "0.1.0",
         },
-        serverOptions
+        {
+          capabilities: {},
+        }
       );
       initializeServer(server);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       // Handles messages originally received via /message
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b: unknown) => {
           body = b as string;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         await Promise.all([
           redisPublisher.publish(
             `responses:${sessionId}:${request.requestId}`,
             JSON.stringify({
               status,
               body,
             })
           ),
           redisPublisher.expire(`responses:${sessionId}`, 60 * 60), // 1 hour
         ]);
 
         if (status >= 200 && status < 300) {
           logInContext("log", `Request ${sessionId} succeeded: ${body}`);
         } else {
           logInContext(
             "error",
             `Message for ${sessionId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, 795 * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
-      const requestId = crypto.randomUUID();
+      const requestId = nextRequestId++;
       const serializedRequest: SerializedRequest = {
         requestId,
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await Promise.all([
         redis.publish(
           `requests:${sessionId}`,
           JSON.stringify(serializedRequest)
         ),
         redis.expire(`requests:${sessionId}`, 60 * 60), // 1 hour
       ]);
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
       let timeout = setTimeout(() => {
         redis.unsubscribe(`responses:${sessionId}:${requestId}`);
         res.statusCode = 408;
         res.end("Request timed out");
       }, 60 * 1000);
 
       // Handles responses from the /sse endpoint.
       redis.subscribe(`responses:${sessionId}:${requestId}`, (message) => {
         clearTimeout(timeout);
         const response = JSON.parse(message) as {
           status: number;
           body: string;
         };
         res.statusCode = response.status;
         res.end(response.body);
       });
 
       res.on("close", () => {
         clearTimeout(timeout);
         redis.unsubscribe(`responses:${sessionId}:${requestId}`);
       });
     } else if (url.pathname === "/") {
     } else if (url.pathname === "/") {
       res.statusCode = 200;
       res.end("Hello, world!");
     } else {
       res.statusCode = 404;
       res.end("Not found");
     }
   };
 }
 
 // Define the options interface
 interface FakeIncomingMessageOptions {
   method?: string;
   url?: string;
   headers?: IncomingHttpHeaders;
   body?: string | Buffer | Record<string, any> | null;
   socket?: Socket;
 }
 
 // Create a fake IncomingMessage
 function createFakeIncomingMessage(
   options: FakeIncomingMessageOptions = {}
 ): IncomingMessage {
   const {
     method = "GET",
     url = "/",
     headers = {},
     body = null,
     socket = new Socket(),
   } = options;
 
   // Create a readable stream that will be used as the base for IncomingMessage
   const readable = new Readable();
   readable._read = (): void => {}; // Required implementation
 
   // Add the body content if provided
   if (body) {
     if (typeof body === "string") {
       readable.push(body);
     } else if (Buffer.isBuffer(body)) {
       readable.push(body);
     } else {
       readable.push(JSON.stringify(body));
     }
     readable.push(null); // Signal the end of the stream
   }
 
   // Create the IncomingMessage instance
   const req = new IncomingMessage(socket);
 
   // Set the properties
   req.method = method;
   req.url = url;
   req.headers = headers;
 
   // Copy over the stream methods
   req.push = readable.push.bind(readable);
   req.read = readable.read.bind(readable);
   req.on = readable.on.bind(readable);
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 96909ab6540fee77fbe53f481fd5d65c301ec7e1
#KEY#COMMIT_DATE# 2025-03-09 11:33:27 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# Update README.md
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- public/index.html

#KEY#DIFF_RANGE# FROM: 88d3dcf9a8b6cdfee53b40ffc7a792748d71ef17 TO: 96909ab6540fee77fbe53f481fd5d65c301ec7e1
=================================================================

#KEY#GIT_DIFF#

diff --git a/public/index.html b/public/index.html
index 7db4a35..364c27b 100644
--- a/public/index.html
+++ b/public/index.html
@@ -1,3 +1,3 @@
 <h1>MCP on Vercel</h1>
 
-<p>Protocol is mounted below /</p>
+<p>Protocol is mounted on /</p>
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 3b64f6e9235b2412e6eca6a03d556354aac4f3ca
#KEY#COMMIT_DATE# 2025-03-09 11:28:34 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# cleanup
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- README.md

#KEY#DIFF_RANGE# FROM: 96909ab6540fee77fbe53f481fd5d65c301ec7e1 TO: 3b64f6e9235b2412e6eca6a03d556354aac4f3ca
=================================================================

#KEY#GIT_DIFF#

diff --git a/README.md b/README.md
index ec9ec0e..c88696f 100644
--- a/README.md
+++ b/README.md
@@ -1,18 +1,18 @@
 # Run an MCP Server on Vercel
 
 ## Usage
 
-Update `api/server.ts` with your tools, prompts, and resources following the [MCP TypeScript SDK documentation](https://github.com/modelcontextprotocol/typescript-sdk/tree/main?tab=readme-ov-file#server).
+Update `api/server.ts` with your tools, prompts, and resources following the [MSC TypeScript SDK documentation](https://github.com/modelcontextprotocol/typescript-sdk/tree/main?tab=readme-ov-file#server).
 
 ## Notes for running on Vercel
 
 - Requires a Redis attached to the project under process.env.REDIS_URL
 - Make sure you have [Fluid compute](https://vercel.com/docs/functions/fluid-compute) enabled for efficient execution
 
 ## Sample Client
 
 `script/test-client.mjs` contains a sample client to try invocations.
 
 ```sh
 node scripts/test-client.mjs https://mcp-on-vercel.vercel.app
 ```
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# d85d23f1ae167fcb12aced3cdae4316f6a8edb6d
#KEY#COMMIT_DATE# 2025-03-09 11:15:23 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# publish
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- README.md
- api/server.ts
- lib/mcp-api-handler.ts
- scripts/test-client.mjs

#KEY#DIFF_RANGE# FROM: 3b64f6e9235b2412e6eca6a03d556354aac4f3ca TO: d85d23f1ae167fcb12aced3cdae4316f6a8edb6d
=================================================================

#KEY#GIT_DIFF#

diff --git a/README.md b/README.md
index c88696f..047ce82 100644
--- a/README.md
+++ b/README.md
@@ -1,18 +1,13 @@
 # Run an MCP Server on Vercel
 
-## Usage
-
-Update `api/server.ts` with your tools, prompts, and resources following the [MSC TypeScript SDK documentation](https://github.com/modelcontextprotocol/typescript-sdk/tree/main?tab=readme-ov-file#server).
-
-## Notes for running on Vercel
-
-- Requires a Redis attached to the project under process.env.REDIS_URL
-- Make sure you have [Fluid compute](https://vercel.com/docs/functions/fluid-compute) enabled for efficient execution
-
-## Sample Client
-
-`script/test-client.mjs` contains a sample client to try invocations.
+## Sample POST
 
 ```sh
-node scripts/test-client.mjs https://mcp-on-vercel.vercel.app
+curl -X POST "https://mcp-on-vercel.vercel.app/message?sessionId=3657fb33-19a4-4e05-bc33-3fd17d0fffe8" \
+  -H "Content-Type: application/json" \
+  -d '{
+    "name": "John Doe",
+    "email": "john@example.com",
+    "message": "Hello, world!"
+  }'
 ```
diff --git a/api/server.ts b/api/server.ts
index 3872766..de12598 100644
--- a/api/server.ts
+++ b/api/server.ts
@@ -1,11 +1,10 @@
 import { z } from "zod";
 import { initializeMcpApiHandler } from "../lib/mcp-api-handler";
 
 const handler = initializeMcpApiHandler((server) => {
-  // Add more tools, resources, and prompts here
   server.tool("echo", { message: z.string() }, async ({ message }) => ({
     content: [{ type: "text", text: `Tool echo: ${message}` }],
   }));
 });
 
 export default handler;
diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index 3d443c9..fffb06c 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,275 +1,268 @@
 import getRawBody from "raw-body";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { createClient } from "redis";
 import { Socket } from "net";
 import { Readable } from "stream";
 
 interface SerializedRequest {
   requestId: number;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 const redis = createClient({ url: process.env.REDIS_URL });
 const redisPublisher = createClient({ url: process.env.REDIS_URL });
+const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 redis.on("error", (err) => {
   console.error("Redis error", err);
 });
 redisPublisher.on("error", (err) => {
   console.error("Redis error", err);
 });
-const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 
 let servers: McpServer[] = [];
 
-// Used for Redis-backed RPC between SSE client and message server.
-let nextRequestId = 0;
+let requestId = 0;
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer) => void
 ) {
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript test server on vercel",
           version: "0.1.0",
         },
         {
           capabilities: {},
         }
       );
       initializeServer(server);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
-      // Handles messages originally received via /message
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
-        // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
-        syntheticRes.writeHead = (statusCode: number) => {
+        syntheticRes.writeHead = (statusCode) => {
           status = statusCode;
           return syntheticRes;
         };
-        syntheticRes.end = (b: unknown) => {
-          body = b as string;
+        syntheticRes.end = (b) => {
+          body = b;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
-        await Promise.all([
-          redisPublisher.publish(
-            `responses:${sessionId}:${request.requestId}`,
-            JSON.stringify({
-              status,
-              body,
-            })
-          ),
-          redisPublisher.expire(`responses:${sessionId}`, 60 * 60), // 1 hour
-        ]);
-
+        await redisPublisher.publish(
+          `responses:${sessionId}:${request.requestId}`,
+          JSON.stringify({
+            status,
+            body,
+          })
+        );
+        await redisPublisher.expire(`responses:${sessionId}`, 60 * 60); // 1 hour
         if (status >= 200 && status < 300) {
           logInContext("log", `Request ${sessionId} succeeded: ${body}`);
         } else {
           logInContext(
             "error",
             `Message for ${sessionId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, 795 * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
-      const requestId = nextRequestId++;
+      const myRequestId = requestId++;
       const serializedRequest: SerializedRequest = {
-        requestId,
+        requestId: myRequestId,
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await Promise.all([
         redis.publish(
           `requests:${sessionId}`,
           JSON.stringify(serializedRequest)
         ),
         redis.expire(`requests:${sessionId}`, 60 * 60), // 1 hour
       ]);
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
       let timeout = setTimeout(() => {
-        redis.unsubscribe(`responses:${sessionId}:${requestId}`);
+        redis.unsubscribe(`responses:${sessionId}:${myRequestId}`);
         res.statusCode = 408;
         res.end("Request timed out");
       }, 60 * 1000);
 
-      // Handles responses from the /sse endpoint.
-      redis.subscribe(`responses:${sessionId}:${requestId}`, (message) => {
+      redis.subscribe(`responses:${sessionId}:${myRequestId}`, (message) => {
         clearTimeout(timeout);
         const response = JSON.parse(message) as {
           status: number;
           body: string;
         };
         res.statusCode = response.status;
         res.end(response.body);
       });
 
       res.on("close", () => {
         clearTimeout(timeout);
-        redis.unsubscribe(`responses:${sessionId}:${requestId}`);
+        redis.unsubscribe(`responses:${sessionId}:${myRequestId}`);
       });
     } else if (url.pathname === "/") {
     } else if (url.pathname === "/") {
       res.statusCode = 200;
       res.end("Hello, world!");
     } else {
       res.statusCode = 404;
       res.end("Not found");
     }
   };
 }
 
 // Define the options interface
 interface FakeIncomingMessageOptions {
   method?: string;
   url?: string;
   headers?: IncomingHttpHeaders;
   body?: string | Buffer | Record<string, any> | null;
   socket?: Socket;
 }
 
 // Create a fake IncomingMessage
 function createFakeIncomingMessage(
   options: FakeIncomingMessageOptions = {}
 ): IncomingMessage {
   const {
     method = "GET",
     url = "/",
     headers = {},
     body = null,
     socket = new Socket(),
   } = options;
 
   // Create a readable stream that will be used as the base for IncomingMessage
   const readable = new Readable();
   readable._read = (): void => {}; // Required implementation
 
   // Add the body content if provided
   if (body) {
     if (typeof body === "string") {
       readable.push(body);
     } else if (Buffer.isBuffer(body)) {
       readable.push(body);
     } else {
       readable.push(JSON.stringify(body));
     }
     readable.push(null); // Signal the end of the stream
   }
 
   // Create the IncomingMessage instance
   const req = new IncomingMessage(socket);
 
   // Set the properties
   req.method = method;
   req.url = url;
   req.headers = headers;
 
   // Copy over the stream methods
   req.push = readable.push.bind(readable);
   req.read = readable.read.bind(readable);
   req.on = readable.on.bind(readable);
   req.pipe = readable.pipe.bind(readable);
 
   return req;
 }
diff --git a/scripts/test-client.mjs b/scripts/test-client.mjs
index 0f2da79..94d3d85 100644
--- a/scripts/test-client.mjs
+++ b/scripts/test-client.mjs
@@ -1,31 +1,31 @@
 import { Client } from "@modelcontextprotocol/sdk/client/index.js";
 import { SSEClientTransport } from "@modelcontextprotocol/sdk/client/sse.js";
 
-const origin = process.argv[2] || "https://mcp-on-vercel.vercel.app";
-
 async function main() {
-  const transport = new SSEClientTransport(new URL(`${origin}/sse`));
+  const transport = new SSEClientTransport(
+    new URL("https://mcp-on-vercel.vercel.app/sse")
+  );
 
   const client = new Client(
     {
       name: "example-client",
       version: "1.0.0",
     },
     {
       capabilities: {
         prompts: {},
         resources: {},
         tools: {},
       },
     }
   );
 
   await client.connect(transport);
 
   console.log("Connected");
 
-  const result = await client.listTools();
+  const result = await client.listPrompts();
   console.log(result);
 }
 
 main();
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 56ab0165b386113b522636510877dc6f5a1850af
#KEY#COMMIT_DATE# 2025-03-09 11:09:18 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# connect2
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: d85d23f1ae167fcb12aced3cdae4316f6a8edb6d TO: 56ab0165b386113b522636510877dc6f5a1850af
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index fffb06c..c485753 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,207 +1,203 @@
 import getRawBody from "raw-body";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { createClient } from "redis";
 import { Socket } from "net";
 import { Readable } from "stream";
 
 interface SerializedRequest {
   requestId: number;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 const redis = createClient({ url: process.env.REDIS_URL });
-const redisPublisher = createClient({ url: process.env.REDIS_URL });
-const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
+const redisPromise = redis.connect();
 redis.on("error", (err) => {
   console.error("Redis error", err);
 });
-redisPublisher.on("error", (err) => {
-  console.error("Redis error", err);
-});
 
 let servers: McpServer[] = [];
 
 let requestId = 0;
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer) => void
 ) {
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript test server on vercel",
           version: "0.1.0",
         },
         {
           capabilities: {},
         }
       );
       initializeServer(server);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b) => {
           body = b;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
-        await redisPublisher.publish(
+        await redis.publish(
           `responses:${sessionId}:${request.requestId}`,
           JSON.stringify({
             status,
             body,
           })
         );
-        await redisPublisher.expire(`responses:${sessionId}`, 60 * 60); // 1 hour
+        await redis.expire(`responses:${sessionId}`, 60 * 60); // 1 hour
         if (status >= 200 && status < 300) {
           logInContext("log", `Request ${sessionId} succeeded: ${body}`);
         } else {
           logInContext(
             "error",
             `Message for ${sessionId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, 795 * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
       const myRequestId = requestId++;
       const serializedRequest: SerializedRequest = {
         requestId: myRequestId,
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await Promise.all([
         redis.publish(
           `requests:${sessionId}`,
           JSON.stringify(serializedRequest)
         ),
         redis.expire(`requests:${sessionId}`, 60 * 60), // 1 hour
       ]);
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
       let timeout = setTimeout(() => {
         redis.unsubscribe(`responses:${sessionId}:${myRequestId}`);
         res.statusCode = 408;
         res.end("Request timed out");
       }, 60 * 1000);
 
       redis.subscribe(`responses:${sessionId}:${myRequestId}`, (message) => {
         clearTimeout(timeout);
         const response = JSON.parse(message) as {
           status: number;
           body: string;
         };
         res.statusCode = response.status;
         res.end(response.body);
       });
 
       res.on("close", () => {
         clearTimeout(timeout);
         redis.unsubscribe(`responses:${sessionId}:${myRequestId}`);
       });
     } else if (url.pathname === "/") {
     } else if (url.pathname === "/") {
       res.statusCode = 200;
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 7fc08466a38732ab639500964f9c8407d2079872
#KEY#COMMIT_DATE# 2025-03-09 11:06:53 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# connect
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: 56ab0165b386113b522636510877dc6f5a1850af TO: 7fc08466a38732ab639500964f9c8407d2079872
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index c485753..dec0f9e 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,195 +1,196 @@
 import getRawBody from "raw-body";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { createClient } from "redis";
 import { Socket } from "net";
 import { Readable } from "stream";
 
 interface SerializedRequest {
   requestId: number;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 const redis = createClient({ url: process.env.REDIS_URL });
 const redisPromise = redis.connect();
 redis.on("error", (err) => {
   console.error("Redis error", err);
 });
 
 let servers: McpServer[] = [];
 
 let requestId = 0;
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer) => void
 ) {
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript test server on vercel",
           version: "0.1.0",
         },
         {
           capabilities: {},
         }
       );
       initializeServer(server);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b) => {
           body = b;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
+        await redis.connect();
         await redis.publish(
           `responses:${sessionId}:${request.requestId}`,
           JSON.stringify({
             status,
             body,
           })
         );
         await redis.expire(`responses:${sessionId}`, 60 * 60); // 1 hour
         if (status >= 200 && status < 300) {
           logInContext("log", `Request ${sessionId} succeeded: ${body}`);
         } else {
           logInContext(
             "error",
             `Message for ${sessionId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, 795 * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
       const myRequestId = requestId++;
       const serializedRequest: SerializedRequest = {
         requestId: myRequestId,
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await Promise.all([
         redis.publish(
           `requests:${sessionId}`,
           JSON.stringify(serializedRequest)
         ),
         redis.expire(`requests:${sessionId}`, 60 * 60), // 1 hour
       ]);
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
       let timeout = setTimeout(() => {
         redis.unsubscribe(`responses:${sessionId}:${myRequestId}`);
         res.statusCode = 408;
         res.end("Request timed out");
       }, 60 * 1000);
 
       redis.subscribe(`responses:${sessionId}:${myRequestId}`, (message) => {
         clearTimeout(timeout);
         const response = JSON.parse(message) as {
           status: number;
           body: string;
         };
         res.statusCode = response.status;
         res.end(response.body);
       });
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 0c8a0fa7aaa09bf9b0b90bc526dd46b5f3e130a0
#KEY#COMMIT_DATE# 2025-03-09 11:05:35 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# timeout
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: 7fc08466a38732ab639500964f9c8407d2079872 TO: 0c8a0fa7aaa09bf9b0b90bc526dd46b5f3e130a0
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index dec0f9e..c485753 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,196 +1,195 @@
 import getRawBody from "raw-body";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { createClient } from "redis";
 import { Socket } from "net";
 import { Readable } from "stream";
 
 interface SerializedRequest {
   requestId: number;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 const redis = createClient({ url: process.env.REDIS_URL });
 const redisPromise = redis.connect();
 redis.on("error", (err) => {
   console.error("Redis error", err);
 });
 
 let servers: McpServer[] = [];
 
 let requestId = 0;
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer) => void
 ) {
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript test server on vercel",
           version: "0.1.0",
         },
         {
           capabilities: {},
         }
       );
       initializeServer(server);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b) => {
           body = b;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
-        await redis.connect();
         await redis.publish(
           `responses:${sessionId}:${request.requestId}`,
           JSON.stringify({
             status,
             body,
           })
         );
         await redis.expire(`responses:${sessionId}`, 60 * 60); // 1 hour
         if (status >= 200 && status < 300) {
           logInContext("log", `Request ${sessionId} succeeded: ${body}`);
         } else {
           logInContext(
             "error",
             `Message for ${sessionId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, 795 * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
       const myRequestId = requestId++;
       const serializedRequest: SerializedRequest = {
         requestId: myRequestId,
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await Promise.all([
         redis.publish(
           `requests:${sessionId}`,
           JSON.stringify(serializedRequest)
         ),
         redis.expire(`requests:${sessionId}`, 60 * 60), // 1 hour
       ]);
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
       let timeout = setTimeout(() => {
         redis.unsubscribe(`responses:${sessionId}:${myRequestId}`);
         res.statusCode = 408;
         res.end("Request timed out");
       }, 60 * 1000);
 
       redis.subscribe(`responses:${sessionId}:${myRequestId}`, (message) => {
         clearTimeout(timeout);
         const response = JSON.parse(message) as {
           status: number;
           body: string;
         };
         res.statusCode = response.status;
         res.end(response.body);
       });
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 817689835f3d8507e878d2e9bd37b2de9d0a0e5e
#KEY#COMMIT_DATE# 2025-03-09 11:04:52 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# echo
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: 0c8a0fa7aaa09bf9b0b90bc526dd46b5f3e130a0 TO: 817689835f3d8507e878d2e9bd37b2de9d0a0e5e
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index c485753..c002ea3 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -81,184 +81,182 @@ export function initializeMcpApiHandler(
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b) => {
           body = b;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         await redis.publish(
           `responses:${sessionId}:${request.requestId}`,
           JSON.stringify({
             status,
             body,
           })
         );
         await redis.expire(`responses:${sessionId}`, 60 * 60); // 1 hour
         if (status >= 200 && status < 300) {
           logInContext("log", `Request ${sessionId} succeeded: ${body}`);
         } else {
           logInContext(
             "error",
             `Message for ${sessionId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, 795 * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
       const myRequestId = requestId++;
       const serializedRequest: SerializedRequest = {
         requestId: myRequestId,
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await Promise.all([
         redis.publish(
           `requests:${sessionId}`,
           JSON.stringify(serializedRequest)
         ),
         redis.expire(`requests:${sessionId}`, 60 * 60), // 1 hour
       ]);
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
-      let timeout = setTimeout(() => {
+      setTimeout(() => {
         redis.unsubscribe(`responses:${sessionId}:${myRequestId}`);
         res.statusCode = 408;
         res.end("Request timed out");
       }, 60 * 1000);
 
       redis.subscribe(`responses:${sessionId}:${myRequestId}`, (message) => {
-        clearTimeout(timeout);
         const response = JSON.parse(message) as {
           status: number;
           body: string;
         };
         res.statusCode = response.status;
         res.end(response.body);
       });
 
       res.on("close", () => {
-        clearTimeout(timeout);
         redis.unsubscribe(`responses:${sessionId}:${myRequestId}`);
       });
     } else if (url.pathname === "/") {
     } else if (url.pathname === "/") {
       res.statusCode = 200;
       res.end("Hello, world!");
     } else {
       res.statusCode = 404;
       res.end("Not found");
     }
   };
 }
 
 // Define the options interface
 interface FakeIncomingMessageOptions {
   method?: string;
   url?: string;
   headers?: IncomingHttpHeaders;
   body?: string | Buffer | Record<string, any> | null;
   socket?: Socket;
 }
 
 // Create a fake IncomingMessage
 function createFakeIncomingMessage(
   options: FakeIncomingMessageOptions = {}
 ): IncomingMessage {
   const {
     method = "GET",
     url = "/",
     headers = {},
     body = null,
     socket = new Socket(),
   } = options;
 
   // Create a readable stream that will be used as the base for IncomingMessage
   const readable = new Readable();
   readable._read = (): void => {}; // Required implementation
 
   // Add the body content if provided
   if (body) {
     if (typeof body === "string") {
       readable.push(body);
     } else if (Buffer.isBuffer(body)) {
       readable.push(body);
     } else {
       readable.push(JSON.stringify(body));
     }
     readable.push(null); // Signal the end of the stream
   }
 
   // Create the IncomingMessage instance
   const req = new IncomingMessage(socket);
 
   // Set the properties
   req.method = method;
   req.url = url;
   req.headers = headers;
 
   // Copy over the stream methods
   req.push = readable.push.bind(readable);
   req.read = readable.read.bind(readable);
   req.on = readable.on.bind(readable);
   req.pipe = readable.pipe.bind(readable);
 
   return req;
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# cd3dde067b37c0f48cb2b92eae189e918fb6536a
#KEY#COMMIT_DATE# 2025-03-09 10:57:04 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# log
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/server.ts
- lib/mcp-api-handler.ts
- scripts/test-client.mjs

#KEY#DIFF_RANGE# FROM: 817689835f3d8507e878d2e9bd37b2de9d0a0e5e TO: cd3dde067b37c0f48cb2b92eae189e918fb6536a
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/server.ts b/api/server.ts
index de12598..aa1d785 100644
--- a/api/server.ts
+++ b/api/server.ts
@@ -1,10 +1,14 @@
-import { z } from "zod";
 import { initializeMcpApiHandler } from "../lib/mcp-api-handler";
 
 const handler = initializeMcpApiHandler((server) => {
-  server.tool("echo", { message: z.string() }, async ({ message }) => ({
-    content: [{ type: "text", text: `Tool echo: ${message}` }],
+  server.resource("config", "config://app", async (uri) => ({
+    contents: [
+      {
+        uri: uri.href,
+        text: "We are running on Vercel",
+      },
+    ],
   }));
 });
 
 export default handler;
diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index c002ea3..cadf9f3 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,262 +1,233 @@
 import getRawBody from "raw-body";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { createClient } from "redis";
 import { Socket } from "net";
 import { Readable } from "stream";
 
 interface SerializedRequest {
-  requestId: number;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 const redis = createClient({ url: process.env.REDIS_URL });
 const redisPromise = redis.connect();
 redis.on("error", (err) => {
   console.error("Redis error", err);
 });
 
 let servers: McpServer[] = [];
 
-let requestId = 0;
-
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer) => void
 ) {
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript test server on vercel",
           version: "0.1.0",
         },
         {
           capabilities: {},
         }
       );
       initializeServer(server);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b) => {
           body = b;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
-        await redis.publish(
-          `responses:${sessionId}:${request.requestId}`,
-          JSON.stringify({
-            status,
-            body,
-          })
-        );
-        await redis.expire(`responses:${sessionId}`, 60 * 60); // 1 hour
         if (status >= 200 && status < 300) {
           logInContext("log", `Request ${sessionId} succeeded: ${body}`);
         } else {
           logInContext(
             "error",
             `Message for ${sessionId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, 795 * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
-      const myRequestId = requestId++;
+
       const serializedRequest: SerializedRequest = {
-        requestId: myRequestId,
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await Promise.all([
         redis.publish(
           `requests:${sessionId}`,
           JSON.stringify(serializedRequest)
         ),
         redis.expire(`requests:${sessionId}`, 60 * 60), // 1 hour
       ]);
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
-      setTimeout(() => {
-        redis.unsubscribe(`responses:${sessionId}:${myRequestId}`);
-        res.statusCode = 408;
-        res.end("Request timed out");
-      }, 60 * 1000);
-
-      redis.subscribe(`responses:${sessionId}:${myRequestId}`, (message) => {
-        const response = JSON.parse(message) as {
-          status: number;
-          body: string;
-        };
-        res.statusCode = response.status;
-        res.end(response.body);
-      });
-
-      res.on("close", () => {
-        redis.unsubscribe(`responses:${sessionId}:${myRequestId}`);
-      });
-    } else if (url.pathname === "/") {
+      res.statusCode = 202;
+      res.end("Accepted");
     } else if (url.pathname === "/") {
       res.statusCode = 200;
       res.end("Hello, world!");
     } else {
       res.statusCode = 404;
       res.end("Not found");
     }
   };
 }
 
 // Define the options interface
 interface FakeIncomingMessageOptions {
   method?: string;
   url?: string;
   headers?: IncomingHttpHeaders;
   body?: string | Buffer | Record<string, any> | null;
   socket?: Socket;
 }
 
 // Create a fake IncomingMessage
 function createFakeIncomingMessage(
   options: FakeIncomingMessageOptions = {}
 ): IncomingMessage {
   const {
     method = "GET",
     url = "/",
     headers = {},
     body = null,
     socket = new Socket(),
   } = options;
 
   // Create a readable stream that will be used as the base for IncomingMessage
   const readable = new Readable();
   readable._read = (): void => {}; // Required implementation
 
   // Add the body content if provided
   if (body) {
     if (typeof body === "string") {
       readable.push(body);
     } else if (Buffer.isBuffer(body)) {
       readable.push(body);
     } else {
       readable.push(JSON.stringify(body));
     }
     readable.push(null); // Signal the end of the stream
   }
 
   // Create the IncomingMessage instance
   const req = new IncomingMessage(socket);
 
   // Set the properties
   req.method = method;
   req.url = url;
   req.headers = headers;
 
   // Copy over the stream methods
   req.push = readable.push.bind(readable);
   req.read = readable.read.bind(readable);
   req.on = readable.on.bind(readable);
   req.pipe = readable.pipe.bind(readable);
 
   return req;
 }
diff --git a/scripts/test-client.mjs b/scripts/test-client.mjs
index 94d3d85..3f4b45d 100644
--- a/scripts/test-client.mjs
+++ b/scripts/test-client.mjs
@@ -1,31 +1,31 @@
 import { Client } from "@modelcontextprotocol/sdk/client/index.js";
 import { SSEClientTransport } from "@modelcontextprotocol/sdk/client/sse.js";
 
 async function main() {
   const transport = new SSEClientTransport(
     new URL("https://mcp-on-vercel.vercel.app/sse")
   );
 
   const client = new Client(
     {
       name: "example-client",
       version: "1.0.0",
     },
     {
       capabilities: {
         prompts: {},
         resources: {},
         tools: {},
       },
     }
   );
 
   await client.connect(transport);
 
   console.log("Connected");
 
-  const result = await client.listPrompts();
+  const result = await client.request("config", "config://app");
   console.log(result);
 }
 
 main();
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# c7aab4e8cfec85e13f23f30fe953db53991895a9
#KEY#COMMIT_DATE# 2025-03-09 10:53:13 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# log
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: cd3dde067b37c0f48cb2b92eae189e918fb6536a TO: c7aab4e8cfec85e13f23f30fe953db53991895a9
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index cadf9f3..d146c34 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,194 +1,194 @@
 import getRawBody from "raw-body";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { createClient } from "redis";
 import { Socket } from "net";
 import { Readable } from "stream";
 
 interface SerializedRequest {
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 const redis = createClient({ url: process.env.REDIS_URL });
 const redisPromise = redis.connect();
 redis.on("error", (err) => {
   console.error("Redis error", err);
 });
 
 let servers: McpServer[] = [];
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer) => void
 ) {
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript test server on vercel",
           version: "0.1.0",
         },
         {
           capabilities: {},
         }
       );
       initializeServer(server);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b) => {
           body = b;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         if (status >= 200 && status < 300) {
-          logInContext("log", `Request ${sessionId} succeeded: ${body}`);
+          logInContext("log", `Request ${sessionId} succeeded`);
         } else {
           logInContext(
             "error",
             `Message for ${sessionId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, 795 * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
 
       const serializedRequest: SerializedRequest = {
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await Promise.all([
         redis.publish(
           `requests:${sessionId}`,
           JSON.stringify(serializedRequest)
         ),
         redis.expire(`requests:${sessionId}`, 60 * 60), // 1 hour
       ]);
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
       res.statusCode = 202;
       res.end("Accepted");
     } else if (url.pathname === "/") {
       res.statusCode = 200;
       res.end("Hello, world!");
     } else {
       res.statusCode = 404;
       res.end("Not found");
     }
   };
 }
 
 // Define the options interface
 interface FakeIncomingMessageOptions {
   method?: string;
   url?: string;
   headers?: IncomingHttpHeaders;
   body?: string | Buffer | Record<string, any> | null;
   socket?: Socket;
 }
 
 // Create a fake IncomingMessage
 function createFakeIncomingMessage(
   options: FakeIncomingMessageOptions = {}
 ): IncomingMessage {
   const {
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 28db1fdd8f859e5f4c54e535f42500305cb1313d
#KEY#COMMIT_DATE# 2025-03-09 10:48:46 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# step
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: c7aab4e8cfec85e13f23f30fe953db53991895a9 TO: 28db1fdd8f859e5f4c54e535f42500305cb1313d
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index d146c34..ea6f7b8 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -67,167 +67,167 @@ export function initializeMcpApiHandler(
       }
 
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b) => {
           body = b;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         if (status >= 200 && status < 300) {
           logInContext("log", `Request ${sessionId} succeeded`);
         } else {
           logInContext(
             "error",
             `Message for ${sessionId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, 795 * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
 
       const serializedRequest: SerializedRequest = {
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await Promise.all([
         redis.publish(
           `requests:${sessionId}`,
           JSON.stringify(serializedRequest)
         ),
         redis.expire(`requests:${sessionId}`, 60 * 60), // 1 hour
       ]);
-      console.log(`Published requests:${sessionId}`, serializedRequest);
+      console.log(`Published requests:${sessionId}`);
 
       res.statusCode = 202;
       res.end("Accepted");
     } else if (url.pathname === "/") {
       res.statusCode = 200;
       res.end("Hello, world!");
     } else {
       res.statusCode = 404;
       res.end("Not found");
     }
   };
 }
 
 // Define the options interface
 interface FakeIncomingMessageOptions {
   method?: string;
   url?: string;
   headers?: IncomingHttpHeaders;
   body?: string | Buffer | Record<string, any> | null;
   socket?: Socket;
 }
 
 // Create a fake IncomingMessage
 function createFakeIncomingMessage(
   options: FakeIncomingMessageOptions = {}
 ): IncomingMessage {
   const {
     method = "GET",
     url = "/",
     headers = {},
     body = null,
     socket = new Socket(),
   } = options;
 
   // Create a readable stream that will be used as the base for IncomingMessage
   const readable = new Readable();
   readable._read = (): void => {}; // Required implementation
 
   // Add the body content if provided
   if (body) {
     if (typeof body === "string") {
       readable.push(body);
     } else if (Buffer.isBuffer(body)) {
       readable.push(body);
     } else {
       readable.push(JSON.stringify(body));
     }
     readable.push(null); // Signal the end of the stream
   }
 
   // Create the IncomingMessage instance
   const req = new IncomingMessage(socket);
 
   // Set the properties
   req.method = method;
   req.url = url;
   req.headers = headers;
 
   // Copy over the stream methods
   req.push = readable.push.bind(readable);
   req.read = readable.read.bind(readable);
   req.on = readable.on.bind(readable);
   req.pipe = readable.pipe.bind(readable);
 
   return req;
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 05b4c1bb485363fd896b9126b5a3308f9723b8b9
#KEY#COMMIT_DATE# 2025-03-09 10:43:25 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# Refactor
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/server.ts
- scripts/test-client.mjs

#KEY#DIFF_RANGE# FROM: 28db1fdd8f859e5f4c54e535f42500305cb1313d TO: 05b4c1bb485363fd896b9126b5a3308f9723b8b9
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/server.ts b/api/server.ts
index aa1d785..6af052d 100644
--- a/api/server.ts
+++ b/api/server.ts
@@ -1,14 +1,12 @@
 import { initializeMcpApiHandler } from "../lib/mcp-api-handler";
 
-const handler = initializeMcpApiHandler((server) => {
+export const handler = initializeMcpApiHandler((server) => {
   server.resource("config", "config://app", async (uri) => ({
     contents: [
       {
         uri: uri.href,
         text: "We are running on Vercel",
       },
     ],
   }));
 });
-
-export default handler;
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 05f89fdfd12c96af98d6fe4b1ac99bdf0b65577b
#KEY#COMMIT_DATE# 2025-03-09 10:34:33 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# Refactor
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/server.ts
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: 05b4c1bb485363fd896b9126b5a3308f9723b8b9 TO: 05f89fdfd12c96af98d6fe4b1ac99bdf0b65577b
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/server.ts b/api/server.ts
index 6af052d..3d3bd58 100644
--- a/api/server.ts
+++ b/api/server.ts
@@ -1,12 +1,3 @@
-import { initializeMcpApiHandler } from "../lib/mcp-api-handler";
+import { mcpApiHandler } from "../lib/mcp-api-handler";
 
-export const handler = initializeMcpApiHandler((server) => {
-  server.resource("config", "config://app", async (uri) => ({
-    contents: [
-      {
-        uri: uri.href,
-        text: "We are running on Vercel",
-      },
-    ],
-  }));
-});
+export default mcpApiHandler;
diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index ea6f7b8..7d752fb 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,233 +1,222 @@
 import getRawBody from "raw-body";
-import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
+import { Server } from "@modelcontextprotocol/sdk/server/index.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { createClient } from "redis";
 import { Socket } from "net";
 import { Readable } from "stream";
+import { resolve } from "path";
 
 interface SerializedRequest {
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 const redis = createClient({ url: process.env.REDIS_URL });
 const redisPromise = redis.connect();
 redis.on("error", (err) => {
   console.error("Redis error", err);
 });
 
-let servers: McpServer[] = [];
-
-export function initializeMcpApiHandler(
-  initializeServer: (server: McpServer) => void
-) {
-  return async function mcpApiHandler(
-    req: IncomingMessage,
-    res: ServerResponse
-  ) {
-    await redisPromise;
-    const url = new URL(req.url || "", "https://example.com");
-    if (url.pathname === "/sse") {
-      console.log("Got new SSE connection");
-
-      const transport = new SSEServerTransport("/message", res);
-      const sessionId = transport.sessionId;
-      const server = new McpServer(
-        {
-          name: "mcp-typescript test server on vercel",
-          version: "0.1.0",
-        },
-        {
-          capabilities: {},
-        }
-      );
-      initializeServer(server);
-
-      servers.push(server);
-
-      server.server.onclose = () => {
-        console.log("SSE connection closed");
-        servers = servers.filter((s) => s !== server);
-      };
-
-      let logs: {
-        type: "log" | "error";
-        messages: string[];
-      }[] = [];
-      // This ensures that we logs in the context of the right invocation since the subscriber
-      // is not itself invoked in request context.
-      function logInContext(severity: "log" | "error", ...messages: string[]) {
-        logs.push({
-          type: severity,
-          messages,
-        });
+let servers: Server[] = [];
+
+export async function mcpApiHandler(req: IncomingMessage, res: ServerResponse) {
+  await redisPromise;
+  const url = new URL(req.url || "", "https://example.com");
+  if (url.pathname === "/sse") {
+    console.log("Got new SSE connection");
+
+    const transport = new SSEServerTransport("/message", res);
+    const sessionId = transport.sessionId;
+    const server = new Server(
+      {
+        name: "mcp-typescript test server on vercel",
+        version: "0.1.0",
+      },
+      {
+        capabilities: {},
       }
+    );
+
+    servers.push(server);
+
+    server.onclose = () => {
+      console.log("SSE connection closed");
+      servers = servers.filter((s) => s !== server);
+    };
+
+    let logs: {
+      type: "log" | "error";
+      messages: string[];
+    }[] = [];
+    // This ensures that we logs in the context of the right invocation since the subscriber
+    // is not itself invoked in request context.
+    function logInContext(severity: "log" | "error", ...messages: string[]) {
+      logs.push({
+        type: severity,
+        messages,
+      });
+    }
 
-      const handleMessage = async (message: string) => {
-        console.log("Received message from Redis", message);
-        logInContext("log", "Received message from Redis", message);
-        const request = JSON.parse(message) as SerializedRequest;
-
-        const req = createFakeIncomingMessage({
-          method: request.method,
-          url: request.url,
-          headers: request.headers,
-          body: request.body,
-        });
-        const syntheticRes = new ServerResponse(req);
-        let status = 100;
-        let body = "";
-        syntheticRes.writeHead = (statusCode) => {
-          status = statusCode;
-          return syntheticRes;
-        };
-        syntheticRes.end = (b) => {
-          body = b;
-          return syntheticRes;
-        };
-        await transport.handlePostMessage(req, syntheticRes);
-
-        if (status >= 200 && status < 300) {
-          logInContext("log", `Request ${sessionId} succeeded`);
-        } else {
-          logInContext(
-            "error",
-            `Message for ${sessionId} failed with status ${status}: ${body}`
-          );
-        }
-      };
+    const handleMessage = async (message: string) => {
+      console.log("Received message from Redis", message);
+      logInContext("log", "Received message from Redis", message);
+      const request = JSON.parse(message) as SerializedRequest;
 
-      const interval = setInterval(() => {
-        for (const log of logs) {
-          console[log.type].call(console, ...log.messages);
-        }
-        logs = [];
-      }, 100);
-
-      await redis.subscribe(`requests:${sessionId}`, handleMessage);
-      console.log(`Subscribed to requests:${sessionId}`);
-
-      let timeout: NodeJS.Timeout;
-      let resolveTimeout: (value: unknown) => void;
-      const waitPromise = new Promise((resolve) => {
-        resolveTimeout = resolve;
-        timeout = setTimeout(() => {
-          resolve("max duration reached");
-        }, 795 * 1000);
+      const req = createFakeIncomingMessage({
+        method: request.method,
+        url: request.url,
+        headers: request.headers,
+        body: request.body,
       });
-
-      async function cleanup() {
-        clearTimeout(timeout);
-        clearInterval(interval);
-        await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
-        console.log("Done");
-        res.statusCode = 200;
-        res.end();
+      const syntheticRes = new ServerResponse(req);
+      let status = 100;
+      let body = "";
+      syntheticRes.writeHead = (statusCode) => {
+        status = statusCode;
+        return syntheticRes;
+      };
+      syntheticRes.end = (b) => {
+        body = b;
+        return syntheticRes;
+      };
+      await transport.handlePostMessage(req, syntheticRes);
+
+      if (status >= 200 && status < 300) {
+        logInContext("log", `Request ${sessionId} succeeded`);
+      } else {
+        logInContext(
+          "error",
+          `Message for ${sessionId} failed with status ${status}: ${body}`
+        );
       }
-      req.on("close", () => resolveTimeout("client hang up"));
-
-      await server.connect(transport);
-      const closeReason = await waitPromise;
-      console.log(closeReason);
-      await cleanup();
-    } else if (url.pathname === "/message") {
-      console.log("Received message");
-
-      const body = await getRawBody(req, {
-        length: req.headers["content-length"],
-        encoding: "utf-8",
-      });
+    };
 
-      const sessionId = url.searchParams.get("sessionId") || "";
-      if (!sessionId) {
-        res.statusCode = 400;
-        res.end("No sessionId provided");
-        return;
+    const interval = setInterval(() => {
+      for (const log of logs) {
+        console[log.type].call(console, ...log.messages);
       }
-
-      const serializedRequest: SerializedRequest = {
-        url: req.url || "",
-        method: req.method || "",
-        body: body,
-        headers: req.headers,
-      };
-
-      // Queue the request in Redis so that a subscriber can pick it up.
-      // One queue per session.
-      await Promise.all([
-        redis.publish(
-          `requests:${sessionId}`,
-          JSON.stringify(serializedRequest)
-        ),
-        redis.expire(`requests:${sessionId}`, 60 * 60), // 1 hour
-      ]);
-      console.log(`Published requests:${sessionId}`);
-
-      res.statusCode = 202;
-      res.end("Accepted");
-    } else if (url.pathname === "/") {
-      res.statusCode = 200;
-      res.end("Hello, world!");
-    } else {
-      res.statusCode = 404;
-      res.end("Not found");
+      logs = [];
+    }, 100);
+
+    await redis.subscribe(`requests:${sessionId}`, handleMessage);
+    console.log(`Subscribed to requests:${sessionId}`);
+
+    let timeout: NodeJS.Timeout;
+    let resolveTimeout: (value: unknown) => void;
+    const waitPromise = new Promise((resolve) => {
+      resolveTimeout = resolve;
+      timeout = setTimeout(() => {
+        resolve("max duration reached");
+      }, 795 * 1000);
+    });
+
+    async function cleanup() {
+      clearTimeout(timeout);
+      clearInterval(interval);
+      await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
+      console.log("Done");
+      res.end();
+    }
+    req.on("close", () => resolveTimeout("client hang up"));
+
+    await server.connect(transport);
+    const closeReason = await waitPromise;
+    console.log(closeReason);
+    await cleanup();
+  } else if (url.pathname === "/message") {
+    console.log("Received message");
+
+    const body = await getRawBody(req, {
+      length: req.headers["content-length"],
+      encoding: "utf-8",
+    });
+
+    const sessionId = url.searchParams.get("sessionId") || "";
+    if (!sessionId) {
+      res.statusCode = 400;
+      res.end("No sessionId provided");
+      return;
     }
-  };
+
+    const serializedRequest: SerializedRequest = {
+      url: req.url || "",
+      method: req.method || "",
+      body: body,
+      headers: req.headers,
+    };
+
+    // Queue the request in Redis so that a subscriber can pick it up.
+    // One queue per session.
+    await Promise.all([
+      redis.publish(`requests:${sessionId}`, JSON.stringify(serializedRequest)),
+      redis.expire(`requests:${sessionId}`, 1 * 60), // 1 minute
+    ]);
+    console.log(`Published requests:${sessionId}`);
+
+    res.statusCode = 202;
+    res.end("Accepted");
+  } else if (url.pathname === "/") {
+    res.statusCode = 200;
+    res.end("Hello, world!");
+  } else {
+    res.statusCode = 404;
+    res.end("Not found");
+  }
 }
 
 // Define the options interface
 interface FakeIncomingMessageOptions {
   method?: string;
   url?: string;
   headers?: IncomingHttpHeaders;
   body?: string | Buffer | Record<string, any> | null;
   socket?: Socket;
 }
 
 // Create a fake IncomingMessage
 function createFakeIncomingMessage(
   options: FakeIncomingMessageOptions = {}
 ): IncomingMessage {
   const {
     method = "GET",
     url = "/",
     headers = {},
     body = null,
     socket = new Socket(),
   } = options;
 
   // Create a readable stream that will be used as the base for IncomingMessage
   const readable = new Readable();
   readable._read = (): void => {}; // Required implementation
 
   // Add the body content if provided
   if (body) {
     if (typeof body === "string") {
       readable.push(body);
     } else if (Buffer.isBuffer(body)) {
       readable.push(body);
     } else {
       readable.push(JSON.stringify(body));
     }
     readable.push(null); // Signal the end of the stream
   }
 
   // Create the IncomingMessage instance
   const req = new IncomingMessage(socket);
 
   // Set the properties
   req.method = method;
   req.url = url;
   req.headers = headers;
 
   // Copy over the stream methods
   req.push = readable.push.bind(readable);
   req.read = readable.read.bind(readable);
   req.on = readable.on.bind(readable);
   req.pipe = readable.pipe.bind(readable);
 
   return req;
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 17350f22810fc3ac1bca05036fdd77be37b463c7
#KEY#COMMIT_DATE# 2025-03-09 10:23:23 -0700
#KEY#COMMIT_AUTHOR# Malte Ubl
#KEY#COMMIT_MESSAGE# clean-up
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- README.md
- api/server.ts
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: 05f89fdfd12c96af98d6fe4b1ac99bdf0b65577b TO: 17350f22810fc3ac1bca05036fdd77be37b463c7
=================================================================

#KEY#GIT_DIFF#

diff --git a/README.md b/README.md
index 047ce82..b5607de 100644
--- a/README.md
+++ b/README.md
@@ -1,13 +1,13 @@
 # Run an MCP Server on Vercel
 
 ## Sample POST
 
 ```sh
-curl -X POST "https://mcp-on-vercel.vercel.app/message?sessionId=3657fb33-19a4-4e05-bc33-3fd17d0fffe8" \
+curl -X POST "https://mcp-on-vercel.vercel.app/message?sessionId=2009b2d0-7584-4d3e-8f0e-62d6df7211b4" \
   -H "Content-Type: application/json" \
   -d '{
     "name": "John Doe",
     "email": "john@example.com",
     "message": "Hello, world!"
   }'
 ```
diff --git a/api/server.ts b/api/server.ts
index 3d3bd58..459b18c 100644
--- a/api/server.ts
+++ b/api/server.ts
@@ -1,3 +1,214 @@
-import { mcpApiHandler } from "../lib/mcp-api-handler";
+import getRawBody from "raw-body";
+import { Server } from "@modelcontextprotocol/sdk/server/index.js";
+import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
+import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
+import { createClient } from "redis";
+import { Socket } from "net";
+import { Readable } from "stream";
 
-export default mcpApiHandler;
+interface SerializedRequest {
+  url: string;
+  method: string;
+  body: string;
+  headers: IncomingHttpHeaders;
+}
+
+const redis = createClient({ url: process.env.REDIS_URL });
+const redisPromise = redis.connect();
+redis.on("error", (err) => {
+  console.error("Redis error", err);
+});
+
+let servers: Server[] = [];
+
+export default async function handler(
+  req: IncomingMessage,
+  res: ServerResponse
+) {
+  await redisPromise;
+  const url = new URL(req.url || "", "https://example.com");
+  if (url.pathname === "/sse") {
+    console.log("Got new SSE connection");
+
+    const transport = new SSEServerTransport("/message", res);
+    const sessionId = transport.sessionId;
+    const server = new Server(
+      {
+        name: "mcp-typescript test server on vercel",
+        version: "0.1.0",
+      },
+      {
+        capabilities: {},
+      }
+    );
+
+    servers.push(server);
+
+    server.onclose = () => {
+      console.log("SSE connection closed");
+      servers = servers.filter((s) => s !== server);
+    };
+
+    let logs: {
+      type: "log" | "error";
+      messages: string[];
+    }[] = [];
+    // This ensures that we logs in the context of the right invocation since the subscriber
+    // is not itself invoked in request context.
+    function logInContext(severity: "log" | "error", ...messages: string[]) {
+      logs.push({
+        type: severity,
+        messages,
+      });
+    }
+
+    const handleMessage = async (message: string) => {
+      console.log("Received message from Redis", message);
+      logInContext("log", "Received message from Redis", message);
+      const request = JSON.parse(message) as SerializedRequest;
+
+      const req = createFakeIncomingMessage({
+        method: request.method,
+        url: request.url,
+        headers: request.headers,
+        body: request.body,
+      });
+      const syntheticRes = new ServerResponse(req);
+      let status = 100;
+      let body = "";
+      syntheticRes.writeHead = (statusCode) => {
+        status = statusCode;
+        return syntheticRes;
+      };
+      syntheticRes.end = (b) => {
+        body = b;
+        return syntheticRes;
+      };
+      await transport.handlePostMessage(req, syntheticRes);
+
+      if (status >= 200 && status < 300) {
+        logInContext("log", `Request ${sessionId} succeeded`);
+      } else {
+        logInContext(
+          "error",
+          `Message for ${sessionId} failed with status ${status}: ${body}`
+        );
+      }
+    };
+
+    const interval = setInterval(() => {
+      for (const log of logs) {
+        console[log.type].call(console, ...log.messages);
+      }
+      logs = [];
+    }, 100);
+
+    await redis.subscribe(`requests:${sessionId}`, handleMessage);
+    console.log(`Subscribed to requests:${sessionId}`);
+
+    const timeout = new Promise((resolve) => {
+      setTimeout(() => {
+        resolve(undefined);
+      }, 795 * 1000);
+    });
+
+    await server.connect(transport);
+    await timeout;
+    redis.unsubscribe(`requests:${sessionId}`, handleMessage);
+    clearInterval(interval);
+    console.log("Done");
+    res.end();
+  } else if (url.pathname === "/message") {
+    console.log("Received message");
+
+    const body = await getRawBody(req, {
+      length: req.headers["content-length"],
+      encoding: "utf-8",
+    });
+
+    const sessionId = url.searchParams.get("sessionId") || "";
+    if (!sessionId) {
+      res.statusCode = 400;
+      res.end("No sessionId provided");
+      return;
+    }
+
+    const serializedRequest: SerializedRequest = {
+      url: req.url || "",
+      method: req.method || "",
+      body: body,
+      headers: req.headers,
+    };
+
+    // Queue the request in Redis so that a subscriber can pick it up.
+    // One queue per session.
+    await Promise.all([
+      redis.publish(`requests:${sessionId}`, JSON.stringify(serializedRequest)),
+      redis.expire(`requests:${sessionId}`, 1 * 60), // 1 minute
+    ]);
+    console.log(`Published requests:${sessionId}`);
+
+    res.statusCode = 202;
+    res.end("Accepted");
+  } else if (url.pathname === "/") {
+    res.statusCode = 200;
+    res.end("Hello, world!");
+  } else {
+    res.statusCode = 404;
+    res.end("Not found");
+  }
+}
+
+// Define the options interface
+interface FakeIncomingMessageOptions {
+  method?: string;
+  url?: string;
+  headers?: IncomingHttpHeaders;
+  body?: string | Buffer | Record<string, any> | null;
+  socket?: Socket;
+}
+
+// Create a fake IncomingMessage
+function createFakeIncomingMessage(
+  options: FakeIncomingMessageOptions = {}
+): IncomingMessage {
+  const {
+    method = "GET",
+    url = "/",
+    headers = {},
+    body = null,
+    socket = new Socket(),
+  } = options;
+
+  // Create a readable stream that will be used as the base for IncomingMessage
+  const readable = new Readable();
+  readable._read = (): void => {}; // Required implementation
+
+  // Add the body content if provided
+  if (body) {
+    if (typeof body === "string") {
+      readable.push(body);
+    } else if (Buffer.isBuffer(body)) {
+      readable.push(body);
+    } else {
+      readable.push(JSON.stringify(body));
+    }
+    readable.push(null); // Signal the end of the stream
+  }
+
+  // Create the IncomingMessage instance
+  const req = new IncomingMessage(socket);
+
+  // Set the properties
+  req.method = method;
+  req.url = url;
+  req.headers = headers;
+
+  // Copy over the stream methods
+  req.push = readable.push.bind(readable);
+  req.read = readable.read.bind(readable);
+  req.on = readable.on.bind(readable);
+  req.pipe = readable.pipe.bind(readable);
+
+  return req;
+}
#KEY#END_COMMIT#
