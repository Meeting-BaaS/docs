#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 9b5d6ec9cb9e096162d84da565ce162e3bfd0bd4
#KEY#COMMIT_DATE# 2025-04-23 12:01:07 +0200
#KEY#COMMIT_AUTHOR# lazrossi@student.42.fr
#KEY#COMMIT_MESSAGE# fix: compilation and rebase
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- README.md

#KEY#DIFF_RANGE# FROM: 6c3e1b562d27167263631f5417f331f2ecf76f8a TO: 9b5d6ec9cb9e096162d84da565ce162e3bfd0bd4
=================================================================

#KEY#GIT_DIFF#

diff --git a/README.md b/README.md
index 5ae5c3b..0105894 100644
--- a/README.md
+++ b/README.md
@@ -1,125 +1,22 @@
-# Meeting Baas MCP Server on Vercel
-
-This is the main MCP (Model Context Protocol) server powering [chat.meetingbaas.com](https://chat.meetingbaas.com), providing the LLM integration and AI capabilities for the Meeting Baas chat interface. It's a fork of the [Vercel MCP template](https://github.com/vercel-labs/mcp-on-vercel) with Meeting Baas-specific modifications.
-
-The server implements the Model Context Protocol (MCP) that integrates with Meeting Baas services, enabling:
-- AI-powered chat interactions
-- Meeting automation through LLMs
-- Intelligent bot management
-- Calendar integration with AI assistance
-
-## Features
-
-- Integration with [Meeting Baas SDK](https://www.npmjs.com/package/@meeting-baas/sdk) for video meeting management
-- Support for both standard and speaking bots
-- Calendar integration for automated meeting recordings
-- Real-time transcription and audio streaming capabilities
-- Comprehensive bot management tools
-
-## SDK Integration
-
-This project uses the official Meeting Baas SDK (`@meeting-baas/sdk`) which provides:
-
-- Complete type safety with comprehensive TypeScript definitions
-- Automatic updates synced with OpenAPI specification
-- Simplified access to all meeting automation capabilities
-- Cross-platform consistency for all supported meeting providers (Google Meet, Zoom, Microsoft Teams)
-- Pre-generated MPC tools for easy integration with AI systems
-- Strongly typed functions for interacting with the complete Meeting Baas API
-
-## Environment Variables
-
-The following environment variables are required:
-
-- `REDIS_URL`: URL to your Redis instance (required for session management)
-
-Optional environment variables:
-- `NODE_ENV`: Set to "development" for development mode
-- `LOG_LEVEL`: Set the logging level (defaults to "info")
-- `BAAS_API_KEY`: Your Meeting Baas API key (only used in development mode)
-
-## Authentication
-
-The server supports multiple ways to provide the Meeting Baas API key:
-
-1. Request headers (in order of precedence):
-   - `x-meeting-baas-api-key`
-   - `x-meetingbaas-apikey`
-   - `x-api-key`
-   - `Authorization` (as a Bearer token)
-
-2. Request body (for POST requests):
-   ```json
-   {
-     "apiKey": "your-api-key"
-   }
-   ```
-
-3. Environment variable (development mode only):
-   ```bash
-   BAAS_API_KEY=your-api-key
-   ```
-
-Note: In production, the API key should be provided through request headers or body. The environment variable is only used in development mode for testing purposes.
+# Run an MCP Server on Vercel
 
 ## Usage
 
 Update `api/server.ts` with your tools, prompts, and resources following the [MCP TypeScript SDK documentation](https://github.com/modelcontextprotocol/typescript-sdk/tree/main?tab=readme-ov-file#server).
 
 [There is also a Next.js version of this template](https://vercel.com/templates/next.js/model-context-protocol-mcp-with-next-js)
 
 ## Notes for running on Vercel
 
 - Requires a Redis attached to the project under `process.env.REDIS_URL`
 - Make sure you have [Fluid compute](https://vercel.com/docs/functions/fluid-compute) enabled for efficient execution
 - After enabling Fluid compute, open `vercel.json` and adjust max duration to 800 if you using a Vercel Pro or Enterprise account
 - [Deploy the MCP template](https://vercel.com/templates/other/model-context-protocol-mcp-with-vercel-functions)
 
-## Meeting Baas Integration
-
-This fork includes several Meeting Baas-specific tools:
-
-### Meeting Management
-- Join meetings with AI bots
-- Record meetings with transcription
-- Manage speaking bots with different personas
-- Leave meetings and clean up resources
-
-### Calendar Management
-- Create and manage calendar integrations
-- Schedule automated recordings
-- List and manage calendar events
-- Update calendar configurations
-
-### Bot Management
-- List and monitor active bots
-- Get detailed bot metadata
-- Manage bot configurations
-
 ## Sample Client
 
 `script/test-client.mjs` contains a sample client to try invocations.
 
 ```sh
 node scripts/test-client.mjs https://mcp-on-vercel.vercel.app
 ```
-
-## Differences from Original Template
-
-This fork adds:
-1. Meeting Baas SDK integration
-2. Enhanced bot management capabilities
-3. Calendar integration features
-4. Speaking bot support with personas
-5. Improved error handling and logging
-
-## Contributing
-
-This is a fork of the Vercel MCP template. For the original template, please visit [vercel-labs/mcp-on-vercel](https://github.com/vercel-labs/mcp-on-vercel).
-
-## Documentation
-
-For more information about the Meeting Baas SDK, visit:
-- [SDK Documentation](https://docs.meetingbaas.com/com/docs/typescript-sdk)
-- [npm Package](https://www.npmjs.com/package/@meeting-baas/sdk)
-- [GitHub Repository](https://github.com/Meeting-Baas/sdk)
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 2f6400baaa7a8cd50ad117a629f40d38a3170ea4
#KEY#COMMIT_DATE# 2025-04-23 11:43:30 +0200
#KEY#COMMIT_AUTHOR# lazrossi@student.42.fr
#KEY#COMMIT_MESSAGE# bump meeting baas sdk version, fix leave route
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts
- package.json
- pnpm-lock.yaml

#KEY#DIFF_RANGE# FROM: 9b5d6ec9cb9e096162d84da565ce162e3bfd0bd4 TO: 2f6400baaa7a8cd50ad117a629f40d38a3170ea4
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index 619de5b..7ec37a8 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,263 +1,260 @@
 import { ServerOptions as McpServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
+import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { Socket } from "net";
 import getRawBody from "raw-body";
 import { createClient } from "redis";
 import { Readable } from "stream";
 import z from "zod";
 import vercelJson from "../vercel.json";
 import { RedisClientType } from "redis";
 import { registerTools } from "../api/tools.js";
-import { randomUUID } from "node:crypto";
 
 interface ServerOptions extends McpServerOptions {
   parameters?: {
     schema: z.ZodSchema;
   };
 }
 
 interface SerializedRequest {
   requestId: string;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer, apiKey: string) => void,
   serverOptions: ServerOptions = {}
 ) {
   const maxDuration =
     vercelJson?.functions?.["api/server.ts"]?.maxDuration || 800;
   const redisUrl = process.env.REDIS_URL || process.env.KV_URL;
   if (!redisUrl) {
     throw new Error("REDIS_URL environment variable is not set");
   }
   const redis = createClient({
     url: redisUrl,
   });
   const redisPublisher = createClient({
     url: redisUrl,
   });
   redis.on("error", (err) => {
     console.error("Redis error", err);
   });
   redisPublisher.on("error", (err) => {
     console.error("Redis error", err);
   });
   const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 
   let servers: McpServer[] = [];
 
   let statelessServer: McpServer;
-  let statelessTransport: SSEServerTransport | null = null;
+  const statelessTransport = new StreamableHTTPServerTransport({
+    sessionIdGenerator: undefined,
+  });
 
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://mcp.meetingbaas.com");
 
     // Skip validation for static files
     if (url.pathname.endsWith(".ico") || url.pathname.endsWith(".png")) {
       return;
     }
 
     // Only validate API key for SSE and chat endpoints
     let apiKey: string | null = null;
     if (url.pathname === "/sse" || url.pathname === "/message") {
       // Try schema-based validation first if available
       if (
         serverOptions.parameters?.schema &&
         req.method === "POST" &&
         req.headers["content-length"]
       ) {
         try {
           const body = await getRawBody(req, {
             length: req.headers["content-length"],
             encoding: "utf-8",
           });
           const params = JSON.parse(body);
           const result = serverOptions.parameters.schema.safeParse(params);
           if (result.success) {
             apiKey = result.data.apiKey;
           }
         } catch (error) {
           console.error("Error parsing parameters:", error);
         }
       }
 
       // If schema validation failed or not available, try headers
       if (!apiKey) {
         apiKey =
           (req.headers["x-meeting-baas-api-key"] as string) ||
           (req.headers["x-meetingbaas-apikey"] as string) ||
           (req.headers["x-api-key"] as string) ||
           (req.headers["authorization"] as string)?.replace(/bearer\s+/i, "") ||
           (process.env.NODE_ENV === "development"
             ? process.env.BAAS_API_KEY
             : null) ||
           null;
       }
 
       // Authentication is optional, so we don't return an error if no API key is found
     }
 
     if (url.pathname === "/mcp") {
       if (req.method === "GET") {
         console.log("Received GET MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       if (req.method === "DELETE") {
         console.log("Received DELETE MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       console.log("Got new MCP connection", req.url, req.method);
 
       if (!statelessServer) {
         statelessServer = new McpServer(
           {
             name: "mcp-typescript server on vercel",
             version: "0.1.0",
           },
           serverOptions
         );
 
         try {
           initializeServer(statelessServer, apiKey || "");
         } catch (error) {
           console.error("Error initializing server:", error);
           // Continue without failing - authentication is optional
         }
-      }
-
-      if (!statelessTransport) {
-        statelessTransport = new SSEServerTransport("/message", res);
         await statelessServer.connect(statelessTransport);
       }
-
-      await statelessTransport.handlePostMessage(req, res);
+      await statelessTransport.handleRequest(req, res);
     } else if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript server on vercel",
           version: "0.1.0",
         },
         serverOptions
       );
 
       try {
         initializeServer(server, apiKey || "");
       } catch (error) {
         console.error("Error initializing server:", error);
         // Continue without failing - authentication is optional
       }
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       // Handles messages originally received via /message
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b: unknown) => {
           body = b as string;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         await redisPublisher.publish(
           `responses:${sessionId}:${request.requestId}`,
           JSON.stringify({
             status,
             body,
           })
         );
 
         if (status >= 200 && status < 300) {
           logInContext(
             "log",
             `Request ${sessionId}:${request.requestId} succeeded: ${body}`
           );
         } else {
           logInContext(
             "error",
             `Message for ${sessionId}:${request.requestId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
diff --git a/package.json b/package.json
index 267ef4d..1de222f 100644
--- a/package.json
+++ b/package.json
@@ -1,33 +1,33 @@
 {
   "name": "meetingbaas-mcp",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
     "build": "tsc",
     "build:watch": "tsc --watch",
     "start": "node -r dotenv/config dist/api/server.js",
     "dev": "tsc --watch & node -r dotenv/config dist/api/server.js",
     "test-client": "tsc && node dist/scripts/test-client.js"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
     "@meeting-baas/sdk": "^4.0.5",
-    "@modelcontextprotocol/sdk": "^1.10.2",
+    "@modelcontextprotocol/sdk": "^1.6.1",
     "axios": "^1.8.4",
     "content-type": "^1.0.5",
     "dotenv": "^16.4.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
     "@types/node": "^20.17.30",
     "tsup": "^8.4.0",
     "typescript": "^5.3.3"
   }
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# c32b2ffabaa31488a23a855d5284975099dbd92d
#KEY#COMMIT_DATE# 2025-04-23 11:43:23 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# fix: simplify tools registration by using a single source of truth
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools.ts
- package.json
- pnpm-lock.yaml

#KEY#DIFF_RANGE# FROM: 2f6400baaa7a8cd50ad117a629f40d38a3170ea4 TO: c32b2ffabaa31488a23a855d5284975099dbd92d
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools.ts b/api/tools.ts
index 46a059e..76c8f17 100644
--- a/api/tools.ts
+++ b/api/tools.ts
@@ -1,511 +1,554 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client";
 import { Provider } from "@meeting-baas/sdk/dist/baas/models/provider";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp";
 import z from "zod";
 import { registerBotTools } from "./tools/bots/index";
 import { registerEchoTool } from "./tools/utils/echo";
 // import { registerJoinSpeakingTool } from "./tools/bots/join-speaking";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
     baseUrl: "https://api.meetingbaas.com/",
   });
 
   // Register bot tools
   let updatedServer = registerBotTools(server, baasClient);
 
   // For Leave Meeting
   updatedServer.tool(
     "leaveMeeting",
     "Remove an AI bot from a meeting. Use this when you want to: 1) End a meeting recording 2) Stop transcription 3) Disconnect the bot from the meeting",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         console.log(`Attempting to remove bot ${botId} from meeting...`);
         const response = await baasClient.defaultApi.leave({
-          uuid: botId
+          params: { uuid: botId },
         });
         console.log(
           "Leave meeting response:",
           JSON.stringify(response.data, null, 2)
         );
 
         if (!response.data) {
           console.error("Leave meeting response missing data");
           return {
             content: [
               {
                 type: "text",
                 text: "Failed to leave meeting: No response data received",
               },
             ],
             isError: true,
           };
         }
 
         return {
           content: [
             {
               type: "text",
               text: `Successfully removed bot ${botId} from meeting`,
             },
           ],
         };
       } catch (error) {
         console.error("Failed to leave meeting:", error);
         let errorMessage = "Failed to leave meeting";
 
         if (error instanceof Error) {
           console.error("Error details:", {
             name: error.name,
             message: error.message,
             stack: error.stack,
           });
           errorMessage += `: ${error.message}`;
         } else if (typeof error === "object" && error !== null) {
           console.error("Error object:", JSON.stringify(error, null, 2));
         }
 
         return {
           content: [
             {
               type: "text",
               text: errorMessage,
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // For Get Meeting Data
   updatedServer.tool(
     "getMeetingData",
     "Get data about a meeting that a bot has joined. Use this when you want to: 1) Check meeting status 2) Get recording information 3) Access transcription data",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         //
         const response = await baasClient.defaultApi.getMeetingData({ botId });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get meeting data:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get meeting data",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // For Delete Data
   updatedServer.tool(
     "deleteData",
     "Delete data associated with a meeting bot. Use this when you want to: 1) Remove meeting recordings 2) Delete transcription data 3) Clean up bot data",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         const response = await baasClient.defaultApi.deleteData({
-          uuid: botId
+          params: { uuid: botId },
         });
         return {
           content: [
             {
               type: "text",
               text: "Successfully deleted meeting data",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to delete meeting data:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to delete meeting data",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // For Create Calendar
   updatedServer.tool(
     "createCalendar",
     "Create a new calendar integration. Use this when you want to: 1) Set up automatic meeting recordings 2) Configure calendar-based bot scheduling 3) Enable recurring meeting coverage",
     {
       oauthClientId: z.string(),
       oauthClientSecret: z.string(),
       oauthRefreshToken: z.string(),
       platform: z.enum(["Google", "Microsoft"]),
       rawCalendarId: z.string().optional(),
     },
     async ({
       oauthClientId,
       oauthClientSecret,
       oauthRefreshToken,
       platform,
       rawCalendarId,
     }) => {
       try {
         const calendarParams = {
           oauthClientId,
           oauthClientSecret,
           oauthRefreshToken,
           platform:
             platform === "Google" ? Provider.google : Provider.microsoft,
           rawCalendarId,
         };
 
         const response = await baasClient.calendarsApi.createCalendar({
           createCalendarParams: calendarParams,
         });
 
         return {
           content: [
             {
               type: "text",
               text: "Successfully created calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to create calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to create calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // For List Calendar
   updatedServer.tool(
     "listCalendars",
     "List all calendar integrations. Use this when you want to: 1) View configured calendars 2) Check calendar status 3) Manage calendar integrations",
     {},
     async () => {
       try {
         const response = await baasClient.calendarsApi.listCalendars();
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to list calendars:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to list calendars",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // For Get Calendar
   updatedServer.tool(
     "getCalendar",
     "Get details about a specific calendar integration. Use this when you want to: 1) View calendar configuration 2) Check calendar status 3) Verify calendar settings",
     { calendarId: z.string() },
     async ({ calendarId }: { calendarId: string }) => {
       try {
+        //
         const response = await baasClient.calendarsApi.getCalendar({
-          uuid: calendarId
+          params: { uuid: calendarId },
         });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // For delete Calendar
   updatedServer.tool(
     "deleteCalendar",
     "Delete a calendar integration. Use this when you want to: 1) Remove a calendar connection 2) Stop automatic recordings 3) Clean up calendar data",
     { calendarId: z.string() },
     async ({ calendarId }: { calendarId: string }) => {
       try {
+        //
         const response = await baasClient.calendarsApi.deleteCalendar({
-          uuid: calendarId
+          params: { uuid: calendarId },
         });
         return {
           content: [
             {
               type: "text",
               text: "Successfully deleted calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to delete calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to delete calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
+  // For Re sysnc all Calendar
+  updatedServer.tool(
+    "resyncAllCalendars",
+    "Resynchronize all calendar integrations. Use this when you want to: 1) Update calendar data 2) Fix sync issues 3) Refresh calendar connections",
+    {},
+    async () => {
+      try {
+        const response = await baasClient.calendarsApi.resyncAllCalendars();
+        return {
+          content: [
+            {
+              type: "text",
+              text: "Successfully resynced all calendars",
+            },
+          ],
+        };
+      } catch (error) {
+        console.error("Failed to resync calendars:", error);
+        return {
+          content: [
+            {
+              type: "text",
+              text: "Failed to resync calendars",
+            },
+          ],
+          isError: true,
+        };
+      }
+    }
+  );
+
   // For Bots with meta data
   updatedServer.tool(
     "botsWithMetadata",
     "Get a list of all bots with their metadata. Use this when you want to: 1) View active bots 2) Check bot status 3) Monitor bot activity",
     {},
     async () => {
       try {
         //
         const response = await baasClient.defaultApi.botsWithMetadata();
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get bots with metadata:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get bots with metadata",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // For List All Events
   updatedServer.tool(
     "listEvents",
     "List all scheduled events. Use this when you want to: 1) View upcoming recordings 2) Check scheduled transcriptions 3) Monitor planned bot activity",
     { calendarId: z.string() },
     async ({ calendarId }) => {
       try {
         //
         const response = await baasClient.calendarsApi.listEvents({
           calendarId,
         });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to list events:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to list events",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // For Schedule Record Events
   updatedServer.tool(
     "scheduleRecordEvent",
     "Schedule a recording. Use this when you want to: 1) Set up automatic recording 2) Schedule future transcriptions 3) Plan meeting recordings",
     {
       eventUuid: z.string(),
       botName: z.string(),
       extra: z.record(z.unknown()).optional(),
       allOccurrences: z.boolean().optional(),
     },
     async ({ eventUuid, botName, extra, allOccurrences }) => {
       try {
         const botParams = {
           botName,
           extra: extra || {},
         };
 
-        const response = await baasClient.calendarsApi.scheduleRecordEvent({
-          uuid: eventUuid,
-          botParam2: botParams,
-          allOccurrences: allOccurrences || false
-        });
+        //
+        const response = await baasClient.calendarsApi.scheduleRecordEvent(
+          {
+            botParam2: botParams,
+            allOccurrences: allOccurrences || false,
+          },
+          {
+            params: { uuid: eventUuid },
+          }
+        );
 
         return {
           content: [
             {
               type: "text",
               text: "Successfully scheduled event recording",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to schedule event recording:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to schedule event recording",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // For Un-Schedule Record Events
   updatedServer.tool(
     "unscheduleRecordEvent",
     "Cancel a scheduled recording. Use this when you want to: 1) Cancel automatic recording 2) Stop planned transcription 3) Remove scheduled bot activity",
     {
       eventUuid: z.string(),
       allOccurrences: z.boolean().optional(),
     },
     async ({ eventUuid, allOccurrences }) => {
       try {
-        const response = await baasClient.calendarsApi.unscheduleRecordEvent({
-          uuid: eventUuid,
-          allOccurrences: allOccurrences || false
-        });
+        //
+        const response = await baasClient.calendarsApi.unscheduleRecordEvent(
+          {
+            allOccurrences: allOccurrences || false,
+          },
+          {
+            params: { uuid: eventUuid },
+          }
+        );
 
         return {
           content: [
             {
               type: "text",
               text: "Successfully unscheduled event recording",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to unschedule event recording:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to unschedule event recording",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // For Update Calendar
   updatedServer.tool(
     "updateCalendar",
     "Update a calendar integration configuration. Use this when you want to: 1) Modify calendar settings 2) Update connection details 3) Change calendar configuration",
     {
       calendarId: z.string(),
       oauthClientId: z.string(),
       oauthClientSecret: z.string(),
       oauthRefreshToken: z.string(),
       platform: z.enum(["Google", "Microsoft"]),
     },
     async ({
       calendarId,
       oauthClientId,
       oauthClientSecret,
       oauthRefreshToken,
       platform,
     }) => {
       try {
         const updateParams = {
           oauthClientId,
           oauthClientSecret,
           oauthRefreshToken,
           platform:
             platform === "Google" ? Provider.google : Provider.microsoft,
         };
 
+        //
         const response = await baasClient.calendarsApi.updateCalendar({
-          uuid: calendarId,
-          updateCalendarParams: updateParams
+          updateCalendarParams: updateParams,
         });
 
         return {
           content: [
             {
               type: "text",
               text: "Successfully updated calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to update calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to update calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // Add echo tool for testing
   const finalServer = registerEchoTool(updatedServer);
 
   return finalServer;
 }
 
 export default registerTools;
diff --git a/package.json b/package.json
index 1de222f..10b1e4f 100644
--- a/package.json
+++ b/package.json
@@ -1,33 +1,33 @@
 {
   "name": "meetingbaas-mcp",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
     "build": "tsc",
     "build:watch": "tsc --watch",
     "start": "node -r dotenv/config dist/api/server.js",
     "dev": "tsc --watch & node -r dotenv/config dist/api/server.js",
     "test-client": "tsc && node dist/scripts/test-client.js"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
-    "@meeting-baas/sdk": "^4.0.5",
+    "@meeting-baas/sdk": "^4.0.4",
     "@modelcontextprotocol/sdk": "^1.6.1",
     "axios": "^1.8.4",
     "content-type": "^1.0.5",
     "dotenv": "^16.4.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
     "@types/node": "^20.17.30",
     "tsup": "^8.4.0",
     "typescript": "^5.3.3"
   }
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# c7d59fd8b8e03e0076af44a8d0607e9f27f7fa38
#KEY#COMMIT_DATE# 2025-04-23 11:43:23 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# fix: properly register both joinMeeting and joinSpeakingMeeting tools
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/server.ts
- api/tools/index.ts

#KEY#DIFF_RANGE# FROM: c32b2ffabaa31488a23a855d5284975099dbd92d TO: c7d59fd8b8e03e0076af44a8d0607e9f27f7fa38
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/server.ts b/api/server.ts
index f111715..446d0cc 100644
--- a/api/server.ts
+++ b/api/server.ts
@@ -1,94 +1,68 @@
 import { initializeMcpApiHandler } from "../lib/mcp-api-handler";
 import registerTools from "./tools";
 
 const handler = initializeMcpApiHandler(
   (server, apiKey) => {
     // Register Meeting BaaS SDK tools with the provided API key
     server = registerTools(server, apiKey);
   },
   {
     capabilities: {
       tools: {
-        // Meeting Management Category
         joinMeeting: {
-          description:
-            "Send an AI bot to join a video meeting. The bot can record the meeting, transcribe speech (enabled by default using Gladia), and provide real-time audio streams.",
-          category: "Meeting Management",
-        },
-        joinSpeakingMeeting: {
-          description:
-            "Send an AI speaking bot to join a video meeting. The bot can assist in meetings with voice AI capabilities.",
-          category: "Meeting Management",
+          description: "Join's a meeting using the MeetingBaas api",
         },
         leaveMeeting: {
-          description: "Remove an AI bot from a meeting.",
-          category: "Meeting Management",
-        },
-        leaveSpeakingMeeting: {
-          description: "Remove a speaking bot from a meeting by its ID.",
-          category: "Meeting Management",
+          description: "Leave a meeting using the MeetingBaas api",
         },
         getMeetingData: {
-          description: "Get data about a meeting that a bot has joined.",
-          category: "Meeting Management",
+          description: "Get meeting data using the MeetingBaas api",
         },
         deleteData: {
-          description: "Delete data associated with a meeting bot.",
-          category: "Meeting Management",
+          description: "Delete meeting data using the MeetingBaas api",
         },
-
-        // Calendar Management Category
         createCalendar: {
-          description: "Create a new calendar integration.",
-          category: "Calendar Management",
+          description: "Create a calendar using the MeetingBaas api",
         },
         listCalendars: {
-          description: "List all calendar integrations.",
-          category: "Calendar Management",
+          description: "List calendars using the MeetingBaas api",
         },
         getCalendar: {
-          description: "Get details about a specific calendar integration.",
-          category: "Calendar Management",
+          description: "Get calendar using the MeetingBaas api",
         },
         deleteCalendar: {
-          description: "Delete a calendar integration.",
-          category: "Calendar Management",
+          description: "Delete calendar using the MeetingBaas api",
         },
         resyncAllCalendars: {
-          description: "Resynchronize all calendar integrations.",
-          category: "Calendar Management",
+          description: "Resync all calendars using the MeetingBaas api",
+        },
+        botsWithMetadata: {
+          description: "Get bots with metadata using the MeetingBaas api",
         },
         listEvents: {
-          description: "List all scheduled events.",
-          category: "Calendar Management",
+          description: "List events using the MeetingBaas api",
         },
         scheduleRecordEvent: {
-          description: "Schedule a recording.",
-          category: "Calendar Management",
+          description: "Schedule a recording using the MeetingBaas api",
         },
         unscheduleRecordEvent: {
-          description: "Cancel a scheduled recording.",
-          category: "Calendar Management",
+          description: "Unschedule a recording using the MeetingBaas api",
         },
         updateCalendar: {
-          description: "Update a calendar integration configuration.",
-          category: "Calendar Management",
+          description: "Update calendar using the MeetingBaas api",
         },
-
-        // Bot Management Category
-        botsWithMetadata: {
-          description: "Get a list of all bots with their metadata.",
-          category: "Bot Management",
+        joinSpeakingMeeting: {
+          description: "Join a speaking meeting using the MeetingBaas api",
+        },
+        leaveSpeakingMeeting: {
+          description: "Leave a speaking meeting using the MeetingBaas api",
         },
-
-        // Utility Category
         echo: {
-          description: "Echo a message back.",
-          category: "Utility",
+          description: "Echo a message",
         },
       },
     },
   }
 );
 
 export default handler;
diff --git a/api/tools/index.ts b/api/tools/index.ts
index 068882e..18535f3 100644
--- a/api/tools/index.ts
+++ b/api/tools/index.ts
@@ -1,22 +1,21 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client.js";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { registerBotTools } from "./bots";
 import { registerEchoTool } from "./utils/echo";
 // import { registerJoinSpeakingTool } from "./bots/join-speaking";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
-    baseUrl: "https://api.meetingbaas.com/",
   });
 
   // Register bot tools
   let updatedServer = registerBotTools(server, baasClient);
 
   // Add echo tool for testing
   const finalServer = registerEchoTool(updatedServer);
 
   return finalServer;
 }
 
 export default registerTools;
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 1d4d013a22c3dea7af668738c5917615b87c31d2
#KEY#COMMIT_DATE# 2025-04-23 11:43:23 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# fix: re-enable joinMeeting tool by registering both bot tools
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools/index.ts

#KEY#DIFF_RANGE# FROM: c7d59fd8b8e03e0076af44a8d0607e9f27f7fa38 TO: 1d4d013a22c3dea7af668738c5917615b87c31d2
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools/index.ts b/api/tools/index.ts
index 18535f3..30cc3e1 100644
--- a/api/tools/index.ts
+++ b/api/tools/index.ts
@@ -1,21 +1,21 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client.js";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
-import { registerBotTools } from "./bots";
+// import { registerBotTools } from "./bots";
 import { registerEchoTool } from "./utils/echo";
-// import { registerJoinSpeakingTool } from "./bots/join-speaking";
+import { registerJoinSpeakingTool } from "./bots/join-speaking";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
   });
 
   // Register bot tools
-  let updatedServer = registerBotTools(server, baasClient);
+  let updatedServer = registerJoinSpeakingTool(server);
 
   // Add echo tool for testing
   const finalServer = registerEchoTool(updatedServer);
 
   return finalServer;
 }
 
 export default registerTools;
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 51440802d5b3426fdd741595f507ee58a592777b
#KEY#COMMIT_DATE# 2025-04-23 11:43:23 +0200
#KEY#COMMIT_AUTHOR# Amit-4582
#KEY#COMMIT_MESSAGE# Minor fixes 2
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools.ts
- api/tools/bots/index.ts

#KEY#DIFF_RANGE# FROM: 1d4d013a22c3dea7af668738c5917615b87c31d2 TO: 51440802d5b3426fdd741595f507ee58a592777b
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools.ts b/api/tools.ts
index 76c8f17..a930073 100644
--- a/api/tools.ts
+++ b/api/tools.ts
@@ -1,116 +1,116 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client";
 import { Provider } from "@meeting-baas/sdk/dist/baas/models/provider";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp";
 import z from "zod";
-import { registerBotTools } from "./tools/bots/index";
+// import { registerBotTools } from "./tools/bots/index";
 import { registerEchoTool } from "./tools/utils/echo";
-// import { registerJoinSpeakingTool } from "./tools/bots/join-speaking";
+import { registerJoinSpeakingTool } from "./tools/bots/join-speaking";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
     baseUrl: "https://api.meetingbaas.com/",
   });
 
   // Register bot tools
-  let updatedServer = registerBotTools(server, baasClient);
+  let updatedServer = registerJoinSpeakingTool(server);
 
   // For Leave Meeting
   updatedServer.tool(
     "leaveMeeting",
     "Remove an AI bot from a meeting. Use this when you want to: 1) End a meeting recording 2) Stop transcription 3) Disconnect the bot from the meeting",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         console.log(`Attempting to remove bot ${botId} from meeting...`);
         const response = await baasClient.defaultApi.leave({
           params: { uuid: botId },
         });
         console.log(
           "Leave meeting response:",
           JSON.stringify(response.data, null, 2)
         );
 
         if (!response.data) {
           console.error("Leave meeting response missing data");
           return {
             content: [
               {
                 type: "text",
                 text: "Failed to leave meeting: No response data received",
               },
             ],
             isError: true,
           };
         }
 
         return {
           content: [
             {
               type: "text",
               text: `Successfully removed bot ${botId} from meeting`,
             },
           ],
         };
       } catch (error) {
         console.error("Failed to leave meeting:", error);
         let errorMessage = "Failed to leave meeting";
 
         if (error instanceof Error) {
           console.error("Error details:", {
             name: error.name,
             message: error.message,
             stack: error.stack,
           });
           errorMessage += `: ${error.message}`;
         } else if (typeof error === "object" && error !== null) {
           console.error("Error object:", JSON.stringify(error, null, 2));
         }
 
         return {
           content: [
             {
               type: "text",
               text: errorMessage,
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // For Get Meeting Data
   updatedServer.tool(
     "getMeetingData",
     "Get data about a meeting that a bot has joined. Use this when you want to: 1) Check meeting status 2) Get recording information 3) Access transcription data",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         //
         const response = await baasClient.defaultApi.getMeetingData({ botId });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get meeting data:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get meeting data",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // For Delete Data
   updatedServer.tool(
diff --git a/api/tools/bots/index.ts b/api/tools/bots/index.ts
index 93b7400..82c63a2 100644
--- a/api/tools/bots/index.ts
+++ b/api/tools/bots/index.ts
@@ -1,19 +1,12 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp";
-import { registerJoinTool } from "./join";
 import { registerJoinSpeakingTool } from "./join-speaking";
 
 export function registerBotTools(
   server: McpServer,
   baasClient?: BaasClient
 ): McpServer {
   // Register all bot-related tools
   let updatedServer = registerJoinSpeakingTool(server);
-
-  // Register the standard joinMeeting tool if baasClient is provided
-  if (baasClient) {
-    updatedServer = registerJoinTool(updatedServer, baasClient);
-  }
-
   return updatedServer;
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 62b4778c97ab07a5243741c14e8a61a659f64302
#KEY#COMMIT_DATE# 2025-04-23 11:43:22 +0200
#KEY#COMMIT_AUTHOR# Amit-4582
#KEY#COMMIT_MESSAGE# Minor fixes 1
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools/index.ts

#KEY#DIFF_RANGE# FROM: 51440802d5b3426fdd741595f507ee58a592777b TO: 62b4778c97ab07a5243741c14e8a61a659f64302
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools/index.ts b/api/tools/index.ts
index 30cc3e1..4f64456 100644
--- a/api/tools/index.ts
+++ b/api/tools/index.ts
@@ -1,21 +1,20 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client.js";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
-// import { registerBotTools } from "./bots";
+import { registerBotTools } from "./bots";
 import { registerEchoTool } from "./utils/echo";
-import { registerJoinSpeakingTool } from "./bots/join-speaking";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
   });
 
   // Register bot tools
-  let updatedServer = registerJoinSpeakingTool(server);
+  const updatedServer = registerBotTools(server, baasClient);
 
   // Add echo tool for testing
   const finalServer = registerEchoTool(updatedServer);
 
   return finalServer;
 }
 
 export default registerTools;
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 56dd4df9b315eef14a8e5ba2e8aef106e2cd7707
#KEY#COMMIT_DATE# 2025-04-23 11:43:22 +0200
#KEY#COMMIT_AUTHOR# Amit-4582
#KEY#COMMIT_MESSAGE# Added Comments for clear understanding the functionalities and fixed the issue related join speaking register bots
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools.ts

#KEY#DIFF_RANGE# FROM: 62b4778c97ab07a5243741c14e8a61a659f64302 TO: 56dd4df9b315eef14a8e5ba2e8aef106e2cd7707
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools.ts b/api/tools.ts
index a930073..514c64e 100644
--- a/api/tools.ts
+++ b/api/tools.ts
@@ -1,125 +1,125 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client";
 import { Provider } from "@meeting-baas/sdk/dist/baas/models/provider";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp";
 import z from "zod";
-// import { registerBotTools } from "./tools/bots/index";
+import { registerBotTools } from "./tools/bots/index";
 import { registerEchoTool } from "./tools/utils/echo";
-import { registerJoinSpeakingTool } from "./tools/bots/join-speaking";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
     baseUrl: "https://api.meetingbaas.com/",
   });
 
   // Register bot tools
-  let updatedServer = registerJoinSpeakingTool(server);
+  const updatedServer = registerBotTools(server);
 
   // For Leave Meeting
   updatedServer.tool(
     "leaveMeeting",
     "Remove an AI bot from a meeting. Use this when you want to: 1) End a meeting recording 2) Stop transcription 3) Disconnect the bot from the meeting",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         console.log(`Attempting to remove bot ${botId} from meeting...`);
+        //
         const response = await baasClient.defaultApi.leave({
           params: { uuid: botId },
         });
         console.log(
           "Leave meeting response:",
           JSON.stringify(response.data, null, 2)
         );
 
         if (!response.data) {
           console.error("Leave meeting response missing data");
           return {
             content: [
               {
                 type: "text",
                 text: "Failed to leave meeting: No response data received",
               },
             ],
             isError: true,
           };
         }
 
         return {
           content: [
             {
               type: "text",
               text: `Successfully removed bot ${botId} from meeting`,
             },
           ],
         };
       } catch (error) {
         console.error("Failed to leave meeting:", error);
         let errorMessage = "Failed to leave meeting";
 
         if (error instanceof Error) {
           console.error("Error details:", {
             name: error.name,
             message: error.message,
             stack: error.stack,
           });
           errorMessage += `: ${error.message}`;
         } else if (typeof error === "object" && error !== null) {
           console.error("Error object:", JSON.stringify(error, null, 2));
         }
 
         return {
           content: [
             {
               type: "text",
               text: errorMessage,
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // For Get Meeting Data
   updatedServer.tool(
     "getMeetingData",
     "Get data about a meeting that a bot has joined. Use this when you want to: 1) Check meeting status 2) Get recording information 3) Access transcription data",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         //
         const response = await baasClient.defaultApi.getMeetingData({ botId });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get meeting data:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get meeting data",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // For Delete Data
   updatedServer.tool(
     "deleteData",
     "Delete data associated with a meeting bot. Use this when you want to: 1) Remove meeting recordings 2) Delete transcription data 3) Clean up bot data",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         const response = await baasClient.defaultApi.deleteData({
           params: { uuid: botId },
         });
         return {
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 1cf45b5fdaeac60e5b1074a41fcaf514d8b63035
#KEY#COMMIT_DATE# 2025-04-23 11:43:22 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# try add debugging
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools.ts
- api/tools/bots/index.ts
- api/tools/bots/join-speaking.ts
- package.json

#KEY#DIFF_RANGE# FROM: 56dd4df9b315eef14a8e5ba2e8aef106e2cd7707 TO: 1cf45b5fdaeac60e5b1074a41fcaf514d8b63035
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools.ts b/api/tools.ts
index 514c64e..031d23e 100644
--- a/api/tools.ts
+++ b/api/tools.ts
@@ -1,554 +1,542 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client";
 import { Provider } from "@meeting-baas/sdk/dist/baas/models/provider";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp";
 import z from "zod";
 import { registerBotTools } from "./tools/bots/index";
 import { registerEchoTool } from "./tools/utils/echo";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
     baseUrl: "https://api.meetingbaas.com/",
   });
 
   // Register bot tools
-  const updatedServer = registerBotTools(server);
+  const updatedServer = registerBotTools(server, baasClient);
 
-  // For Leave Meeting
+  // Register Meeting BaaS SDK tools
   updatedServer.tool(
     "leaveMeeting",
     "Remove an AI bot from a meeting. Use this when you want to: 1) End a meeting recording 2) Stop transcription 3) Disconnect the bot from the meeting",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         console.log(`Attempting to remove bot ${botId} from meeting...`);
         //
         const response = await baasClient.defaultApi.leave({
           params: { uuid: botId },
         });
         console.log(
           "Leave meeting response:",
           JSON.stringify(response.data, null, 2)
         );
 
         if (!response.data) {
           console.error("Leave meeting response missing data");
           return {
             content: [
               {
                 type: "text",
                 text: "Failed to leave meeting: No response data received",
               },
             ],
             isError: true,
           };
         }
 
         return {
           content: [
             {
               type: "text",
               text: `Successfully removed bot ${botId} from meeting`,
             },
           ],
         };
       } catch (error) {
         console.error("Failed to leave meeting:", error);
         let errorMessage = "Failed to leave meeting";
 
         if (error instanceof Error) {
           console.error("Error details:", {
             name: error.name,
             message: error.message,
             stack: error.stack,
           });
           errorMessage += `: ${error.message}`;
         } else if (typeof error === "object" && error !== null) {
           console.error("Error object:", JSON.stringify(error, null, 2));
         }
 
         return {
           content: [
             {
               type: "text",
               text: errorMessage,
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  // For Get Meeting Data
   updatedServer.tool(
     "getMeetingData",
     "Get data about a meeting that a bot has joined. Use this when you want to: 1) Check meeting status 2) Get recording information 3) Access transcription data",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         //
         const response = await baasClient.defaultApi.getMeetingData({ botId });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get meeting data:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get meeting data",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  // For Delete Data
   updatedServer.tool(
     "deleteData",
     "Delete data associated with a meeting bot. Use this when you want to: 1) Remove meeting recordings 2) Delete transcription data 3) Clean up bot data",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         const response = await baasClient.defaultApi.deleteData({
           params: { uuid: botId },
         });
         return {
           content: [
             {
               type: "text",
               text: "Successfully deleted meeting data",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to delete meeting data:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to delete meeting data",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  // For Create Calendar
   updatedServer.tool(
     "createCalendar",
     "Create a new calendar integration. Use this when you want to: 1) Set up automatic meeting recordings 2) Configure calendar-based bot scheduling 3) Enable recurring meeting coverage",
     {
       oauthClientId: z.string(),
       oauthClientSecret: z.string(),
       oauthRefreshToken: z.string(),
       platform: z.enum(["Google", "Microsoft"]),
       rawCalendarId: z.string().optional(),
     },
     async ({
       oauthClientId,
       oauthClientSecret,
       oauthRefreshToken,
       platform,
       rawCalendarId,
     }) => {
       try {
         const calendarParams = {
           oauthClientId,
           oauthClientSecret,
           oauthRefreshToken,
           platform:
             platform === "Google" ? Provider.google : Provider.microsoft,
           rawCalendarId,
         };
 
         const response = await baasClient.calendarsApi.createCalendar({
           createCalendarParams: calendarParams,
         });
 
         return {
           content: [
             {
               type: "text",
               text: "Successfully created calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to create calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to create calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  // For List Calendar
   updatedServer.tool(
     "listCalendars",
     "List all calendar integrations. Use this when you want to: 1) View configured calendars 2) Check calendar status 3) Manage calendar integrations",
     {},
     async () => {
       try {
         const response = await baasClient.calendarsApi.listCalendars();
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to list calendars:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to list calendars",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  // For Get Calendar
   updatedServer.tool(
     "getCalendar",
     "Get details about a specific calendar integration. Use this when you want to: 1) View calendar configuration 2) Check calendar status 3) Verify calendar settings",
     { calendarId: z.string() },
     async ({ calendarId }: { calendarId: string }) => {
       try {
         //
         const response = await baasClient.calendarsApi.getCalendar({
           params: { uuid: calendarId },
         });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  // For delete Calendar
   updatedServer.tool(
     "deleteCalendar",
     "Delete a calendar integration. Use this when you want to: 1) Remove a calendar connection 2) Stop automatic recordings 3) Clean up calendar data",
     { calendarId: z.string() },
     async ({ calendarId }: { calendarId: string }) => {
       try {
         //
         const response = await baasClient.calendarsApi.deleteCalendar({
           params: { uuid: calendarId },
         });
         return {
           content: [
             {
               type: "text",
               text: "Successfully deleted calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to delete calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to delete calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  // For Re sysnc all Calendar
   updatedServer.tool(
     "resyncAllCalendars",
     "Resynchronize all calendar integrations. Use this when you want to: 1) Update calendar data 2) Fix sync issues 3) Refresh calendar connections",
     {},
     async () => {
       try {
         const response = await baasClient.calendarsApi.resyncAllCalendars();
         return {
           content: [
             {
               type: "text",
               text: "Successfully resynced all calendars",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to resync calendars:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to resync calendars",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  // For Bots with meta data
   updatedServer.tool(
     "botsWithMetadata",
     "Get a list of all bots with their metadata. Use this when you want to: 1) View active bots 2) Check bot status 3) Monitor bot activity",
     {},
     async () => {
       try {
         //
         const response = await baasClient.defaultApi.botsWithMetadata();
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get bots with metadata:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get bots with metadata",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  // For List All Events
   updatedServer.tool(
     "listEvents",
     "List all scheduled events. Use this when you want to: 1) View upcoming recordings 2) Check scheduled transcriptions 3) Monitor planned bot activity",
     { calendarId: z.string() },
     async ({ calendarId }) => {
       try {
         //
         const response = await baasClient.calendarsApi.listEvents({
           calendarId,
         });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to list events:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to list events",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  // For Schedule Record Events
   updatedServer.tool(
     "scheduleRecordEvent",
     "Schedule a recording. Use this when you want to: 1) Set up automatic recording 2) Schedule future transcriptions 3) Plan meeting recordings",
     {
       eventUuid: z.string(),
       botName: z.string(),
       extra: z.record(z.unknown()).optional(),
       allOccurrences: z.boolean().optional(),
     },
     async ({ eventUuid, botName, extra, allOccurrences }) => {
       try {
         const botParams = {
           botName,
           extra: extra || {},
         };
 
         //
         const response = await baasClient.calendarsApi.scheduleRecordEvent(
           {
             botParam2: botParams,
             allOccurrences: allOccurrences || false,
           },
           {
             params: { uuid: eventUuid },
           }
         );
 
         return {
           content: [
             {
               type: "text",
               text: "Successfully scheduled event recording",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to schedule event recording:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to schedule event recording",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  // For Un-Schedule Record Events
   updatedServer.tool(
     "unscheduleRecordEvent",
     "Cancel a scheduled recording. Use this when you want to: 1) Cancel automatic recording 2) Stop planned transcription 3) Remove scheduled bot activity",
     {
       eventUuid: z.string(),
       allOccurrences: z.boolean().optional(),
     },
     async ({ eventUuid, allOccurrences }) => {
       try {
         //
         const response = await baasClient.calendarsApi.unscheduleRecordEvent(
           {
             allOccurrences: allOccurrences || false,
           },
           {
             params: { uuid: eventUuid },
           }
         );
 
         return {
           content: [
             {
               type: "text",
               text: "Successfully unscheduled event recording",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to unschedule event recording:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to unschedule event recording",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  // For Update Calendar
   updatedServer.tool(
     "updateCalendar",
     "Update a calendar integration configuration. Use this when you want to: 1) Modify calendar settings 2) Update connection details 3) Change calendar configuration",
     {
       calendarId: z.string(),
       oauthClientId: z.string(),
       oauthClientSecret: z.string(),
       oauthRefreshToken: z.string(),
       platform: z.enum(["Google", "Microsoft"]),
     },
     async ({
       calendarId,
       oauthClientId,
       oauthClientSecret,
       oauthRefreshToken,
       platform,
     }) => {
       try {
         const updateParams = {
           oauthClientId,
           oauthClientSecret,
           oauthRefreshToken,
           platform:
             platform === "Google" ? Provider.google : Provider.microsoft,
         };
 
         //
         const response = await baasClient.calendarsApi.updateCalendar({
           updateCalendarParams: updateParams,
         });
 
         return {
           content: [
             {
               type: "text",
               text: "Successfully updated calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to update calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to update calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // Add echo tool for testing
   const finalServer = registerEchoTool(updatedServer);
 
   return finalServer;
 }
 
 export default registerTools;
diff --git a/api/tools/bots/index.ts b/api/tools/bots/index.ts
index 82c63a2..2d948bf 100644
--- a/api/tools/bots/index.ts
+++ b/api/tools/bots/index.ts
@@ -1,12 +1,14 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp";
 import { registerJoinSpeakingTool } from "./join-speaking";
 
 export function registerBotTools(
   server: McpServer,
-  baasClient?: BaasClient
+  baasClient: BaasClient
 ): McpServer {
   // Register all bot-related tools
+  // let updatedServer = registerJoinTool(server, baasClient);
   let updatedServer = registerJoinSpeakingTool(server);
+
   return updatedServer;
 }
diff --git a/api/tools/bots/join-speaking.ts b/api/tools/bots/join-speaking.ts
index 07fd409..1b36301 100644
--- a/api/tools/bots/join-speaking.ts
+++ b/api/tools/bots/join-speaking.ts
@@ -5,264 +5,263 @@ import { z } from "zod";
 
 // Define the persona types based on the new schema
 const SPEAKING_API_URL = "https://speaking.meetingbaas.com";
 
 // Hardcoded list of available personas
 const AVAILABLE_PERSONAS = [
   "1940s_noir_detective",
   "academic_warlord",
   "ancient_alien_theorist",
   "ancient_roman_general",
   "arctic_prospector",
   "artisan_magnate",
   "astral_plane_uber_driver",
   "baas_onboarder",
   "bitcoin_maximalist",
   "buddhist_monk",
   "climate_engineer",
   "corporate_girlboss",
   "cpp_veteran",
   "crypto_patriarch",
   "cyberpunk_grandma",
   "data_baron",
   "debate_champion",
   "deep_sea_therapist",
   "environmental_activist",
   "factory_patriarch",
   "fading_diplomat",
   "forensic_accountant",
   "french_renaissance_painter",
   "futuristic_ai_philosopher",
   "genetic_aristocrat",
   "gladiator_chef",
   "golang_minimalist",
   "grafana_guru",
   "haskell_purist",
   "hospital_administrator",
   "immigration_maximalist",
   "intelligence_officer",
   "interdimensional_therapist",
   "intergalactic_barista",
   "interviewer",
   "kgb_ballerina",
   "lisp_enlightened",
   "master_sommelier",
   "media_cardinal",
   "medieval_crypto_trader",
   "medieval_plague_doctor",
   "memory_merchant",
   "military_strategist",
   "mongolian_shepherd",
   "neural_interface_mogul",
   "ninja_librarian",
   "oligarch_widow",
   "pair_programmer",
   "pharma_patriarch",
   "pirate_queen",
   "poker_champion",
   "port_master",
   "prehistoric_foodie",
   "quantum_financier",
   "quantum_mechanic",
   "quantum_physicist",
   "renaissance_gym_bro",
   "renaissance_soundcloud_rapper",
   "revolutionary_hacker",
   "rust_evangelist",
   "southern_grandma",
   "space_exploration_robot",
   "space_industrialist",
   "stoic_philosopher",
   "stone_age_tech_support",
   "synthetic_food_baron",
   "time_traveling_influencer",
   "underground_banker",
   "urban_mining_tycoon",
   "vatican_cybersecurity_officer",
   "victorian_etiquette_coach",
   "victorian_serial_killer",
   "war_correspondent",
   "waste_baron",
   "water_merchant",
 ];
 
 // Define types based on the OpenAPI specification
 interface BotRequest {
   meeting_url: string;
   bot_name: string;
   meeting_baas_api_key: string;
   personas?: string[] | null;
   bot_image?: string | null;
   entry_message?: string | null;
   extra?: Record<string, unknown> | null;
   enable_tools?: boolean;
 }
 
 interface JoinResponse {
   bot_id: string;
 }
 
 export function registerJoinSpeakingTool(server: McpServer): McpServer {
-  // For Join Speaking Meeting
   server.tool(
     "joinSpeakingMeeting",
     "Send an AI speaking bot to join a video meeting. The bot can assist in meetings with voice AI capabilities.",
     {
       meetingUrl: z.string().url().describe("URL of the meeting to join"),
       botName: z
         .string()
         .describe("Name to display for the bot in the meeting"),
       meetingBaasApiKey: z
         .string()
         .describe("Your MeetingBaas API key for authentication"),
       personas: z
         .array(z.string())
         .optional()
         .describe(
           `List of persona names to use. The first available will be selected. Available personas: ${AVAILABLE_PERSONAS.join(
             ", "
           )}`
         ),
       botImage: z
         .string()
         .url()
         .optional()
         .describe("The image to use for the bot, must be a URL."),
       entryMessage: z
         .string()
         .optional()
         .describe("Message to send when joining the meeting."),
       enableTools: z
         .boolean()
         .optional()
         .default(true)
         .describe("Whether to enable tools for the bot."),
       extra: z
         .record(z.unknown())
         .optional()
         .describe(
           "A JSON object that allows you to add custom data to a bot for your convenience."
         ),
     },
     async (params) => {
       try {
         // Create the bot request according to the new schema
         const botRequest: BotRequest = {
           meeting_url: params.meetingUrl,
           bot_name: params.botName,
           meeting_baas_api_key: params.meetingBaasApiKey,
           personas: params.personas || null,
           bot_image: params.botImage || null,
           entry_message: params.entryMessage || null,
           enable_tools: params.enableTools,
           extra: params.extra || null,
         };
 
         // Make a direct API call to the new endpoint
         const response = await axios.post<JoinResponse>(
           `${SPEAKING_API_URL}/bots`,
           botRequest
         );
 
         if (response.data.bot_id) {
           return {
             content: [
               {
                 type: "text",
                 text: `Successfully joined meeting with speaking bot ID: ${response.data.bot_id}`,
               },
             ],
           };
         }
 
         return {
           content: [
             {
               type: "text",
               text: "No bot ID received in the response",
             },
           ],
           isError: true,
         };
       } catch (error) {
         console.error("Failed to join meeting with speaking bot:", error);
 
         let errorMessage = "Failed to join meeting with speaking bot: ";
         if (error instanceof Error) {
           errorMessage += error.message;
         } else if (typeof error === "string") {
           errorMessage += error;
         } else {
           errorMessage += "Unknown error occurred";
         }
 
         return {
           content: [
             {
               type: "text",
               text: errorMessage,
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  // For Leave Speaking Meeting
+  // Add a leave meeting tool for the speaking bot
   server.tool(
     "leaveSpeakingMeeting",
     "Remove a speaking bot from a meeting by its ID.",
     {
       botId: z
         .string()
         .describe("The MeetingBaas bot ID to remove from the meeting"),
       meetingBaasApiKey: z
         .string()
         .describe("Your MeetingBaas API key for authentication"),
     },
     async (params) => {
       try {
         const leaveRequest = {
           meeting_baas_api_key: params.meetingBaasApiKey,
           bot_id: params.botId,
         };
 
         await axios.delete(`${SPEAKING_API_URL}/bots/${params.botId}`, {
           data: leaveRequest,
         });
 
         return {
           content: [
             {
               type: "text",
               text: `Successfully removed speaking bot ID: ${params.botId} from the meeting`,
             },
           ],
         };
       } catch (error) {
         console.error("Failed to remove speaking bot from meeting:", error);
 
         let errorMessage = "Failed to remove speaking bot: ";
         if (error instanceof Error) {
           errorMessage += error.message;
         } else if (typeof error === "string") {
           errorMessage += error;
         } else {
           errorMessage += "Unknown error occurred";
         }
 
         return {
           content: [
             {
               type: "text",
               text: errorMessage,
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   return server;
 }
diff --git a/package.json b/package.json
index 10b1e4f..26c0b5d 100644
--- a/package.json
+++ b/package.json
@@ -1,33 +1,33 @@
 {
   "name": "meetingbaas-mcp",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
     "build": "tsc",
     "build:watch": "tsc --watch",
     "start": "node -r dotenv/config dist/api/server.js",
     "dev": "tsc --watch & node -r dotenv/config dist/api/server.js",
     "test-client": "tsc && node dist/scripts/test-client.js"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
-    "@meeting-baas/sdk": "^4.0.4",
+    "@meeting-baas/sdk": "4.0.4",
     "@modelcontextprotocol/sdk": "^1.6.1",
     "axios": "^1.8.4",
     "content-type": "^1.0.5",
     "dotenv": "^16.4.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
     "@types/node": "^20.17.30",
     "tsup": "^8.4.0",
     "typescript": "^5.3.3"
   }
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# f0c94d94b94dd4472462051cd5afd2ee3bbb86a7
#KEY#COMMIT_DATE# 2025-04-23 11:43:22 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# try improve?
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools/bots/index.ts
- api/tools/bots/join.ts

#KEY#DIFF_RANGE# FROM: 1cf45b5fdaeac60e5b1074a41fcaf514d8b63035 TO: f0c94d94b94dd4472462051cd5afd2ee3bbb86a7
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools/bots/index.ts b/api/tools/bots/index.ts
index 2d948bf..eb9418c 100644
--- a/api/tools/bots/index.ts
+++ b/api/tools/bots/index.ts
@@ -1,14 +1,15 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp";
+import { registerJoinTool } from "./join";
 import { registerJoinSpeakingTool } from "./join-speaking";
 
 export function registerBotTools(
   server: McpServer,
   baasClient: BaasClient
 ): McpServer {
   // Register all bot-related tools
-  // let updatedServer = registerJoinTool(server, baasClient);
-  let updatedServer = registerJoinSpeakingTool(server);
+  let updatedServer = registerJoinTool(server, baasClient);
+  updatedServer = registerJoinSpeakingTool(updatedServer);
 
   return updatedServer;
 }
diff --git a/api/tools/bots/join.ts b/api/tools/bots/join.ts
index f4eba1b..c0c3401 100644
--- a/api/tools/bots/join.ts
+++ b/api/tools/bots/join.ts
@@ -13,240 +13,181 @@ export function registerJoinTool(
     "joinMeeting",
     "Send an AI bot to join a video meeting. The bot can record the meeting, transcribe speech (enabled by default using Gladia), and provide real-time audio streams. Use this when you want to: 1) Record a meeting 2) Get meeting transcriptions 3) Stream meeting audio 4) Monitor meeting attendance",
     {
       meetingUrl: z.string().url().describe("URL of the meeting to join"),
       botName: z
         .string()
         .describe("Name to display for the bot in the meeting"),
       botImage: z
         .string()
         .url()
         .optional()
         .describe(
           "The image to use for the bot, must be a URL. Recommended ratio is 4:3."
         ),
       entryMessage: z
         .string()
         .optional()
         .describe(
           "There are no entry messages on Microsoft Teams as guests outside of an organization do not have access to the chat."
         ),
       webhookUrl: z
         .string()
         .url()
         .optional()
         .describe(
           "A webhook URL to send events to, overrides the webhook URL set in your account settings."
         ),
       recordingMode: z
         .enum(RECORDING_MODES)
         .optional()
         .describe(
           "The recording mode for the bot, defaults to 'speaker_view'."
         ),
       speechToText: z
         .object({
           provider: z.string().default("gladia"),
           apiKey: z.string().optional(),
         })
         .default({ provider: "default" })
         .describe("The speech to text provider, defaults to Gladia."),
       streaming: z
         .object({
           input: z
             .string()
             .url()
             .optional()
             .describe("WebSocket URL for audio input"),
           output: z
             .string()
             .url()
             .optional()
             .describe("WebSocket URL for audio output"),
           audioFrequency: z
             .string()
             .optional()
             .describe("Audio frequency for streaming"),
         })
         .optional()
         .describe("Configure streaming capabilities for the bot"),
       automaticLeave: z
         .object({
           nooneJoinedTimeout: z
             .number()
             .optional()
             .describe("Timeout in seconds when no one joins"),
           waitingRoomTimeout: z
             .number()
             .optional()
             .describe("Timeout in seconds when in waiting room"),
         })
         .optional()
         .describe("Configure automatic leave behavior"),
       reserved: z
         .boolean()
         .default(false)
         .describe(
           "Whether or not the bot should come from the available pool of bots or be a dedicated bot. Reserved bots come in exactly 4 minutes after the request."
         ),
       startTime: z
         .number()
         .optional()
         .describe(
           "Unix timestamp (in milliseconds) for when the bot should join the meeting. The bot joins 4 minutes before the start time."
         ),
       deduplicationKey: z
         .string()
         .optional()
         .describe(
           "We prevent multiple bots with same API key joining a meeting within 5 mins, unless overridden by deduplication_key."
         ),
       extra: z
         .record(z.unknown())
         .optional()
         .describe(
           "A Json object that allows you to add custom data to a bot for your convenience, e.g. your end user's ID."
         ),
     },
     async (params) => {
       try {
         // Create the join request object that matches the SDK's expected format
-        // Need to cast to any due to field name differences between our snake_case and the SDK types
-        const joinRequest: any = {
-          meeting_url: params.meetingUrl,
-          bot_name: params.botName,
-          bot_image:
-            params.botImage ||
-            "https://meetingbaas.com/static/a3e9f3dbde935920a3558317a514ff1a/b5380/preview.png",
-          webhook_url: params.webhookUrl,
-          recording_mode: params.recordingMode || "speaker_view",
-          speech_to_text: params.speechToText
-            ? {
-                provider:
-                  params.speechToText.provider === "default"
-                    ? "Default"
-                    : params.speechToText.provider === "gladia"
-                    ? "Gladia"
-                    : params.speechToText.provider === "runpod"
-                    ? "Runpod"
-                    : "Default",
-                api_key: params.speechToText.apiKey,
-              }
-            : {
-                provider: "Default",
-              },
-          reserved: params.reserved || false,
+        const joinRequest = {
+          meetingUrl: params.meetingUrl,
+          botName: params.botName,
+          botImage: params.botImage,
+          webhookUrl: params.webhookUrl,
+          recordingMode: params.recordingMode || "speaker_view",
+          speechToText: params.speechToText && {
+            provider: params.speechToText.provider,
+            apiKey: params.speechToText.apiKey,
+          },
+          reserved: params.reserved,
           streaming: params.streaming && {
             input: params.streaming.input,
             output: params.streaming.output,
-            audio_frequency: params.streaming.audioFrequency,
+            audioFrequency: params.streaming.audioFrequency,
           },
-          automatic_leave: params.automaticLeave && {
-            noone_joined_timeout: params.automaticLeave.nooneJoinedTimeout,
-            waiting_room_timeout: params.automaticLeave.waitingRoomTimeout,
+          automaticLeave: params.automaticLeave && {
+            nooneJoinedTimeout: params.automaticLeave.nooneJoinedTimeout,
+            waitingRoomTimeout: params.automaticLeave.waitingRoomTimeout,
           },
-          start_time: params.startTime,
-          deduplication_key: params.deduplicationKey,
+          startTime: params.startTime,
+          deduplicationKey: params.deduplicationKey,
           extra: params.extra,
         };
 
         // Use the BaasClient's defaultApi methods
         const response = await baasClient.defaultApi.join({
           joinRequest,
         });
 
-        // Type assertion to handle the snake_case vs camelCase mismatch
-        const responseData = response.data as unknown as { bot_id?: string };
-
-        if (responseData?.bot_id) {
+        if (response.data?.botId) {
           return {
             content: [
               {
                 type: "text",
                 text: `Successfully joined meeting with bot ID: ${
-                  responseData.bot_id
+                  response.data.botId
                 } (Speech-to-text enabled by default using ${
                   params.speechToText?.provider || "default"
                 } provider)`,
               },
             ],
           };
         }
 
         return {
           content: [
             {
               type: "text",
               text: "No bot ID received in the response",
             },
           ],
           isError: true,
         };
       } catch (error) {
         console.error("Failed to join meeting:", error);
 
-        // Log the request payload that was sent
-        console.error(
-          "Request payload:",
-          JSON.stringify(
-            {
-              meetingUrl: params.meetingUrl,
-              botName: params.botName,
-              botImage: params.botImage,
-              // Include other relevant fields
-              recordingMode: params.recordingMode,
-              reserved: params.reserved,
-              speechToText: params.speechToText,
-            },
-            null,
-            2
-          )
-        );
-
         let errorMessage = "Failed to join meeting: ";
-
-        // Type for axios error that includes response
-        type AxiosErrorWithResponse = Error & {
-          response?: {
-            status: number;
-            data: any;
-          };
-        };
-
         if (error instanceof Error) {
           errorMessage += error.message;
-
-          // Check for axios error with response data using type assertion
-          const axiosError = error as AxiosErrorWithResponse;
-          if (axiosError.response && axiosError.response.data) {
-            console.error("Error response status:", axiosError.response.status);
-            console.error(
-              "Error response data:",
-              JSON.stringify(axiosError.response.data, null, 2)
-            );
-            errorMessage += ` - ${JSON.stringify(
-              axiosError.response.data,
-              null,
-              2
-            )}`;
-          }
         } else if (typeof error === "string") {
           errorMessage += error;
         } else {
           errorMessage += "Unknown error occurred";
         }
 
         return {
           content: [
             {
               type: "text",
               text: errorMessage,
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   return server;
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 2482f67cd4edd31c963fbabaf706f5f1ef630c94
#KEY#COMMIT_DATE# 2025-04-23 11:43:17 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# fix: properly register speaking
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- .env
- api/tools.ts
- api/tools/bots/index.ts
- api/tools/bots/join-speaking.ts
- api/tools/bots/join.ts
- api/tools/utils/echo.ts
- connect-stdio.md
- global.d.ts
- llm-ai-sdk.mdc
- logs/mcp-server.log
- package.json
- pnpm-lock.yaml
- rules/baas-sdk.mdc
- scripts/test-client.js
- tsconfig.paths.json

#KEY#DIFF_RANGE# FROM: f0c94d94b94dd4472462051cd5afd2ee3bbb86a7 TO: 2482f67cd4edd31c963fbabaf706f5f1ef630c94
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools.ts b/api/tools.ts
index 031d23e..2dcddf8 100644
--- a/api/tools.ts
+++ b/api/tools.ts
@@ -1,115 +1,115 @@
-import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client";
-import { Provider } from "@meeting-baas/sdk/dist/baas/models/provider";
-import { McpServer } from "@modelcontextprotocol/sdk/server/mcp";
+import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client.js";
+import { Provider } from "@meeting-baas/sdk/dist/baas/models/provider.js";
+import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import z from "zod";
-import { registerBotTools } from "./tools/bots/index";
-import { registerEchoTool } from "./tools/utils/echo";
+import { registerJoinTool } from "./tools/bots/join.js";
+import { registerEchoTool } from "./tools/utils/echo.js";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
     baseUrl: "https://api.meetingbaas.com/",
   });
 
   // Register bot tools
-  const updatedServer = registerBotTools(server, baasClient);
+  const updatedServer = registerJoinTool(server, baasClient);
 
   // Register Meeting BaaS SDK tools
   updatedServer.tool(
     "leaveMeeting",
     "Remove an AI bot from a meeting. Use this when you want to: 1) End a meeting recording 2) Stop transcription 3) Disconnect the bot from the meeting",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         console.log(`Attempting to remove bot ${botId} from meeting...`);
         //
         const response = await baasClient.defaultApi.leave({
           params: { uuid: botId },
         });
         console.log(
           "Leave meeting response:",
           JSON.stringify(response.data, null, 2)
         );
 
         if (!response.data) {
           console.error("Leave meeting response missing data");
           return {
             content: [
               {
                 type: "text",
                 text: "Failed to leave meeting: No response data received",
               },
             ],
             isError: true,
           };
         }
 
         return {
           content: [
             {
               type: "text",
               text: `Successfully removed bot ${botId} from meeting`,
             },
           ],
         };
       } catch (error) {
         console.error("Failed to leave meeting:", error);
         let errorMessage = "Failed to leave meeting";
 
         if (error instanceof Error) {
           console.error("Error details:", {
             name: error.name,
             message: error.message,
             stack: error.stack,
           });
           errorMessage += `: ${error.message}`;
         } else if (typeof error === "object" && error !== null) {
           console.error("Error object:", JSON.stringify(error, null, 2));
         }
 
         return {
           content: [
             {
               type: "text",
               text: errorMessage,
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "getMeetingData",
     "Get data about a meeting that a bot has joined. Use this when you want to: 1) Check meeting status 2) Get recording information 3) Access transcription data",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         //
         const response = await baasClient.defaultApi.getMeetingData({ botId });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get meeting data:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get meeting data",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "deleteData",
diff --git a/api/tools/bots/index.ts b/api/tools/bots/index.ts
index eb9418c..42ca2bc 100644
--- a/api/tools/bots/index.ts
+++ b/api/tools/bots/index.ts
@@ -1,15 +1,15 @@
-import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client";
-import { McpServer } from "@modelcontextprotocol/sdk/server/mcp";
+import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client.js";
+import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { registerJoinTool } from "./join";
 import { registerJoinSpeakingTool } from "./join-speaking";
 
 export function registerBotTools(
   server: McpServer,
   baasClient: BaasClient
 ): McpServer {
   // Register all bot-related tools
   let updatedServer = registerJoinTool(server, baasClient);
   updatedServer = registerJoinSpeakingTool(updatedServer);
 
   return updatedServer;
 }
diff --git a/api/tools/bots/join-speaking.ts b/api/tools/bots/join-speaking.ts
index 1b36301..91bc1a5 100644
--- a/api/tools/bots/join-speaking.ts
+++ b/api/tools/bots/join-speaking.ts
@@ -1,101 +1,101 @@
-import { McpServer } from "@modelcontextprotocol/sdk/server/mcp";
+import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 // @ts-ignore
 import axios from "axios";
 import { z } from "zod";
 
 // Define the persona types based on the new schema
 const SPEAKING_API_URL = "https://speaking.meetingbaas.com";
 
 // Hardcoded list of available personas
 const AVAILABLE_PERSONAS = [
   "1940s_noir_detective",
   "academic_warlord",
   "ancient_alien_theorist",
   "ancient_roman_general",
   "arctic_prospector",
   "artisan_magnate",
   "astral_plane_uber_driver",
   "baas_onboarder",
   "bitcoin_maximalist",
   "buddhist_monk",
   "climate_engineer",
   "corporate_girlboss",
   "cpp_veteran",
   "crypto_patriarch",
   "cyberpunk_grandma",
   "data_baron",
   "debate_champion",
   "deep_sea_therapist",
   "environmental_activist",
   "factory_patriarch",
   "fading_diplomat",
   "forensic_accountant",
   "french_renaissance_painter",
   "futuristic_ai_philosopher",
   "genetic_aristocrat",
   "gladiator_chef",
   "golang_minimalist",
   "grafana_guru",
   "haskell_purist",
   "hospital_administrator",
   "immigration_maximalist",
   "intelligence_officer",
   "interdimensional_therapist",
   "intergalactic_barista",
   "interviewer",
   "kgb_ballerina",
   "lisp_enlightened",
   "master_sommelier",
   "media_cardinal",
   "medieval_crypto_trader",
   "medieval_plague_doctor",
   "memory_merchant",
   "military_strategist",
   "mongolian_shepherd",
   "neural_interface_mogul",
   "ninja_librarian",
   "oligarch_widow",
   "pair_programmer",
   "pharma_patriarch",
   "pirate_queen",
   "poker_champion",
   "port_master",
   "prehistoric_foodie",
   "quantum_financier",
   "quantum_mechanic",
   "quantum_physicist",
   "renaissance_gym_bro",
   "renaissance_soundcloud_rapper",
   "revolutionary_hacker",
   "rust_evangelist",
   "southern_grandma",
   "space_exploration_robot",
   "space_industrialist",
   "stoic_philosopher",
   "stone_age_tech_support",
   "synthetic_food_baron",
   "time_traveling_influencer",
   "underground_banker",
   "urban_mining_tycoon",
   "vatican_cybersecurity_officer",
   "victorian_etiquette_coach",
   "victorian_serial_killer",
   "war_correspondent",
   "waste_baron",
   "water_merchant",
 ];
 
 // Define types based on the OpenAPI specification
 interface BotRequest {
   meeting_url: string;
   bot_name: string;
   meeting_baas_api_key: string;
   personas?: string[] | null;
   bot_image?: string | null;
   entry_message?: string | null;
   extra?: Record<string, unknown> | null;
   enable_tools?: boolean;
 }
 
 interface JoinResponse {
   bot_id: string;
diff --git a/api/tools/bots/join.ts b/api/tools/bots/join.ts
index c0c3401..adb3056 100644
--- a/api/tools/bots/join.ts
+++ b/api/tools/bots/join.ts
@@ -1,102 +1,102 @@
-import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client";
-import { McpServer } from "@modelcontextprotocol/sdk/server/mcp";
+import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client.js";
+import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { z } from "zod";
 
 // Constants for configuration based on OpenAPI spec
 const RECORDING_MODES = ["speaker_view", "gallery_view", "audio_only"] as const;
 
 export function registerJoinTool(
   server: McpServer,
   baasClient: BaasClient
 ): McpServer {
   server.tool(
     "joinMeeting",
     "Send an AI bot to join a video meeting. The bot can record the meeting, transcribe speech (enabled by default using Gladia), and provide real-time audio streams. Use this when you want to: 1) Record a meeting 2) Get meeting transcriptions 3) Stream meeting audio 4) Monitor meeting attendance",
     {
       meetingUrl: z.string().url().describe("URL of the meeting to join"),
       botName: z
         .string()
         .describe("Name to display for the bot in the meeting"),
       botImage: z
         .string()
         .url()
         .optional()
         .describe(
           "The image to use for the bot, must be a URL. Recommended ratio is 4:3."
         ),
       entryMessage: z
         .string()
         .optional()
         .describe(
           "There are no entry messages on Microsoft Teams as guests outside of an organization do not have access to the chat."
         ),
       webhookUrl: z
         .string()
         .url()
         .optional()
         .describe(
           "A webhook URL to send events to, overrides the webhook URL set in your account settings."
         ),
       recordingMode: z
         .enum(RECORDING_MODES)
         .optional()
         .describe(
           "The recording mode for the bot, defaults to 'speaker_view'."
         ),
       speechToText: z
         .object({
           provider: z.string().default("gladia"),
           apiKey: z.string().optional(),
         })
         .default({ provider: "default" })
         .describe("The speech to text provider, defaults to Gladia."),
       streaming: z
         .object({
           input: z
             .string()
             .url()
             .optional()
             .describe("WebSocket URL for audio input"),
           output: z
             .string()
             .url()
             .optional()
             .describe("WebSocket URL for audio output"),
           audioFrequency: z
             .string()
             .optional()
             .describe("Audio frequency for streaming"),
         })
         .optional()
         .describe("Configure streaming capabilities for the bot"),
       automaticLeave: z
         .object({
           nooneJoinedTimeout: z
             .number()
             .optional()
             .describe("Timeout in seconds when no one joins"),
           waitingRoomTimeout: z
             .number()
             .optional()
             .describe("Timeout in seconds when in waiting room"),
         })
         .optional()
         .describe("Configure automatic leave behavior"),
       reserved: z
         .boolean()
         .default(false)
         .describe(
           "Whether or not the bot should come from the available pool of bots or be a dedicated bot. Reserved bots come in exactly 4 minutes after the request."
         ),
       startTime: z
         .number()
         .optional()
         .describe(
           "Unix timestamp (in milliseconds) for when the bot should join the meeting. The bot joins 4 minutes before the start time."
         ),
       deduplicationKey: z
         .string()
         .optional()
         .describe(
           "We prevent multiple bots with same API key joining a meeting within 5 mins, unless overridden by deduplication_key."
         ),
diff --git a/api/tools/utils/echo.ts b/api/tools/utils/echo.ts
index 2e52fbd..9d1d3e3 100644
--- a/api/tools/utils/echo.ts
+++ b/api/tools/utils/echo.ts
@@ -1,19 +1,15 @@
-import { McpServer } from "@modelcontextprotocol/sdk/server/mcp";
 import { z } from "zod";
+import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 
 export function registerEchoTool(server: McpServer): McpServer {
-  server.tool(
-    "echo",
-    { message: z.string() },
-    async ({ message }: { message: string }) => ({
-      content: [
-        {
-          type: "text",
-          text: `Tool echo: ${message}`,
-        },
-      ],
-    })
-  );
+  server.tool("echo", { message: z.string() }, async ({ message }: { message: string }) => ({
+    content: [
+      {
+        type: "text",
+        text: `Tool echo: ${message}`,
+      },
+    ],
+  }));
 
   return server;
-}
+} 
\ No newline at end of file
diff --git a/package.json b/package.json
index 26c0b5d..5d869a9 100644
--- a/package.json
+++ b/package.json
@@ -1,33 +1,32 @@
 {
   "name": "meetingbaas-mcp",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
     "build": "tsc",
     "build:watch": "tsc --watch",
     "start": "node -r dotenv/config dist/api/server.js",
-    "dev": "tsc --watch & node -r dotenv/config dist/api/server.js",
-    "test-client": "tsc && node dist/scripts/test-client.js"
+    "dev": "tsc --watch & node -r dotenv/config dist/api/server.js"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
     "@meeting-baas/sdk": "4.0.4",
     "@modelcontextprotocol/sdk": "^1.6.1",
     "axios": "^1.8.4",
     "content-type": "^1.0.5",
     "dotenv": "^16.4.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
     "@types/node": "^20.17.30",
     "tsup": "^8.4.0",
     "typescript": "^5.3.3"
   }
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 49c8cbeb6a25abc396fd0ad6c2f54f095bc4eb03
#KEY#COMMIT_DATE# 2025-04-23 11:43:17 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# sdk compatibilit
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools/bots/index.ts

#KEY#DIFF_RANGE# FROM: 2482f67cd4edd31c963fbabaf706f5f1ef630c94 TO: 49c8cbeb6a25abc396fd0ad6c2f54f095bc4eb03
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools/bots/index.ts b/api/tools/bots/index.ts
index 42ca2bc..43aa95f 100644
--- a/api/tools/bots/index.ts
+++ b/api/tools/bots/index.ts
@@ -1,15 +1,15 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client.js";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { registerJoinTool } from "./join";
 import { registerJoinSpeakingTool } from "./join-speaking";
 
 export function registerBotTools(
   server: McpServer,
   baasClient: BaasClient
 ): McpServer {
   // Register all bot-related tools
   let updatedServer = registerJoinTool(server, baasClient);
-  updatedServer = registerJoinSpeakingTool(updatedServer);
+  updatedServer = registerJoinSpeakingTool(server);
 
   return updatedServer;
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# d2eb0b12f85b8b879df03643388f0db2f5a82b7f
#KEY#COMMIT_DATE# 2025-04-23 11:43:17 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# switch join tool to SDK usage
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools/bots/join.ts

#KEY#DIFF_RANGE# FROM: 49c8cbeb6a25abc396fd0ad6c2f54f095bc4eb03 TO: d2eb0b12f85b8b879df03643388f0db2f5a82b7f
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools/bots/join.ts b/api/tools/bots/join.ts
index adb3056..cd276b2 100644
--- a/api/tools/bots/join.ts
+++ b/api/tools/bots/join.ts
@@ -12,182 +12,182 @@ export function registerJoinTool(
   server.tool(
     "joinMeeting",
     "Send an AI bot to join a video meeting. The bot can record the meeting, transcribe speech (enabled by default using Gladia), and provide real-time audio streams. Use this when you want to: 1) Record a meeting 2) Get meeting transcriptions 3) Stream meeting audio 4) Monitor meeting attendance",
     {
       meetingUrl: z.string().url().describe("URL of the meeting to join"),
       botName: z
         .string()
         .describe("Name to display for the bot in the meeting"),
       botImage: z
         .string()
         .url()
         .optional()
         .describe(
           "The image to use for the bot, must be a URL. Recommended ratio is 4:3."
         ),
       entryMessage: z
         .string()
         .optional()
         .describe(
           "There are no entry messages on Microsoft Teams as guests outside of an organization do not have access to the chat."
         ),
       webhookUrl: z
         .string()
         .url()
         .optional()
         .describe(
           "A webhook URL to send events to, overrides the webhook URL set in your account settings."
         ),
       recordingMode: z
         .enum(RECORDING_MODES)
         .optional()
         .describe(
           "The recording mode for the bot, defaults to 'speaker_view'."
         ),
       speechToText: z
         .object({
           provider: z.string().default("gladia"),
           apiKey: z.string().optional(),
         })
         .default({ provider: "default" })
         .describe("The speech to text provider, defaults to Gladia."),
       streaming: z
         .object({
           input: z
             .string()
             .url()
             .optional()
             .describe("WebSocket URL for audio input"),
           output: z
             .string()
             .url()
             .optional()
             .describe("WebSocket URL for audio output"),
           audioFrequency: z
             .string()
             .optional()
             .describe("Audio frequency for streaming"),
         })
         .optional()
         .describe("Configure streaming capabilities for the bot"),
       automaticLeave: z
         .object({
           nooneJoinedTimeout: z
             .number()
             .optional()
             .describe("Timeout in seconds when no one joins"),
           waitingRoomTimeout: z
             .number()
             .optional()
             .describe("Timeout in seconds when in waiting room"),
         })
         .optional()
         .describe("Configure automatic leave behavior"),
       reserved: z
         .boolean()
         .default(false)
         .describe(
           "Whether or not the bot should come from the available pool of bots or be a dedicated bot. Reserved bots come in exactly 4 minutes after the request."
         ),
       startTime: z
         .number()
         .optional()
         .describe(
           "Unix timestamp (in milliseconds) for when the bot should join the meeting. The bot joins 4 minutes before the start time."
         ),
       deduplicationKey: z
         .string()
         .optional()
         .describe(
           "We prevent multiple bots with same API key joining a meeting within 5 mins, unless overridden by deduplication_key."
         ),
       extra: z
         .record(z.unknown())
         .optional()
         .describe(
           "A Json object that allows you to add custom data to a bot for your convenience, e.g. your end user's ID."
         ),
     },
     async (params) => {
       try {
-        // Create the join request object that matches the SDK's expected format
+        // Create the join request
         const joinRequest = {
           meetingUrl: params.meetingUrl,
           botName: params.botName,
           botImage: params.botImage,
           webhookUrl: params.webhookUrl,
           recordingMode: params.recordingMode || "speaker_view",
           speechToText: params.speechToText && {
             provider: params.speechToText.provider,
             apiKey: params.speechToText.apiKey,
           },
           reserved: params.reserved,
           streaming: params.streaming && {
             input: params.streaming.input,
             output: params.streaming.output,
             audioFrequency: params.streaming.audioFrequency,
           },
           automaticLeave: params.automaticLeave && {
             nooneJoinedTimeout: params.automaticLeave.nooneJoinedTimeout,
             waitingRoomTimeout: params.automaticLeave.waitingRoomTimeout,
           },
           startTime: params.startTime,
           deduplicationKey: params.deduplicationKey,
           extra: params.extra,
         };
 
-        // Use the BaasClient's defaultApi methods
+        // Use the baasClient's join method instead of direct axios call
         const response = await baasClient.defaultApi.join({
           joinRequest,
         });
 
         if (response.data?.botId) {
           return {
             content: [
               {
                 type: "text",
                 text: `Successfully joined meeting with bot ID: ${
                   response.data.botId
                 } (Speech-to-text enabled by default using ${
                   params.speechToText?.provider || "default"
                 } provider)`,
               },
             ],
           };
         }
 
         return {
           content: [
             {
               type: "text",
               text: "No bot ID received in the response",
             },
           ],
           isError: true,
         };
       } catch (error) {
         console.error("Failed to join meeting:", error);
 
         let errorMessage = "Failed to join meeting: ";
         if (error instanceof Error) {
           errorMessage += error.message;
         } else if (typeof error === "string") {
           errorMessage += error;
         } else {
           errorMessage += "Unknown error occurred";
         }
 
         return {
           content: [
             {
               type: "text",
               text: errorMessage,
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   return server;
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 5a619d200816e76c58b7b9ff962e20782bb0e4ae
#KEY#COMMIT_DATE# 2025-04-23 11:43:17 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# fix: baseUrl in BaasClient
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools/bots/join.ts

#KEY#DIFF_RANGE# FROM: d2eb0b12f85b8b879df03643388f0db2f5a82b7f TO: 5a619d200816e76c58b7b9ff962e20782bb0e4ae
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools/bots/join.ts b/api/tools/bots/join.ts
index cd276b2..c39a63d 100644
--- a/api/tools/bots/join.ts
+++ b/api/tools/bots/join.ts
@@ -1,193 +1,203 @@
-import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client.js";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
+import axios from "axios";
 import { z } from "zod";
 
 // Constants for configuration based on OpenAPI spec
 const RECORDING_MODES = ["speaker_view", "gallery_view", "audio_only"] as const;
 
 export function registerJoinTool(
   server: McpServer,
-  baasClient: BaasClient
+  baasClient: any
 ): McpServer {
   server.tool(
     "joinMeeting",
     "Send an AI bot to join a video meeting. The bot can record the meeting, transcribe speech (enabled by default using Gladia), and provide real-time audio streams. Use this when you want to: 1) Record a meeting 2) Get meeting transcriptions 3) Stream meeting audio 4) Monitor meeting attendance",
     {
       meetingUrl: z.string().url().describe("URL of the meeting to join"),
       botName: z
         .string()
         .describe("Name to display for the bot in the meeting"),
       botImage: z
         .string()
         .url()
         .optional()
         .describe(
           "The image to use for the bot, must be a URL. Recommended ratio is 4:3."
         ),
       entryMessage: z
         .string()
         .optional()
         .describe(
           "There are no entry messages on Microsoft Teams as guests outside of an organization do not have access to the chat."
         ),
       webhookUrl: z
         .string()
         .url()
         .optional()
         .describe(
           "A webhook URL to send events to, overrides the webhook URL set in your account settings."
         ),
       recordingMode: z
         .enum(RECORDING_MODES)
         .optional()
         .describe(
           "The recording mode for the bot, defaults to 'speaker_view'."
         ),
       speechToText: z
         .object({
           provider: z.string().default("gladia"),
           apiKey: z.string().optional(),
         })
         .default({ provider: "default" })
         .describe("The speech to text provider, defaults to Gladia."),
       streaming: z
         .object({
           input: z
             .string()
             .url()
             .optional()
             .describe("WebSocket URL for audio input"),
           output: z
             .string()
             .url()
             .optional()
             .describe("WebSocket URL for audio output"),
           audioFrequency: z
             .string()
             .optional()
             .describe("Audio frequency for streaming"),
         })
         .optional()
         .describe("Configure streaming capabilities for the bot"),
       automaticLeave: z
         .object({
           nooneJoinedTimeout: z
             .number()
             .optional()
             .describe("Timeout in seconds when no one joins"),
           waitingRoomTimeout: z
             .number()
             .optional()
             .describe("Timeout in seconds when in waiting room"),
         })
         .optional()
         .describe("Configure automatic leave behavior"),
       reserved: z
         .boolean()
         .default(false)
         .describe(
           "Whether or not the bot should come from the available pool of bots or be a dedicated bot. Reserved bots come in exactly 4 minutes after the request."
         ),
       startTime: z
         .number()
         .optional()
         .describe(
           "Unix timestamp (in milliseconds) for when the bot should join the meeting. The bot joins 4 minutes before the start time."
         ),
       deduplicationKey: z
         .string()
         .optional()
         .describe(
           "We prevent multiple bots with same API key joining a meeting within 5 mins, unless overridden by deduplication_key."
         ),
       extra: z
         .record(z.unknown())
         .optional()
         .describe(
           "A Json object that allows you to add custom data to a bot for your convenience, e.g. your end user's ID."
         ),
     },
     async (params) => {
       try {
+        // Use the baasClient, but access the underlying request config to get the API key
+        const apiKey = baasClient.configuration.apiKey;
+
         // Create the join request
         const joinRequest = {
-          meetingUrl: params.meetingUrl,
-          botName: params.botName,
-          botImage: params.botImage,
-          webhookUrl: params.webhookUrl,
-          recordingMode: params.recordingMode || "speaker_view",
-          speechToText: params.speechToText && {
+          meeting_url: params.meetingUrl,
+          bot_name: params.botName,
+          bot_image: params.botImage,
+          webhook_url: params.webhookUrl,
+          recording_mode: params.recordingMode || "speaker_view",
+          speech_to_text: params.speechToText && {
             provider: params.speechToText.provider,
-            apiKey: params.speechToText.apiKey,
+            api_key: params.speechToText.apiKey,
           },
           reserved: params.reserved,
           streaming: params.streaming && {
             input: params.streaming.input,
             output: params.streaming.output,
-            audioFrequency: params.streaming.audioFrequency,
+            audio_frequency: params.streaming.audioFrequency,
           },
-          automaticLeave: params.automaticLeave && {
-            nooneJoinedTimeout: params.automaticLeave.nooneJoinedTimeout,
-            waitingRoomTimeout: params.automaticLeave.waitingRoomTimeout,
+          automatic_leave: params.automaticLeave && {
+            noone_joined_timeout: params.automaticLeave.nooneJoinedTimeout,
+            waiting_room_timeout: params.automaticLeave.waitingRoomTimeout,
           },
-          startTime: params.startTime,
-          deduplicationKey: params.deduplicationKey,
+          start_time: params.startTime,
+          deduplication_key: params.deduplicationKey,
           extra: params.extra,
         };
 
-        // Use the baasClient's join method instead of direct axios call
-        const response = await baasClient.defaultApi.join({
-          joinRequest,
-        });
+        // Make a direct API call
+        const response = await axios.post(
+          "https://api.meetingbaas.com/v1/bots/join",
+          { joinRequest },
+          {
+            headers: {
+              "X-API-Key": apiKey,
+              "Content-Type": "application/json",
+            },
+          }
+        );
 
-        if (response.data?.botId) {
+        if (response.data.bot_id) {
           return {
             content: [
               {
                 type: "text",
                 text: `Successfully joined meeting with bot ID: ${
-                  response.data.botId
+                  response.data.bot_id
                 } (Speech-to-text enabled by default using ${
                   params.speechToText?.provider || "default"
                 } provider)`,
               },
             ],
           };
         }
 
         return {
           content: [
             {
               type: "text",
               text: "No bot ID received in the response",
             },
           ],
           isError: true,
         };
       } catch (error) {
         console.error("Failed to join meeting:", error);
 
         let errorMessage = "Failed to join meeting: ";
         if (error instanceof Error) {
           errorMessage += error.message;
         } else if (typeof error === "string") {
           errorMessage += error;
         } else {
           errorMessage += "Unknown error occurred";
         }
 
         return {
           content: [
             {
               type: "text",
               text: errorMessage,
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   return server;
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# efad1ffa04176e8a59fca6f811d1eaac742e8b8d
#KEY#COMMIT_DATE# 2025-04-23 11:43:17 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# bump to 4.0.4
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools.ts
- tsconfig.json

#KEY#DIFF_RANGE# FROM: 5a619d200816e76c58b7b9ff962e20782bb0e4ae TO: efad1ffa04176e8a59fca6f811d1eaac742e8b8d
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools.ts b/api/tools.ts
index 2dcddf8..c427a6f 100644
--- a/api/tools.ts
+++ b/api/tools.ts
@@ -1,111 +1,110 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client.js";
 import { Provider } from "@meeting-baas/sdk/dist/baas/models/provider.js";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import z from "zod";
 import { registerJoinTool } from "./tools/bots/join.js";
 import { registerEchoTool } from "./tools/utils/echo.js";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
-    baseUrl: "https://api.meetingbaas.com/",
   });
 
   // Register bot tools
   const updatedServer = registerJoinTool(server, baasClient);
 
   // Register Meeting BaaS SDK tools
   updatedServer.tool(
     "leaveMeeting",
     "Remove an AI bot from a meeting. Use this when you want to: 1) End a meeting recording 2) Stop transcription 3) Disconnect the bot from the meeting",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         console.log(`Attempting to remove bot ${botId} from meeting...`);
         //
         const response = await baasClient.defaultApi.leave({
           params: { uuid: botId },
         });
         console.log(
           "Leave meeting response:",
           JSON.stringify(response.data, null, 2)
         );
 
         if (!response.data) {
           console.error("Leave meeting response missing data");
           return {
             content: [
               {
                 type: "text",
                 text: "Failed to leave meeting: No response data received",
               },
             ],
             isError: true,
           };
         }
 
         return {
           content: [
             {
               type: "text",
               text: `Successfully removed bot ${botId} from meeting`,
             },
           ],
         };
       } catch (error) {
         console.error("Failed to leave meeting:", error);
         let errorMessage = "Failed to leave meeting";
 
         if (error instanceof Error) {
           console.error("Error details:", {
             name: error.name,
             message: error.message,
             stack: error.stack,
           });
           errorMessage += `: ${error.message}`;
         } else if (typeof error === "object" && error !== null) {
           console.error("Error object:", JSON.stringify(error, null, 2));
         }
 
         return {
           content: [
             {
               type: "text",
               text: errorMessage,
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "getMeetingData",
     "Get data about a meeting that a bot has joined. Use this when you want to: 1) Check meeting status 2) Get recording information 3) Access transcription data",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         //
         const response = await baasClient.defaultApi.getMeetingData({ botId });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get meeting data:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get meeting data",
             },
           ],
           isError: true,
         };
       }
     }
diff --git a/tsconfig.json b/tsconfig.json
index cba2482..35e81e5 100644
--- a/tsconfig.json
+++ b/tsconfig.json
@@ -1,19 +1,19 @@
 {
   "compilerOptions": {
     "target": "ES2020",
     "module": "CommonJS",
     "lib": ["ES2020"],
     "outDir": "./dist",
     "rootDir": "./",
     "strict": true,
     "esModuleInterop": true,
     "skipLibCheck": true,
     "forceConsistentCasingInFileNames": true,
     "moduleResolution": "node",
     "resolveJsonModule": true,
     "declaration": true,
     "sourceMap": true
   },
-  "include": ["api/**/*", "lib/**/*", "types/**/*"],
+  "include": ["api/**/*", "lib/**/*"],
   "exclude": ["node_modules", "dist"]
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 96d97a841892934daef722df23bad693650aad6e
#KEY#COMMIT_DATE# 2025-04-23 11:43:17 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# bump to 4.0.3 meeting-baas
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- package.json
- pnpm-lock.yaml

#KEY#DIFF_RANGE# FROM: efad1ffa04176e8a59fca6f811d1eaac742e8b8d TO: 96d97a841892934daef722df23bad693650aad6e
=================================================================

#KEY#GIT_DIFF#

diff --git a/package.json b/package.json
index 5d869a9..a5e6cf4 100644
--- a/package.json
+++ b/package.json
@@ -1,32 +1,32 @@
 {
   "name": "meetingbaas-mcp",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
     "build": "tsc",
     "build:watch": "tsc --watch",
     "start": "node -r dotenv/config dist/api/server.js",
     "dev": "tsc --watch & node -r dotenv/config dist/api/server.js"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
-    "@meeting-baas/sdk": "4.0.4",
+    "@meeting-baas/sdk": "4.0.3",
     "@modelcontextprotocol/sdk": "^1.6.1",
     "axios": "^1.8.4",
     "content-type": "^1.0.5",
     "dotenv": "^16.4.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
     "@types/node": "^20.17.30",
     "tsup": "^8.4.0",
     "typescript": "^5.3.3"
   }
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 86d7fdbd96f93561a5bffdda1a6b7cc3d054091c
#KEY#COMMIT_DATE# 2025-04-23 11:43:17 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# bump 4.0.2
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- package.json
- pnpm-lock.yaml

#KEY#DIFF_RANGE# FROM: 96d97a841892934daef722df23bad693650aad6e TO: 86d7fdbd96f93561a5bffdda1a6b7cc3d054091c
=================================================================

#KEY#GIT_DIFF#

diff --git a/package.json b/package.json
index a5e6cf4..5a64fa3 100644
--- a/package.json
+++ b/package.json
@@ -1,32 +1,32 @@
 {
   "name": "meetingbaas-mcp",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
     "build": "tsc",
     "build:watch": "tsc --watch",
     "start": "node -r dotenv/config dist/api/server.js",
     "dev": "tsc --watch & node -r dotenv/config dist/api/server.js"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
-    "@meeting-baas/sdk": "4.0.3",
+    "@meeting-baas/sdk": "4.0.2",
     "@modelcontextprotocol/sdk": "^1.6.1",
     "axios": "^1.8.4",
     "content-type": "^1.0.5",
     "dotenv": "^16.4.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
     "@types/node": "^20.17.30",
     "tsup": "^8.4.0",
     "typescript": "^5.3.3"
   }
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# b5eada9a0901145684d0b903c004b2f8b8fa7b72
#KEY#COMMIT_DATE# 2025-04-23 11:43:17 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# bump meeting baas
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- package.json

#KEY#DIFF_RANGE# FROM: 86d7fdbd96f93561a5bffdda1a6b7cc3d054091c TO: b5eada9a0901145684d0b903c004b2f8b8fa7b72
=================================================================

#KEY#GIT_DIFF#

diff --git a/package.json b/package.json
index 5a64fa3..fc5b289 100644
--- a/package.json
+++ b/package.json
@@ -1,32 +1,32 @@
 {
   "name": "meetingbaas-mcp",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
     "build": "tsc",
     "build:watch": "tsc --watch",
     "start": "node -r dotenv/config dist/api/server.js",
     "dev": "tsc --watch & node -r dotenv/config dist/api/server.js"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
-    "@meeting-baas/sdk": "4.0.2",
+    "@meeting-baas/sdk": "4.0.1",
     "@modelcontextprotocol/sdk": "^1.6.1",
     "axios": "^1.8.4",
     "content-type": "^1.0.5",
     "dotenv": "^16.4.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
     "@types/node": "^20.17.30",
     "tsup": "^8.4.0",
     "typescript": "^5.3.3"
   }
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# a210ed0d6d1b0f360fbb9540f4a7d36fb814d4fa
#KEY#COMMIT_DATE# 2025-04-23 11:43:17 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# bump version
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- package.json

#KEY#DIFF_RANGE# FROM: b5eada9a0901145684d0b903c004b2f8b8fa7b72 TO: a210ed0d6d1b0f360fbb9540f4a7d36fb814d4fa
=================================================================

#KEY#GIT_DIFF#

diff --git a/package.json b/package.json
index fc5b289..00e2ea7 100644
--- a/package.json
+++ b/package.json
@@ -1,32 +1,32 @@
 {
   "name": "meetingbaas-mcp",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
     "build": "tsc",
     "build:watch": "tsc --watch",
     "start": "node -r dotenv/config dist/api/server.js",
     "dev": "tsc --watch & node -r dotenv/config dist/api/server.js"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
-    "@meeting-baas/sdk": "4.0.1",
+    "@meeting-baas/sdk": "4.0.0",
     "@modelcontextprotocol/sdk": "^1.6.1",
     "axios": "^1.8.4",
     "content-type": "^1.0.5",
     "dotenv": "^16.4.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
     "@types/node": "^20.17.30",
     "tsup": "^8.4.0",
     "typescript": "^5.3.3"
   }
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# e83cf9935190536f7c619234bddbf5e369b06d65
#KEY#COMMIT_DATE# 2025-04-23 11:43:17 +0200
#KEY#COMMIT_AUTHOR# amit-node-dev
#KEY#COMMIT_MESSAGE# Updating the library and minor fixes has been updated
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- package.json
- pnpm-lock.yaml

#KEY#DIFF_RANGE# FROM: a210ed0d6d1b0f360fbb9540f4a7d36fb814d4fa TO: e83cf9935190536f7c619234bddbf5e369b06d65
=================================================================

#KEY#GIT_DIFF#

diff --git a/package.json b/package.json
index 00e2ea7..f5443bd 100644
--- a/package.json
+++ b/package.json
@@ -1,32 +1,32 @@
 {
   "name": "meetingbaas-mcp",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
     "build": "tsc",
     "build:watch": "tsc --watch",
     "start": "node -r dotenv/config dist/api/server.js",
     "dev": "tsc --watch & node -r dotenv/config dist/api/server.js"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
-    "@meeting-baas/sdk": "4.0.0",
+    "@meeting-baas/sdk": "0.3.8",
     "@modelcontextprotocol/sdk": "^1.6.1",
     "axios": "^1.8.4",
     "content-type": "^1.0.5",
     "dotenv": "^16.4.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
     "@types/node": "^20.17.30",
     "tsup": "^8.4.0",
     "typescript": "^5.3.3"
   }
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# ec289bc3100bdddab784151a0d72c3b7e3b59948
#KEY#COMMIT_DATE# 2025-04-23 11:43:17 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# bump version, continue working
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- .gitignore
- api/tools.ts
- api/tools/bots/index.ts
- api/tools/index.ts

#KEY#DIFF_RANGE# FROM: e83cf9935190536f7c619234bddbf5e369b06d65 TO: ec289bc3100bdddab784151a0d72c3b7e3b59948
=================================================================

#KEY#GIT_DIFF#

diff --git a/.gitignore b/.gitignore
index e6d159b..e0a64ea 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,6 +1,2 @@
 .vercel
-node_modules
-
-/dist/
-
-package-lock.json
\ No newline at end of file
+node_modules
\ No newline at end of file
diff --git a/api/tools.ts b/api/tools.ts
index c427a6f..274ce3d 100644
--- a/api/tools.ts
+++ b/api/tools.ts
@@ -1,541 +1,510 @@
-import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client.js";
-import { Provider } from "@meeting-baas/sdk/dist/baas/models/provider.js";
+import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client";
+import { CreateCalendarParams } from "@meeting-baas/sdk/dist/baas/models/create-calendar-params";
+import { Provider } from "@meeting-baas/sdk/dist/baas/models/provider";
+import { UpdateCalendarParams } from "@meeting-baas/sdk/dist/baas/models/update-calendar-params";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import z from "zod";
-import { registerJoinTool } from "./tools/bots/join.js";
-import { registerEchoTool } from "./tools/utils/echo.js";
+import { registerJoinTool } from "./tools/bots/join";
+import { registerEchoTool } from "./tools/utils/echo";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
   });
 
   // Register bot tools
   const updatedServer = registerJoinTool(server, baasClient);
 
   // Register Meeting BaaS SDK tools
   updatedServer.tool(
     "leaveMeeting",
     "Remove an AI bot from a meeting. Use this when you want to: 1) End a meeting recording 2) Stop transcription 3) Disconnect the bot from the meeting",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
-        console.log(`Attempting to remove bot ${botId} from meeting...`);
-        //
-        const response = await baasClient.defaultApi.leave({
-          params: { uuid: botId },
+        await baasClient.defaultApi.leave({
+          headers: { "x-bot-id": botId },
         });
-        console.log(
-          "Leave meeting response:",
-          JSON.stringify(response.data, null, 2)
-        );
-
-        if (!response.data) {
-          console.error("Leave meeting response missing data");
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Failed to leave meeting: No response data received",
-              },
-            ],
-            isError: true,
-          };
-        }
-
         return {
           content: [
             {
               type: "text",
               text: `Successfully removed bot ${botId} from meeting`,
             },
           ],
         };
       } catch (error) {
-        console.error("Failed to leave meeting:", error);
-        let errorMessage = "Failed to leave meeting";
-
-        if (error instanceof Error) {
-          console.error("Error details:", {
-            name: error.name,
-            message: error.message,
-            stack: error.stack,
-          });
-          errorMessage += `: ${error.message}`;
-        } else if (typeof error === "object" && error !== null) {
-          console.error("Error object:", JSON.stringify(error, null, 2));
-        }
-
+        console.error("Error leaving meeting:", error);
         return {
           content: [
             {
               type: "text",
-              text: errorMessage,
+              text: "Failed to leave meeting",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "getMeetingData",
     "Get data about a meeting that a bot has joined. Use this when you want to: 1) Check meeting status 2) Get recording information 3) Access transcription data",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
-        //
-        const response = await baasClient.defaultApi.getMeetingData({ botId });
+        const response = await baasClient.defaultApi.getMeetingData({
+          botId,
+        });
         return {
           content: [
             {
               type: "text",
-              text: JSON.stringify(response.data, null, 2),
+              text: `Meeting data: ${JSON.stringify(response.data, null, 2)}`,
             },
           ],
         };
       } catch (error) {
-        console.error("Failed to get meeting data:", error);
+        console.error("Error getting meeting data:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get meeting data",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "deleteData",
     "Delete data associated with a meeting bot. Use this when you want to: 1) Remove meeting recordings 2) Delete transcription data 3) Clean up bot data",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
-        const response = await baasClient.defaultApi.deleteData({
-          params: { uuid: botId },
+        await baasClient.defaultApi.deleteData({
+          headers: { "x-bot-id": botId },
         });
         return {
           content: [
             {
               type: "text",
               text: "Successfully deleted meeting data",
             },
           ],
         };
       } catch (error) {
-        console.error("Failed to delete meeting data:", error);
+        console.error("Error deleting data:", error);
         return {
           content: [
             {
               type: "text",
-              text: "Failed to delete meeting data",
+              text: "Failed to delete data",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "createCalendar",
     "Create a new calendar integration. Use this when you want to: 1) Set up automatic meeting recordings 2) Configure calendar-based bot scheduling 3) Enable recurring meeting coverage",
     {
       oauthClientId: z.string(),
       oauthClientSecret: z.string(),
       oauthRefreshToken: z.string(),
       platform: z.enum(["Google", "Microsoft"]),
-      rawCalendarId: z.string().optional(),
+      rawCalendarId: z.string(),
     },
     async ({
       oauthClientId,
       oauthClientSecret,
       oauthRefreshToken,
       platform,
       rawCalendarId,
     }) => {
       try {
-        const calendarParams = {
-          oauthClientId,
-          oauthClientSecret,
-          oauthRefreshToken,
+        let createCalendarParams: CreateCalendarParams = {
+          oauthClientId: oauthClientId,
+          oauthClientSecret: oauthClientSecret,
+          oauthRefreshToken: oauthRefreshToken,
           platform:
             platform === "Google" ? Provider.google : Provider.microsoft,
-          rawCalendarId,
+          raw_calendar_id: rawCalendarId,
         };
-
-        const response = await baasClient.calendarsApi.createCalendar({
-          createCalendarParams: calendarParams,
-        });
-
+        // @ts-ignore - SDK type definition issue
+        const response = await baasClient.calendarsApi.createCalendar(
+          createCalendarParams
+        );
         return {
           content: [
             {
               type: "text",
               text: "Successfully created calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to create calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to create calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "listCalendars",
     "List all calendar integrations. Use this when you want to: 1) View configured calendars 2) Check calendar status 3) Manage calendar integrations",
     {},
     async () => {
       try {
         const response = await baasClient.calendarsApi.listCalendars();
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to list calendars:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to list calendars",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "getCalendar",
     "Get details about a specific calendar integration. Use this when you want to: 1) View calendar configuration 2) Check calendar status 3) Verify calendar settings",
     { calendarId: z.string() },
     async ({ calendarId }: { calendarId: string }) => {
       try {
-        //
+        // @ts-ignore - SDK type definition issue
         const response = await baasClient.calendarsApi.getCalendar({
-          params: { uuid: calendarId },
+          calendarId: calendarId,
         });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "deleteCalendar",
     "Delete a calendar integration. Use this when you want to: 1) Remove a calendar connection 2) Stop automatic recordings 3) Clean up calendar data",
     { calendarId: z.string() },
     async ({ calendarId }: { calendarId: string }) => {
       try {
-        //
+        // @ts-ignore - SDK type definition issue
         const response = await baasClient.calendarsApi.deleteCalendar({
-          params: { uuid: calendarId },
+          calendar_id: calendarId,
         });
         return {
           content: [
             {
               type: "text",
               text: "Successfully deleted calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to delete calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to delete calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "resyncAllCalendars",
     "Resynchronize all calendar integrations. Use this when you want to: 1) Update calendar data 2) Fix sync issues 3) Refresh calendar connections",
     {},
     async () => {
       try {
         const response = await baasClient.calendarsApi.resyncAllCalendars();
         return {
           content: [
             {
               type: "text",
               text: "Successfully resynced all calendars",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to resync calendars:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to resync calendars",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "botsWithMetadata",
     "Get a list of all bots with their metadata. Use this when you want to: 1) View active bots 2) Check bot status 3) Monitor bot activity",
     {},
     async () => {
       try {
-        //
-        const response = await baasClient.defaultApi.botsWithMetadata();
+        const response = await baasClient.defaultApi.botsWithMetadata({
+          botName: "",
+          createdAfter: "",
+          createdBefore: "",
+          cursor: "",
+          filterByExtra: "",
+          limit: 10,
+          meetingUrl: "",
+          sortByExtra: "",
+          speakerName: "",
+        });
         return {
           content: [
             {
               type: "text",
-              text: JSON.stringify(response.data, null, 2),
+              text: `Bots with metadata: ${JSON.stringify(
+                response.data,
+                null,
+                2
+              )}`,
             },
           ],
         };
       } catch (error) {
-        console.error("Failed to get bots with metadata:", error);
+        console.error("Error listing bots:", error);
         return {
           content: [
             {
               type: "text",
-              text: "Failed to get bots with metadata",
+              text: "Failed to list bots",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "listEvents",
     "List all scheduled events. Use this when you want to: 1) View upcoming recordings 2) Check scheduled transcriptions 3) Monitor planned bot activity",
     { calendarId: z.string() },
     async ({ calendarId }) => {
       try {
-        //
+        // @ts-ignore - SDK type definition issue
         const response = await baasClient.calendarsApi.listEvents({
-          calendarId,
+          calendarId: calendarId,
         });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to list events:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to list events",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "scheduleRecordEvent",
     "Schedule a recording. Use this when you want to: 1) Set up automatic recording 2) Schedule future transcriptions 3) Plan meeting recordings",
     {
       eventUuid: z.string(),
       botName: z.string(),
       extra: z.record(z.unknown()).optional(),
-      allOccurrences: z.boolean().optional(),
     },
-    async ({ eventUuid, botName, extra, allOccurrences }) => {
+    async ({ eventUuid, botName, extra }) => {
       try {
-        const botParams = {
-          botName,
-          extra: extra || {},
-        };
-
-        //
+        // @ts-ignore - SDK type definition issue
         const response = await baasClient.calendarsApi.scheduleRecordEvent(
           {
-            botParam2: botParams,
-            allOccurrences: allOccurrences || false,
+            botParam2: {
+              botName: botName,
+              extra: extra || {},
+            },
+            allOccurrences: false,
           },
           {
-            params: { uuid: eventUuid },
+            url: `/calendarEvents/${eventUuid}/bot`,
           }
         );
-
         return {
           content: [
             {
               type: "text",
               text: "Successfully scheduled event recording",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to schedule event recording:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to schedule event recording",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "unscheduleRecordEvent",
     "Cancel a scheduled recording. Use this when you want to: 1) Cancel automatic recording 2) Stop planned transcription 3) Remove scheduled bot activity",
-    {
-      eventUuid: z.string(),
-      allOccurrences: z.boolean().optional(),
-    },
-    async ({ eventUuid, allOccurrences }) => {
+    { eventUuid: z.string() },
+    async ({ eventUuid }: { eventUuid: string }) => {
       try {
-        //
-        const response = await baasClient.calendarsApi.unscheduleRecordEvent(
-          {
-            allOccurrences: allOccurrences || false,
-          },
-          {
-            params: { uuid: eventUuid },
-          }
-        );
-
+        // @ts-ignore - SDK type definition issue
+        const response = await baasClient.calendarsApi.unscheduleRecordEvent({
+          uuid: eventUuid,
+        });
         return {
           content: [
             {
               type: "text",
               text: "Successfully unscheduled event recording",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to unschedule event recording:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to unschedule event recording",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "updateCalendar",
     "Update a calendar integration configuration. Use this when you want to: 1) Modify calendar settings 2) Update connection details 3) Change calendar configuration",
     {
       calendarId: z.string(),
       oauthClientId: z.string(),
       oauthClientSecret: z.string(),
       oauthRefreshToken: z.string(),
       platform: z.enum(["Google", "Microsoft"]),
     },
     async ({
       calendarId,
       oauthClientId,
       oauthClientSecret,
       oauthRefreshToken,
       platform,
     }) => {
       try {
-        const updateParams = {
-          oauthClientId,
-          oauthClientSecret,
-          oauthRefreshToken,
+        const updateParams: UpdateCalendarParams = {
+          oauthClientId: oauthClientId,
+          oauthClientSecret: oauthClientSecret,
+          oauthRefreshToken: oauthRefreshToken,
           platform:
             platform === "Google" ? Provider.google : Provider.microsoft,
         };
 
-        //
-        const response = await baasClient.calendarsApi.updateCalendar({
-          updateCalendarParams: updateParams,
-        });
-
+        // @ts-ignore - SDK type definition issue
+        const response = await baasClient.calendarsApi.updateCalendar(
+          calendarId,
+          updateParams
+        );
         return {
           content: [
             {
               type: "text",
               text: "Successfully updated calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to update calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to update calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // Add echo tool for testing
   const finalServer = registerEchoTool(updatedServer);
 
   return finalServer;
 }
 
 export default registerTools;
diff --git a/api/tools/bots/index.ts b/api/tools/bots/index.ts
index 43aa95f..e407c24 100644
--- a/api/tools/bots/index.ts
+++ b/api/tools/bots/index.ts
@@ -1,15 +1,15 @@
-import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client.js";
+import { BaasClient } from "@meeting-baas/sdk";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { registerJoinTool } from "./join";
 import { registerJoinSpeakingTool } from "./join-speaking";
 
 export function registerBotTools(
   server: McpServer,
   baasClient: BaasClient
 ): McpServer {
   // Register all bot-related tools
   let updatedServer = registerJoinTool(server, baasClient);
   updatedServer = registerJoinSpeakingTool(server);
 
   return updatedServer;
 }
diff --git a/api/tools/index.ts b/api/tools/index.ts
index 4f64456..8e5360d 100644
--- a/api/tools/index.ts
+++ b/api/tools/index.ts
@@ -1,20 +1,20 @@
-import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client.js";
+import { BaasClient } from "@meeting-baas/sdk";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { registerBotTools } from "./bots";
 import { registerEchoTool } from "./utils/echo";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
   });
 
   // Register bot tools
   const updatedServer = registerBotTools(server, baasClient);
 
   // Add echo tool for testing
   const finalServer = registerEchoTool(updatedServer);
 
   return finalServer;
 }
 
 export default registerTools;
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 52814e33b39357c43848eec7d932db5b53a1468b
#KEY#COMMIT_DATE# 2025-04-23 11:43:16 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# working - not speaking
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/server.ts
- api/tools.ts
- api/tools/bots/index.ts
- api/tools/bots/join.ts
- package.json
- pnpm-lock.yaml

#KEY#DIFF_RANGE# FROM: ec289bc3100bdddab784151a0d72c3b7e3b59948 TO: 52814e33b39357c43848eec7d932db5b53a1468b
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/server.ts b/api/server.ts
index 446d0cc..22a0843 100644
--- a/api/server.ts
+++ b/api/server.ts
@@ -1,68 +1,62 @@
 import { initializeMcpApiHandler } from "../lib/mcp-api-handler";
 import registerTools from "./tools";
 
 const handler = initializeMcpApiHandler(
   (server, apiKey) => {
     // Register Meeting BaaS SDK tools with the provided API key
     server = registerTools(server, apiKey);
   },
   {
     capabilities: {
       tools: {
         joinMeeting: {
           description: "Join's a meeting using the MeetingBaas api",
         },
         leaveMeeting: {
           description: "Leave a meeting using the MeetingBaas api",
         },
         getMeetingData: {
           description: "Get meeting data using the MeetingBaas api",
         },
         deleteData: {
           description: "Delete meeting data using the MeetingBaas api",
         },
         createCalendar: {
           description: "Create a calendar using the MeetingBaas api",
         },
         listCalendars: {
           description: "List calendars using the MeetingBaas api",
         },
         getCalendar: {
           description: "Get calendar using the MeetingBaas api",
         },
         deleteCalendar: {
           description: "Delete calendar using the MeetingBaas api",
         },
         resyncAllCalendars: {
           description: "Resync all calendars using the MeetingBaas api",
         },
         botsWithMetadata: {
           description: "Get bots with metadata using the MeetingBaas api",
         },
         listEvents: {
           description: "List events using the MeetingBaas api",
         },
         scheduleRecordEvent: {
           description: "Schedule a recording using the MeetingBaas api",
         },
         unscheduleRecordEvent: {
           description: "Unschedule a recording using the MeetingBaas api",
         },
         updateCalendar: {
           description: "Update calendar using the MeetingBaas api",
         },
-        joinSpeakingMeeting: {
-          description: "Join a speaking meeting using the MeetingBaas api",
-        },
-        leaveSpeakingMeeting: {
-          description: "Leave a speaking meeting using the MeetingBaas api",
-        },
         echo: {
           description: "Echo a message",
         },
       },
     },
   }
 );
 
 export default handler;
diff --git a/api/tools.ts b/api/tools.ts
index 274ce3d..d533207 100644
--- a/api/tools.ts
+++ b/api/tools.ts
@@ -1,510 +1,481 @@
-import { BaasClient } from "@meeting-baas/sdk/dist/baas/api/client";
-import { CreateCalendarParams } from "@meeting-baas/sdk/dist/baas/models/create-calendar-params";
-import { Provider } from "@meeting-baas/sdk/dist/baas/models/provider";
-import { UpdateCalendarParams } from "@meeting-baas/sdk/dist/baas/models/update-calendar-params";
+import { BaasClient } from "@meeting-baas/sdk/dist/generated/baas/api/client";
+import { CreateCalendarParams } from "@meeting-baas/sdk/dist/generated/baas/models/create-calendar-params";
+import { UpdateCalendarParams } from "@meeting-baas/sdk/dist/generated/baas/models/update-calendar-params";
+import { BotParam2 } from "@meeting-baas/sdk/dist/generated/baas/models/bot-param2";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import z from "zod";
 import { registerJoinTool } from "./tools/bots/join";
 import { registerEchoTool } from "./tools/utils/echo";
+import { Provider } from "@meeting-baas/sdk/dist/generated/baas/models/provider";
+import { JoinRequest } from "@meeting-baas/sdk/dist/generated/baas/models/join-request";
+import { JoinRequestAutomaticLeave } from "@meeting-baas/sdk/dist/generated/baas/models/join-request-automatic-leave";
+import { JoinRequestSpeechToText } from "@meeting-baas/sdk/dist/generated/baas/models/join-request-speech-to-text";
+import { SpeechToTextProvider } from "@meeting-baas/sdk/dist/generated/baas/models/speech-to-text-provider";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
   });
 
   // Register bot tools
   const updatedServer = registerJoinTool(server, baasClient);
 
   // Register Meeting BaaS SDK tools
   updatedServer.tool(
     "leaveMeeting",
     "Remove an AI bot from a meeting. Use this when you want to: 1) End a meeting recording 2) Stop transcription 3) Disconnect the bot from the meeting",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         await baasClient.defaultApi.leave({
-          headers: { "x-bot-id": botId },
+          headers: { "x-bot-id": botId }
         });
         return {
           content: [
             {
               type: "text",
-              text: `Successfully removed bot ${botId} from meeting`,
-            },
-          ],
+              text: `Successfully removed bot ${botId} from meeting`
+            }
+          ]
         };
       } catch (error) {
         console.error("Error leaving meeting:", error);
         return {
           content: [
             {
               type: "text",
-              text: "Failed to leave meeting",
-            },
+              text: "Failed to leave meeting"
+            }
           ],
-          isError: true,
+          isError: true
         };
       }
     }
   );
 
   updatedServer.tool(
     "getMeetingData",
     "Get data about a meeting that a bot has joined. Use this when you want to: 1) Check meeting status 2) Get recording information 3) Access transcription data",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         const response = await baasClient.defaultApi.getMeetingData({
-          botId,
+          botId
         });
         return {
           content: [
             {
               type: "text",
-              text: `Meeting data: ${JSON.stringify(response.data, null, 2)}`,
-            },
-          ],
+              text: `Meeting data: ${JSON.stringify(response.data, null, 2)}`
+            }
+          ]
         };
       } catch (error) {
         console.error("Error getting meeting data:", error);
         return {
           content: [
             {
               type: "text",
-              text: "Failed to get meeting data",
-            },
+              text: "Failed to get meeting data"
+            }
           ],
-          isError: true,
+          isError: true
         };
       }
     }
   );
 
   updatedServer.tool(
     "deleteData",
     "Delete data associated with a meeting bot. Use this when you want to: 1) Remove meeting recordings 2) Delete transcription data 3) Clean up bot data",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         await baasClient.defaultApi.deleteData({
-          headers: { "x-bot-id": botId },
+          headers: { "x-bot-id": botId }
         });
         return {
           content: [
             {
               type: "text",
-              text: "Successfully deleted meeting data",
-            },
-          ],
+              text: "Successfully deleted meeting data"
+            }
+          ]
         };
       } catch (error) {
         console.error("Error deleting data:", error);
         return {
           content: [
             {
               type: "text",
-              text: "Failed to delete data",
-            },
+              text: "Failed to delete data"
+            }
           ],
-          isError: true,
+          isError: true
         };
       }
     }
   );
 
   updatedServer.tool(
     "createCalendar",
     "Create a new calendar integration. Use this when you want to: 1) Set up automatic meeting recordings 2) Configure calendar-based bot scheduling 3) Enable recurring meeting coverage",
     {
       oauthClientId: z.string(),
       oauthClientSecret: z.string(),
       oauthRefreshToken: z.string(),
       platform: z.enum(["Google", "Microsoft"]),
       rawCalendarId: z.string(),
     },
-    async ({
-      oauthClientId,
-      oauthClientSecret,
-      oauthRefreshToken,
-      platform,
-      rawCalendarId,
-    }) => {
+    async ({ oauthClientId, oauthClientSecret, oauthRefreshToken, platform, rawCalendarId }) => {
       try {
         let createCalendarParams: CreateCalendarParams = {
-          oauthClientId: oauthClientId,
-          oauthClientSecret: oauthClientSecret,
-          oauthRefreshToken: oauthRefreshToken,
-          platform:
-            platform === "Google" ? Provider.google : Provider.microsoft,
-          raw_calendar_id: rawCalendarId,
+          oauth_client_id: oauthClientId,
+          oauth_client_secret: oauthClientSecret,
+          oauth_refresh_token: oauthRefreshToken,
+          platform: platform === "Google" ? Provider.google : Provider.microsoft,
+          raw_calendar_id: rawCalendarId
         };
         // @ts-ignore - SDK type definition issue
-        const response = await baasClient.calendarsApi.createCalendar(
-          createCalendarParams
-        );
+        const response = await baasClient.calendarsApi.createCalendar(createCalendarParams);
         return {
           content: [
             {
               type: "text",
               text: "Successfully created calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to create calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to create calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "listCalendars",
     "List all calendar integrations. Use this when you want to: 1) View configured calendars 2) Check calendar status 3) Manage calendar integrations",
     {},
     async () => {
       try {
         const response = await baasClient.calendarsApi.listCalendars();
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to list calendars:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to list calendars",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "getCalendar",
     "Get details about a specific calendar integration. Use this when you want to: 1) View calendar configuration 2) Check calendar status 3) Verify calendar settings",
     { calendarId: z.string() },
     async ({ calendarId }: { calendarId: string }) => {
       try {
         // @ts-ignore - SDK type definition issue
-        const response = await baasClient.calendarsApi.getCalendar({
-          calendarId: calendarId,
-        });
+        const response = await baasClient.calendarsApi.getCalendar({ calendar_id: calendarId });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "deleteCalendar",
     "Delete a calendar integration. Use this when you want to: 1) Remove a calendar connection 2) Stop automatic recordings 3) Clean up calendar data",
     { calendarId: z.string() },
     async ({ calendarId }: { calendarId: string }) => {
       try {
         // @ts-ignore - SDK type definition issue
-        const response = await baasClient.calendarsApi.deleteCalendar({
-          calendar_id: calendarId,
-        });
+        const response = await baasClient.calendarsApi.deleteCalendar({ calendar_id: calendarId });
         return {
           content: [
             {
               type: "text",
               text: "Successfully deleted calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to delete calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to delete calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "resyncAllCalendars",
     "Resynchronize all calendar integrations. Use this when you want to: 1) Update calendar data 2) Fix sync issues 3) Refresh calendar connections",
     {},
     async () => {
       try {
         const response = await baasClient.calendarsApi.resyncAllCalendars();
         return {
           content: [
             {
               type: "text",
               text: "Successfully resynced all calendars",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to resync calendars:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to resync calendars",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "botsWithMetadata",
     "Get a list of all bots with their metadata. Use this when you want to: 1) View active bots 2) Check bot status 3) Monitor bot activity",
     {},
     async () => {
       try {
         const response = await baasClient.defaultApi.botsWithMetadata({
           botName: "",
           createdAfter: "",
           createdBefore: "",
           cursor: "",
           filterByExtra: "",
           limit: 10,
           meetingUrl: "",
           sortByExtra: "",
-          speakerName: "",
+          speakerName: ""
         });
         return {
           content: [
             {
               type: "text",
-              text: `Bots with metadata: ${JSON.stringify(
-                response.data,
-                null,
-                2
-              )}`,
+              text: `Bots with metadata: ${JSON.stringify(response.data, null, 2)}`
             },
           ],
         };
       } catch (error) {
         console.error("Error listing bots:", error);
         return {
           content: [
             {
               type: "text",
-              text: "Failed to list bots",
-            },
+              text: "Failed to list bots"
+            }
           ],
-          isError: true,
+          isError: true
         };
       }
     }
   );
 
   updatedServer.tool(
     "listEvents",
     "List all scheduled events. Use this when you want to: 1) View upcoming recordings 2) Check scheduled transcriptions 3) Monitor planned bot activity",
     { calendarId: z.string() },
     async ({ calendarId }) => {
       try {
         // @ts-ignore - SDK type definition issue
-        const response = await baasClient.calendarsApi.listEvents({
-          calendarId: calendarId,
-        });
+        const response = await baasClient.calendarsApi.listEvents({ calendar_id: calendarId });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to list events:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to list events",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "scheduleRecordEvent",
     "Schedule a recording. Use this when you want to: 1) Set up automatic recording 2) Schedule future transcriptions 3) Plan meeting recordings",
     {
       eventUuid: z.string(),
       botName: z.string(),
       extra: z.record(z.unknown()).optional(),
     },
     async ({ eventUuid, botName, extra }) => {
       try {
         // @ts-ignore - SDK type definition issue
-        const response = await baasClient.calendarsApi.scheduleRecordEvent(
-          {
-            botParam2: {
-              botName: botName,
-              extra: extra || {},
-            },
-            allOccurrences: false,
+        const response = await baasClient.calendarsApi.scheduleRecordEvent({
+          botParam2: {
+            bot_name: botName,
+            extra: extra || {},
           },
-          {
-            url: `/calendarEvents/${eventUuid}/bot`,
-          }
-        );
+          allOccurrences: false,
+        }, {
+          url: `/calendarEvents/${eventUuid}/bot`
+        });
         return {
           content: [
             {
               type: "text",
               text: "Successfully scheduled event recording",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to schedule event recording:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to schedule event recording",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "unscheduleRecordEvent",
     "Cancel a scheduled recording. Use this when you want to: 1) Cancel automatic recording 2) Stop planned transcription 3) Remove scheduled bot activity",
     { eventUuid: z.string() },
     async ({ eventUuid }: { eventUuid: string }) => {
       try {
         // @ts-ignore - SDK type definition issue
-        const response = await baasClient.calendarsApi.unscheduleRecordEvent({
-          uuid: eventUuid,
-        });
+        const response = await baasClient.calendarsApi.unscheduleRecordEvent({ uuid: eventUuid });
         return {
           content: [
             {
               type: "text",
               text: "Successfully unscheduled event recording",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to unschedule event recording:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to unschedule event recording",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "updateCalendar",
     "Update a calendar integration configuration. Use this when you want to: 1) Modify calendar settings 2) Update connection details 3) Change calendar configuration",
     {
       calendarId: z.string(),
       oauthClientId: z.string(),
       oauthClientSecret: z.string(),
       oauthRefreshToken: z.string(),
       platform: z.enum(["Google", "Microsoft"]),
     },
-    async ({
-      calendarId,
-      oauthClientId,
-      oauthClientSecret,
-      oauthRefreshToken,
-      platform,
-    }) => {
+    async ({ calendarId, oauthClientId, oauthClientSecret, oauthRefreshToken, platform }) => {
       try {
         const updateParams: UpdateCalendarParams = {
-          oauthClientId: oauthClientId,
-          oauthClientSecret: oauthClientSecret,
-          oauthRefreshToken: oauthRefreshToken,
-          platform:
-            platform === "Google" ? Provider.google : Provider.microsoft,
+          oauth_client_id: oauthClientId,
+          oauth_client_secret: oauthClientSecret,
+          oauth_refresh_token: oauthRefreshToken,
+          platform: platform === "Google" ? Provider.google : Provider.microsoft,
         };
 
         // @ts-ignore - SDK type definition issue
-        const response = await baasClient.calendarsApi.updateCalendar(
-          calendarId,
-          updateParams
-        );
+        const response = await baasClient.calendarsApi.updateCalendar(calendarId, updateParams);
         return {
           content: [
             {
               type: "text",
               text: "Successfully updated calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to update calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to update calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // Add echo tool for testing
   const finalServer = registerEchoTool(updatedServer);
 
   return finalServer;
 }
 
 export default registerTools;
diff --git a/api/tools/bots/index.ts b/api/tools/bots/index.ts
index e407c24..b0a9a68 100644
--- a/api/tools/bots/index.ts
+++ b/api/tools/bots/index.ts
@@ -1,15 +1,14 @@
-import { BaasClient } from "@meeting-baas/sdk";
+import { BaasClient } from "@meeting-baas/sdk/dist/generated/baas/api/client";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { registerJoinTool } from "./join";
 import { registerJoinSpeakingTool } from "./join-speaking";
-
 export function registerBotTools(
   server: McpServer,
   baasClient: BaasClient
 ): McpServer {
   // Register all bot-related tools
   let updatedServer = registerJoinTool(server, baasClient);
   updatedServer = registerJoinSpeakingTool(server);
 
   return updatedServer;
 }
diff --git a/api/tools/bots/join.ts b/api/tools/bots/join.ts
index c39a63d..8287564 100644
--- a/api/tools/bots/join.ts
+++ b/api/tools/bots/join.ts
@@ -1,203 +1,117 @@
+import { BaasClient } from "@meeting-baas/sdk/dist/generated/baas/api/client";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
-import axios from "axios";
 import { z } from "zod";
 
 // Constants for configuration based on OpenAPI spec
-const RECORDING_MODES = ["speaker_view", "gallery_view", "audio_only"] as const;
+const RECORDING_MODES = ['speaker_view', 'gallery_view', 'audio_only'] as const;
 
-export function registerJoinTool(
-  server: McpServer,
-  baasClient: any
-): McpServer {
+// Import the enums and types from the SDK's generated types
+import { AudioFrequency, SpeechToTextProvider } from "@meeting-baas/sdk/dist/generated/baas/models";
+import { JoinRequest } from "@meeting-baas/sdk/dist/generated/baas/models/join-request";
+import { JoinRequestAutomaticLeave } from "@meeting-baas/sdk/dist/generated/baas/models/join-request-automatic-leave";
+import { JoinRequestSpeechToText } from "@meeting-baas/sdk/dist/generated/baas/models/join-request-speech-to-text";
+
+export function registerJoinTool(server: McpServer, baasClient: BaasClient): McpServer {
   server.tool(
     "joinMeeting",
     "Send an AI bot to join a video meeting. The bot can record the meeting, transcribe speech (enabled by default using Gladia), and provide real-time audio streams. Use this when you want to: 1) Record a meeting 2) Get meeting transcriptions 3) Stream meeting audio 4) Monitor meeting attendance",
     {
       meetingUrl: z.string().url().describe("URL of the meeting to join"),
-      botName: z
-        .string()
-        .describe("Name to display for the bot in the meeting"),
-      botImage: z
-        .string()
-        .url()
-        .optional()
-        .describe(
-          "The image to use for the bot, must be a URL. Recommended ratio is 4:3."
-        ),
-      entryMessage: z
-        .string()
-        .optional()
-        .describe(
-          "There are no entry messages on Microsoft Teams as guests outside of an organization do not have access to the chat."
-        ),
-      webhookUrl: z
-        .string()
-        .url()
-        .optional()
-        .describe(
-          "A webhook URL to send events to, overrides the webhook URL set in your account settings."
-        ),
-      recordingMode: z
-        .enum(RECORDING_MODES)
-        .optional()
-        .describe(
-          "The recording mode for the bot, defaults to 'speaker_view'."
-        ),
-      speechToText: z
-        .object({
-          provider: z.string().default("gladia"),
-          apiKey: z.string().optional(),
-        })
-        .default({ provider: "default" })
-        .describe("The speech to text provider, defaults to Gladia."),
-      streaming: z
-        .object({
-          input: z
-            .string()
-            .url()
-            .optional()
-            .describe("WebSocket URL for audio input"),
-          output: z
-            .string()
-            .url()
-            .optional()
-            .describe("WebSocket URL for audio output"),
-          audioFrequency: z
-            .string()
-            .optional()
-            .describe("Audio frequency for streaming"),
-        })
-        .optional()
-        .describe("Configure streaming capabilities for the bot"),
-      automaticLeave: z
-        .object({
-          nooneJoinedTimeout: z
-            .number()
-            .optional()
-            .describe("Timeout in seconds when no one joins"),
-          waitingRoomTimeout: z
-            .number()
-            .optional()
-            .describe("Timeout in seconds when in waiting room"),
-        })
-        .optional()
-        .describe("Configure automatic leave behavior"),
-      reserved: z
-        .boolean()
-        .default(false)
-        .describe(
-          "Whether or not the bot should come from the available pool of bots or be a dedicated bot. Reserved bots come in exactly 4 minutes after the request."
-        ),
-      startTime: z
-        .number()
-        .optional()
-        .describe(
-          "Unix timestamp (in milliseconds) for when the bot should join the meeting. The bot joins 4 minutes before the start time."
-        ),
-      deduplicationKey: z
-        .string()
-        .optional()
-        .describe(
-          "We prevent multiple bots with same API key joining a meeting within 5 mins, unless overridden by deduplication_key."
-        ),
-      extra: z
-        .record(z.unknown())
-        .optional()
-        .describe(
-          "A Json object that allows you to add custom data to a bot for your convenience, e.g. your end user's ID."
-        ),
+      botName: z.string().describe("Name to display for the bot in the meeting"),
+      botImage: z.string().url().optional().describe("The image to use for the bot, must be a URL. Recommended ratio is 4:3."),
+      entryMessage: z.string().optional().describe("There are no entry messages on Microsoft Teams as guests outside of an organization do not have access to the chat."),
+      webhookUrl: z.string().url().optional().describe("A webhook URL to send events to, overrides the webhook URL set in your account settings."),
+      recordingMode: z.enum(RECORDING_MODES).optional().describe("The recording mode for the bot, defaults to 'speaker_view'."),
+      speechToText: z.object({
+        provider: z.nativeEnum(SpeechToTextProvider).default(SpeechToTextProvider.gladia),
+        apiKey: z.string().optional()
+      }).default({ provider: SpeechToTextProvider.default }).describe("The speech to text provider, defaults to Gladia."),
+      streaming: z.object({
+        input: z.string().url().optional().describe("WebSocket URL for audio input"),
+        output: z.string().url().optional().describe("WebSocket URL for audio output"),
+        audioFrequency: z.nativeEnum(AudioFrequency).optional().describe("Audio frequency for streaming")
+      }).optional().describe("Configure streaming capabilities for the bot"),
+      automaticLeave: z.object({
+        nooneJoinedTimeout: z.number().optional().describe("Timeout in seconds when no one joins"),
+        waitingRoomTimeout: z.number().optional().describe("Timeout in seconds when in waiting room")
+      }).optional().describe("Configure automatic leave behavior"),
+      reserved: z.boolean().default(false).describe("Whether or not the bot should come from the available pool of bots or be a dedicated bot. Reserved bots come in exactly 4 minutes after the request."),
+      startTime: z.number().optional().describe("Unix timestamp (in milliseconds) for when the bot should join the meeting. The bot joins 4 minutes before the start time."),
+      deduplicationKey: z.string().optional().describe("We prevent multiple bots with same API key joining a meeting within 5 mins, unless overridden by deduplication_key."),
+      extra: z.record(z.unknown()).optional().describe("A Json object that allows you to add custom data to a bot for your convenience, e.g. your end user's ID.")
     },
     async (params) => {
       try {
-        // Use the baasClient, but access the underlying request config to get the API key
-        const apiKey = baasClient.configuration.apiKey;
-
-        // Create the join request
-        const joinRequest = {
+        // Create the join request using the SDK's types
+        const joinRequest: JoinRequest = {
           meeting_url: params.meetingUrl,
           bot_name: params.botName,
           bot_image: params.botImage,
           webhook_url: params.webhookUrl,
-          recording_mode: params.recordingMode || "speaker_view",
+          recording_mode: params.recordingMode || 'speaker_view',
           speech_to_text: params.speechToText && {
             provider: params.speechToText.provider,
-            api_key: params.speechToText.apiKey,
-          },
+            api_key: params.speechToText.apiKey
+          } as JoinRequestSpeechToText,
           reserved: params.reserved,
           streaming: params.streaming && {
             input: params.streaming.input,
             output: params.streaming.output,
-            audio_frequency: params.streaming.audioFrequency,
+            audio_frequency: params.streaming.audioFrequency
           },
           automatic_leave: params.automaticLeave && {
             noone_joined_timeout: params.automaticLeave.nooneJoinedTimeout,
-            waiting_room_timeout: params.automaticLeave.waitingRoomTimeout,
-          },
+            waiting_room_timeout: params.automaticLeave.waitingRoomTimeout
+          } as JoinRequestAutomaticLeave,
           start_time: params.startTime,
           deduplication_key: params.deduplicationKey,
-          extra: params.extra,
+          extra: params.extra
         };
 
-        // Make a direct API call
-        const response = await axios.post(
-          "https://api.meetingbaas.com/v1/bots/join",
-          { joinRequest },
-          {
-            headers: {
-              "X-API-Key": apiKey,
-              "Content-Type": "application/json",
-            },
-          }
-        );
+        const response = await baasClient.defaultApi.join({
+          joinRequest
+        });
 
         if (response.data.bot_id) {
           return {
-            content: [
-              {
-                type: "text",
-                text: `Successfully joined meeting with bot ID: ${
-                  response.data.bot_id
-                } (Speech-to-text enabled by default using ${
-                  params.speechToText?.provider || "default"
-                } provider)`,
-              },
-            ],
+            content: [{
+              type: "text",
+              text: `Successfully joined meeting with bot ID: ${response.data.bot_id} (Speech-to-text enabled by default using ${params.speechToText?.provider || SpeechToTextProvider.default} provider)`
+            }]
           };
         }
 
         return {
-          content: [
-            {
-              type: "text",
-              text: "No bot ID received in the response",
-            },
-          ],
-          isError: true,
+          content: [{
+            type: "text",
+            text: "No bot ID received in the response"
+          }],
+          isError: true
         };
       } catch (error) {
         console.error("Failed to join meeting:", error);
-
+        
         let errorMessage = "Failed to join meeting: ";
         if (error instanceof Error) {
           errorMessage += error.message;
-        } else if (typeof error === "string") {
+        } else if (typeof error === 'string') {
           errorMessage += error;
         } else {
           errorMessage += "Unknown error occurred";
         }
 
         return {
           content: [
             {
               type: "text",
-              text: errorMessage,
-            },
+              text: errorMessage
+            }
           ],
-          isError: true,
+          isError: true
         };
       }
     }
   );
 
   return server;
-}
+} 
\ No newline at end of file
diff --git a/package.json b/package.json
index f5443bd..b94313f 100644
--- a/package.json
+++ b/package.json
@@ -1,32 +1,32 @@
 {
   "name": "meetingbaas-mcp",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
     "build": "tsc",
     "build:watch": "tsc --watch",
     "start": "node -r dotenv/config dist/api/server.js",
     "dev": "tsc --watch & node -r dotenv/config dist/api/server.js"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
-    "@meeting-baas/sdk": "0.3.8",
+    "@meeting-baas/sdk": "0.3.6",
     "@modelcontextprotocol/sdk": "^1.6.1",
     "axios": "^1.8.4",
     "content-type": "^1.0.5",
     "dotenv": "^16.4.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
     "@types/node": "^20.17.30",
     "tsup": "^8.4.0",
     "typescript": "^5.3.3"
   }
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# f946e5c4971d7f3ad089addd30fc734d8981dc2b
#KEY#COMMIT_DATE# 2025-04-23 11:43:10 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# fix: better use SDK
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools/bots/index.ts
- api/tools/bots/join-speaking.ts
- api/tools/index.ts
- package.json
- pnpm-lock.yaml

#KEY#DIFF_RANGE# FROM: 52814e33b39357c43848eec7d932db5b53a1468b TO: f946e5c4971d7f3ad089addd30fc734d8981dc2b
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools/bots/index.ts b/api/tools/bots/index.ts
index b0a9a68..e0d4048 100644
--- a/api/tools/bots/index.ts
+++ b/api/tools/bots/index.ts
@@ -1,14 +1,10 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/generated/baas/api/client";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { registerJoinTool } from "./join";
-import { registerJoinSpeakingTool } from "./join-speaking";
-export function registerBotTools(
-  server: McpServer,
-  baasClient: BaasClient
-): McpServer {
-  // Register all bot-related tools
-  let updatedServer = registerJoinTool(server, baasClient);
-  updatedServer = registerJoinSpeakingTool(server);
 
+export function registerBotTools(server: McpServer, baasClient: BaasClient): McpServer {
+  // Register all bot-related tools
+  const updatedServer = registerJoinTool(server, baasClient);
+  
   return updatedServer;
-}
+} 
\ No newline at end of file
diff --git a/api/tools/index.ts b/api/tools/index.ts
index 8e5360d..d9f0bda 100644
--- a/api/tools/index.ts
+++ b/api/tools/index.ts
@@ -1,20 +1,20 @@
 import { BaasClient } from "@meeting-baas/sdk";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { registerBotTools } from "./bots";
 import { registerEchoTool } from "./utils/echo";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
   });
 
   // Register bot tools
   const updatedServer = registerBotTools(server, baasClient);
 
   // Add echo tool for testing
   const finalServer = registerEchoTool(updatedServer);
 
   return finalServer;
 }
 
-export default registerTools;
+export default registerTools; 
\ No newline at end of file
diff --git a/package.json b/package.json
index b94313f..33c4644 100644
--- a/package.json
+++ b/package.json
@@ -1,32 +1,31 @@
 {
   "name": "meetingbaas-mcp",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
     "build": "tsc",
     "build:watch": "tsc --watch",
     "start": "node -r dotenv/config dist/api/server.js",
     "dev": "tsc --watch & node -r dotenv/config dist/api/server.js"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
-    "@meeting-baas/sdk": "0.3.6",
+    "@meeting-baas/sdk": "^0.3.6",
     "@modelcontextprotocol/sdk": "^1.6.1",
-    "axios": "^1.8.4",
     "content-type": "^1.0.5",
     "dotenv": "^16.4.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
     "@types/node": "^20.17.30",
     "tsup": "^8.4.0",
     "typescript": "^5.3.3"
   }
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# eb72580bad26eceaa1ba3b5f24b734d57c2adfac
#KEY#COMMIT_DATE# 2025-04-23 11:43:10 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# better errors
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools.ts
- api/tools/bots/join.ts

#KEY#DIFF_RANGE# FROM: f946e5c4971d7f3ad089addd30fc734d8981dc2b TO: eb72580bad26eceaa1ba3b5f24b734d57c2adfac
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools.ts b/api/tools.ts
index d533207..79ce6b4 100644
--- a/api/tools.ts
+++ b/api/tools.ts
@@ -1,481 +1,490 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/generated/baas/api/client";
 import { CreateCalendarParams } from "@meeting-baas/sdk/dist/generated/baas/models/create-calendar-params";
 import { UpdateCalendarParams } from "@meeting-baas/sdk/dist/generated/baas/models/update-calendar-params";
 import { BotParam2 } from "@meeting-baas/sdk/dist/generated/baas/models/bot-param2";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import z from "zod";
 import { registerJoinTool } from "./tools/bots/join";
 import { registerEchoTool } from "./tools/utils/echo";
 import { Provider } from "@meeting-baas/sdk/dist/generated/baas/models/provider";
-import { JoinRequest } from "@meeting-baas/sdk/dist/generated/baas/models/join-request";
-import { JoinRequestAutomaticLeave } from "@meeting-baas/sdk/dist/generated/baas/models/join-request-automatic-leave";
-import { JoinRequestSpeechToText } from "@meeting-baas/sdk/dist/generated/baas/models/join-request-speech-to-text";
-import { SpeechToTextProvider } from "@meeting-baas/sdk/dist/generated/baas/models/speech-to-text-provider";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
   });
 
   // Register bot tools
   const updatedServer = registerJoinTool(server, baasClient);
 
   // Register Meeting BaaS SDK tools
   updatedServer.tool(
     "leaveMeeting",
     "Remove an AI bot from a meeting. Use this when you want to: 1) End a meeting recording 2) Stop transcription 3) Disconnect the bot from the meeting",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
-        await baasClient.defaultApi.leave({
-          headers: { "x-bot-id": botId }
-        });
+        console.log(`Attempting to remove bot ${botId} from meeting...`);
+        // @ts-ignore - SDK type definition issue
+        const response = await baasClient.defaultApi.leave({ bot_id: botId });
+        console.log('Leave meeting response:', JSON.stringify(response.data, null, 2));
+        
+        if (!response.data) {
+          console.error('Leave meeting response missing data');
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Failed to leave meeting: No response data received"
+              }
+            ],
+            isError: true
+          };
+        }
+
         return {
           content: [
             {
               type: "text",
               text: `Successfully removed bot ${botId} from meeting`
             }
           ]
         };
       } catch (error) {
-        console.error("Error leaving meeting:", error);
+        console.error("Failed to leave meeting:", error);
+        let errorMessage = "Failed to leave meeting";
+        
+        if (error instanceof Error) {
+          console.error('Error details:', {
+            name: error.name,
+            message: error.message,
+            stack: error.stack
+          });
+          errorMessage += `: ${error.message}`;
+        } else if (typeof error === 'object' && error !== null) {
+          console.error('Error object:', JSON.stringify(error, null, 2));
+        }
+        
         return {
           content: [
             {
               type: "text",
-              text: "Failed to leave meeting"
+              text: errorMessage
             }
           ],
           isError: true
         };
       }
     }
   );
 
   updatedServer.tool(
     "getMeetingData",
     "Get data about a meeting that a bot has joined. Use this when you want to: 1) Check meeting status 2) Get recording information 3) Access transcription data",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
-        const response = await baasClient.defaultApi.getMeetingData({
-          botId
-        });
+        // @ts-ignore - SDK type definition issue
+        const response = await baasClient.defaultApi.getMeetingData({ bot_id: botId });
         return {
           content: [
             {
               type: "text",
-              text: `Meeting data: ${JSON.stringify(response.data, null, 2)}`
-            }
-          ]
+              text: JSON.stringify(response.data, null, 2),
+            },
+          ],
         };
       } catch (error) {
-        console.error("Error getting meeting data:", error);
+        console.error("Failed to get meeting data:", error);
         return {
           content: [
             {
               type: "text",
-              text: "Failed to get meeting data"
-            }
+              text: "Failed to get meeting data",
+            },
           ],
-          isError: true
+          isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "deleteData",
     "Delete data associated with a meeting bot. Use this when you want to: 1) Remove meeting recordings 2) Delete transcription data 3) Clean up bot data",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
-        await baasClient.defaultApi.deleteData({
-          headers: { "x-bot-id": botId }
-        });
+        // @ts-ignore - SDK type definition issue
+        const response = await baasClient.defaultApi.deleteData({ bot_id: botId });
         return {
           content: [
             {
               type: "text",
-              text: "Successfully deleted meeting data"
-            }
-          ]
+              text: "Successfully deleted meeting data",
+            },
+          ],
         };
       } catch (error) {
-        console.error("Error deleting data:", error);
+        console.error("Failed to delete meeting data:", error);
         return {
           content: [
             {
               type: "text",
-              text: "Failed to delete data"
-            }
+              text: "Failed to delete meeting data",
+            },
           ],
-          isError: true
+          isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "createCalendar",
     "Create a new calendar integration. Use this when you want to: 1) Set up automatic meeting recordings 2) Configure calendar-based bot scheduling 3) Enable recurring meeting coverage",
     {
       oauthClientId: z.string(),
       oauthClientSecret: z.string(),
       oauthRefreshToken: z.string(),
       platform: z.enum(["Google", "Microsoft"]),
       rawCalendarId: z.string(),
     },
     async ({ oauthClientId, oauthClientSecret, oauthRefreshToken, platform, rawCalendarId }) => {
       try {
-        let createCalendarParams: CreateCalendarParams = {
-          oauth_client_id: oauthClientId,
-          oauth_client_secret: oauthClientSecret,
-          oauth_refresh_token: oauthRefreshToken,
-          platform: platform === "Google" ? Provider.google : Provider.microsoft,
-          raw_calendar_id: rawCalendarId
-        };
+      let createCalendarParams: CreateCalendarParams = {
+        oauth_client_id: oauthClientId,
+        oauth_client_secret: oauthClientSecret,
+        oauth_refresh_token: oauthRefreshToken,
+        platform: platform === "Google" ? Provider.google : Provider.microsoft
+      };
         // @ts-ignore - SDK type definition issue
         const response = await baasClient.calendarsApi.createCalendar(createCalendarParams);
         return {
           content: [
             {
               type: "text",
               text: "Successfully created calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to create calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to create calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "listCalendars",
     "List all calendar integrations. Use this when you want to: 1) View configured calendars 2) Check calendar status 3) Manage calendar integrations",
     {},
     async () => {
       try {
         const response = await baasClient.calendarsApi.listCalendars();
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to list calendars:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to list calendars",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "getCalendar",
     "Get details about a specific calendar integration. Use this when you want to: 1) View calendar configuration 2) Check calendar status 3) Verify calendar settings",
     { calendarId: z.string() },
     async ({ calendarId }: { calendarId: string }) => {
       try {
         // @ts-ignore - SDK type definition issue
         const response = await baasClient.calendarsApi.getCalendar({ calendar_id: calendarId });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "deleteCalendar",
     "Delete a calendar integration. Use this when you want to: 1) Remove a calendar connection 2) Stop automatic recordings 3) Clean up calendar data",
     { calendarId: z.string() },
     async ({ calendarId }: { calendarId: string }) => {
       try {
         // @ts-ignore - SDK type definition issue
         const response = await baasClient.calendarsApi.deleteCalendar({ calendar_id: calendarId });
         return {
           content: [
             {
               type: "text",
               text: "Successfully deleted calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to delete calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to delete calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "resyncAllCalendars",
     "Resynchronize all calendar integrations. Use this when you want to: 1) Update calendar data 2) Fix sync issues 3) Refresh calendar connections",
     {},
     async () => {
       try {
         const response = await baasClient.calendarsApi.resyncAllCalendars();
         return {
           content: [
             {
               type: "text",
               text: "Successfully resynced all calendars",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to resync calendars:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to resync calendars",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "botsWithMetadata",
     "Get a list of all bots with their metadata. Use this when you want to: 1) View active bots 2) Check bot status 3) Monitor bot activity",
     {},
     async () => {
       try {
-        const response = await baasClient.defaultApi.botsWithMetadata({
-          botName: "",
-          createdAfter: "",
-          createdBefore: "",
-          cursor: "",
-          filterByExtra: "",
-          limit: 10,
-          meetingUrl: "",
-          sortByExtra: "",
-          speakerName: ""
-        });
+        // @ts-ignore - SDK type definition issue
+        const response = await baasClient.defaultApi.listRecentBots();
         return {
           content: [
             {
               type: "text",
-              text: `Bots with metadata: ${JSON.stringify(response.data, null, 2)}`
+              text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
-        console.error("Error listing bots:", error);
+        console.error("Failed to get bots with metadata:", error);
         return {
           content: [
             {
               type: "text",
-              text: "Failed to list bots"
-            }
+              text: "Failed to get bots with metadata",
+            },
           ],
-          isError: true
+          isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "listEvents",
     "List all scheduled events. Use this when you want to: 1) View upcoming recordings 2) Check scheduled transcriptions 3) Monitor planned bot activity",
     { calendarId: z.string() },
     async ({ calendarId }) => {
       try {
         // @ts-ignore - SDK type definition issue
         const response = await baasClient.calendarsApi.listEvents({ calendar_id: calendarId });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to list events:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to list events",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "scheduleRecordEvent",
     "Schedule a recording. Use this when you want to: 1) Set up automatic recording 2) Schedule future transcriptions 3) Plan meeting recordings",
     {
       eventUuid: z.string(),
       botName: z.string(),
       extra: z.record(z.unknown()).optional(),
     },
     async ({ eventUuid, botName, extra }) => {
       try {
         // @ts-ignore - SDK type definition issue
         const response = await baasClient.calendarsApi.scheduleRecordEvent({
           botParam2: {
             bot_name: botName,
             extra: extra || {},
           },
           allOccurrences: false,
-        }, {
-          url: `/calendarEvents/${eventUuid}/bot`
         });
         return {
           content: [
             {
               type: "text",
               text: "Successfully scheduled event recording",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to schedule event recording:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to schedule event recording",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "unscheduleRecordEvent",
     "Cancel a scheduled recording. Use this when you want to: 1) Cancel automatic recording 2) Stop planned transcription 3) Remove scheduled bot activity",
     { eventUuid: z.string() },
     async ({ eventUuid }: { eventUuid: string }) => {
       try {
         // @ts-ignore - SDK type definition issue
         const response = await baasClient.calendarsApi.unscheduleRecordEvent({ uuid: eventUuid });
         return {
           content: [
             {
               type: "text",
               text: "Successfully unscheduled event recording",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to unschedule event recording:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to unschedule event recording",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "updateCalendar",
     "Update a calendar integration configuration. Use this when you want to: 1) Modify calendar settings 2) Update connection details 3) Change calendar configuration",
     {
       calendarId: z.string(),
-      oauthClientId: z.string(),
-      oauthClientSecret: z.string(),
-      oauthRefreshToken: z.string(),
-      platform: z.enum(["Google", "Microsoft"]),
+      name: z.string(),
+      type: z.string(),
+      config: z.record(z.unknown()),
     },
-    async ({ calendarId, oauthClientId, oauthClientSecret, oauthRefreshToken, platform }) => {
-      try {
-        const updateParams: UpdateCalendarParams = {
-          oauth_client_id: oauthClientId,
-          oauth_client_secret: oauthClientSecret,
-          oauth_refresh_token: oauthRefreshToken,
-          platform: platform === "Google" ? Provider.google : Provider.microsoft,
-        };
+    async ({ calendarId, name, type, config }) => {
+      let updateCalendarParams: UpdateCalendarParams = {
+        oauth_client_id: calendarId,
+        oauth_client_secret: name,
+        oauth_refresh_token: type,
+        platform: type === "Google" ? Provider.google : Provider.microsoft
+      };
 
+      try {
         // @ts-ignore - SDK type definition issue
-        const response = await baasClient.calendarsApi.updateCalendar(calendarId, updateParams);
+        const response = await baasClient.calendarsApi.updateCalendar(updateCalendarParams);
         return {
           content: [
             {
               type: "text",
               text: "Successfully updated calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to update calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to update calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // Add echo tool for testing
   const finalServer = registerEchoTool(updatedServer);
 
   return finalServer;
 }
 
 export default registerTools;
diff --git a/api/tools/bots/join.ts b/api/tools/bots/join.ts
index 8287564..812093b 100644
--- a/api/tools/bots/join.ts
+++ b/api/tools/bots/join.ts
@@ -1,117 +1,114 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/generated/baas/api/client";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { z } from "zod";
 
 // Constants for configuration based on OpenAPI spec
 const RECORDING_MODES = ['speaker_view', 'gallery_view', 'audio_only'] as const;
 
-// Import the enums and types from the SDK's generated types
+// Import the enums from the SDK's generated types
 import { AudioFrequency, SpeechToTextProvider } from "@meeting-baas/sdk/dist/generated/baas/models";
-import { JoinRequest } from "@meeting-baas/sdk/dist/generated/baas/models/join-request";
-import { JoinRequestAutomaticLeave } from "@meeting-baas/sdk/dist/generated/baas/models/join-request-automatic-leave";
-import { JoinRequestSpeechToText } from "@meeting-baas/sdk/dist/generated/baas/models/join-request-speech-to-text";
 
 export function registerJoinTool(server: McpServer, baasClient: BaasClient): McpServer {
   server.tool(
     "joinMeeting",
     "Send an AI bot to join a video meeting. The bot can record the meeting, transcribe speech (enabled by default using Gladia), and provide real-time audio streams. Use this when you want to: 1) Record a meeting 2) Get meeting transcriptions 3) Stream meeting audio 4) Monitor meeting attendance",
     {
       meetingUrl: z.string().url().describe("URL of the meeting to join"),
       botName: z.string().describe("Name to display for the bot in the meeting"),
       botImage: z.string().url().optional().describe("The image to use for the bot, must be a URL. Recommended ratio is 4:3."),
       entryMessage: z.string().optional().describe("There are no entry messages on Microsoft Teams as guests outside of an organization do not have access to the chat."),
       webhookUrl: z.string().url().optional().describe("A webhook URL to send events to, overrides the webhook URL set in your account settings."),
       recordingMode: z.enum(RECORDING_MODES).optional().describe("The recording mode for the bot, defaults to 'speaker_view'."),
       speechToText: z.object({
         provider: z.nativeEnum(SpeechToTextProvider).default(SpeechToTextProvider.gladia),
         apiKey: z.string().optional()
       }).default({ provider: SpeechToTextProvider.default }).describe("The speech to text provider, defaults to Gladia."),
       streaming: z.object({
         input: z.string().url().optional().describe("WebSocket URL for audio input"),
         output: z.string().url().optional().describe("WebSocket URL for audio output"),
         audioFrequency: z.nativeEnum(AudioFrequency).optional().describe("Audio frequency for streaming")
       }).optional().describe("Configure streaming capabilities for the bot"),
       automaticLeave: z.object({
         nooneJoinedTimeout: z.number().optional().describe("Timeout in seconds when no one joins"),
         waitingRoomTimeout: z.number().optional().describe("Timeout in seconds when in waiting room")
       }).optional().describe("Configure automatic leave behavior"),
       reserved: z.boolean().default(false).describe("Whether or not the bot should come from the available pool of bots or be a dedicated bot. Reserved bots come in exactly 4 minutes after the request."),
       startTime: z.number().optional().describe("Unix timestamp (in milliseconds) for when the bot should join the meeting. The bot joins 4 minutes before the start time."),
       deduplicationKey: z.string().optional().describe("We prevent multiple bots with same API key joining a meeting within 5 mins, unless overridden by deduplication_key."),
       extra: z.record(z.unknown()).optional().describe("A Json object that allows you to add custom data to a bot for your convenience, e.g. your end user's ID.")
     },
     async (params) => {
       try {
-        // Create the join request using the SDK's types
-        const joinRequest: JoinRequest = {
-          meeting_url: params.meetingUrl,
-          bot_name: params.botName,
-          bot_image: params.botImage,
-          webhook_url: params.webhookUrl,
-          recording_mode: params.recordingMode || 'speaker_view',
-          speech_to_text: params.speechToText && {
-            provider: params.speechToText.provider,
-            api_key: params.speechToText.apiKey
-          } as JoinRequestSpeechToText,
-          reserved: params.reserved,
-          streaming: params.streaming && {
-            input: params.streaming.input,
-            output: params.streaming.output,
-            audio_frequency: params.streaming.audioFrequency
-          },
-          automatic_leave: params.automaticLeave && {
-            noone_joined_timeout: params.automaticLeave.nooneJoinedTimeout,
-            waiting_room_timeout: params.automaticLeave.waitingRoomTimeout
-          } as JoinRequestAutomaticLeave,
-          start_time: params.startTime,
-          deduplication_key: params.deduplicationKey,
-          extra: params.extra
+        // Join the meeting using the BaaS SDK
+        const joinRequest = {
+          joinRequest: {
+            meeting_url: params.meetingUrl,
+            bot_name: params.botName,
+            bot_image: params.botImage,
+            webhook_url: params.webhookUrl,
+            recording_mode: params.recordingMode || 'speaker_view',
+            speech_to_text: {
+              provider: params.speechToText?.provider || SpeechToTextProvider.gladia,
+              api_key: params.speechToText?.apiKey
+            },
+            reserved: params.reserved,
+            streaming: params.streaming && {
+              input: params.streaming.input,
+              output: params.streaming.output,
+              audio_frequency: params.streaming.audioFrequency
+            },
+            automatic_leave: params.automaticLeave && {
+              noone_joined_timeout: params.automaticLeave.nooneJoinedTimeout,
+              waiting_room_timeout: params.automaticLeave.waitingRoomTimeout
+            },
+            start_time: params.startTime,
+            deduplication_key: params.deduplicationKey,
+            extra: params.extra
+          }
         };
 
-        const response = await baasClient.defaultApi.join({
-          joinRequest
-        });
+        const response = await baasClient.defaultApi.join(joinRequest);
 
         if (response.data.bot_id) {
           return {
             content: [{
               type: "text",
               text: `Successfully joined meeting with bot ID: ${response.data.bot_id} (Speech-to-text enabled by default using ${params.speechToText?.provider || SpeechToTextProvider.default} provider)`
             }]
           };
         }
 
         return {
           content: [{
             type: "text",
             text: "No bot ID received in the response"
           }],
           isError: true
         };
       } catch (error) {
         console.error("Failed to join meeting:", error);
         
         let errorMessage = "Failed to join meeting: ";
         if (error instanceof Error) {
           errorMessage += error.message;
         } else if (typeof error === 'string') {
           errorMessage += error;
         } else {
           errorMessage += "Unknown error occurred";
         }
 
         return {
           content: [
             {
               type: "text",
               text: errorMessage
             }
           ],
           isError: true
         };
       }
     }
   );
 
   return server;
 } 
\ No newline at end of file
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 74c2981e73199b316d4a1ea756fd04069c6fc758
#KEY#COMMIT_DATE# 2025-04-23 11:43:10 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# Feat: make transcription on by default
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools.ts
- api/tools/bots/join.ts

#KEY#DIFF_RANGE# FROM: eb72580bad26eceaa1ba3b5f24b734d57c2adfac TO: 74c2981e73199b316d4a1ea756fd04069c6fc758
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools.ts b/api/tools.ts
index 79ce6b4..2526328 100644
--- a/api/tools.ts
+++ b/api/tools.ts
@@ -1,174 +1,145 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/generated/baas/api/client";
 import { CreateCalendarParams } from "@meeting-baas/sdk/dist/generated/baas/models/create-calendar-params";
 import { UpdateCalendarParams } from "@meeting-baas/sdk/dist/generated/baas/models/update-calendar-params";
 import { BotParam2 } from "@meeting-baas/sdk/dist/generated/baas/models/bot-param2";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import z from "zod";
 import { registerJoinTool } from "./tools/bots/join";
 import { registerEchoTool } from "./tools/utils/echo";
 import { Provider } from "@meeting-baas/sdk/dist/generated/baas/models/provider";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
   });
 
   // Register bot tools
   const updatedServer = registerJoinTool(server, baasClient);
 
   // Register Meeting BaaS SDK tools
   updatedServer.tool(
     "leaveMeeting",
     "Remove an AI bot from a meeting. Use this when you want to: 1) End a meeting recording 2) Stop transcription 3) Disconnect the bot from the meeting",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
-        console.log(`Attempting to remove bot ${botId} from meeting...`);
         // @ts-ignore - SDK type definition issue
         const response = await baasClient.defaultApi.leave({ bot_id: botId });
-        console.log('Leave meeting response:', JSON.stringify(response.data, null, 2));
-        
-        if (!response.data) {
-          console.error('Leave meeting response missing data');
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Failed to leave meeting: No response data received"
-              }
-            ],
-            isError: true
-          };
-        }
-
         return {
           content: [
             {
               type: "text",
-              text: `Successfully removed bot ${botId} from meeting`
-            }
-          ]
+              text: "Successfully left meeting",
+            },
+          ],
         };
       } catch (error) {
         console.error("Failed to leave meeting:", error);
-        let errorMessage = "Failed to leave meeting";
-        
-        if (error instanceof Error) {
-          console.error('Error details:', {
-            name: error.name,
-            message: error.message,
-            stack: error.stack
-          });
-          errorMessage += `: ${error.message}`;
-        } else if (typeof error === 'object' && error !== null) {
-          console.error('Error object:', JSON.stringify(error, null, 2));
-        }
-        
         return {
           content: [
             {
               type: "text",
-              text: errorMessage
-            }
+              text: "Failed to leave meeting",
+            },
           ],
-          isError: true
+          isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "getMeetingData",
     "Get data about a meeting that a bot has joined. Use this when you want to: 1) Check meeting status 2) Get recording information 3) Access transcription data",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         // @ts-ignore - SDK type definition issue
         const response = await baasClient.defaultApi.getMeetingData({ bot_id: botId });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(response.data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get meeting data:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get meeting data",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "deleteData",
     "Delete data associated with a meeting bot. Use this when you want to: 1) Remove meeting recordings 2) Delete transcription data 3) Clean up bot data",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         // @ts-ignore - SDK type definition issue
         const response = await baasClient.defaultApi.deleteData({ bot_id: botId });
         return {
           content: [
             {
               type: "text",
               text: "Successfully deleted meeting data",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to delete meeting data:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to delete meeting data",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "createCalendar",
     "Create a new calendar integration. Use this when you want to: 1) Set up automatic meeting recordings 2) Configure calendar-based bot scheduling 3) Enable recurring meeting coverage",
     {
       oauthClientId: z.string(),
       oauthClientSecret: z.string(),
       oauthRefreshToken: z.string(),
       platform: z.enum(["Google", "Microsoft"]),
       rawCalendarId: z.string(),
     },
     async ({ oauthClientId, oauthClientSecret, oauthRefreshToken, platform, rawCalendarId }) => {
       try {
       let createCalendarParams: CreateCalendarParams = {
         oauth_client_id: oauthClientId,
         oauth_client_secret: oauthClientSecret,
         oauth_refresh_token: oauthRefreshToken,
         platform: platform === "Google" ? Provider.google : Provider.microsoft
       };
         // @ts-ignore - SDK type definition issue
         const response = await baasClient.calendarsApi.createCalendar(createCalendarParams);
         return {
           content: [
             {
               type: "text",
               text: "Successfully created calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to create calendar:", error);
         return {
           content: [
             {
diff --git a/api/tools/bots/join.ts b/api/tools/bots/join.ts
index 812093b..cec4a5a 100644
--- a/api/tools/bots/join.ts
+++ b/api/tools/bots/join.ts
@@ -1,114 +1,114 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/generated/baas/api/client";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { z } from "zod";
 
 // Constants for configuration based on OpenAPI spec
 const RECORDING_MODES = ['speaker_view', 'gallery_view', 'audio_only'] as const;
 
 // Import the enums from the SDK's generated types
 import { AudioFrequency, SpeechToTextProvider } from "@meeting-baas/sdk/dist/generated/baas/models";
 
 export function registerJoinTool(server: McpServer, baasClient: BaasClient): McpServer {
   server.tool(
     "joinMeeting",
-    "Send an AI bot to join a video meeting. The bot can record the meeting, transcribe speech (enabled by default using Gladia), and provide real-time audio streams. Use this when you want to: 1) Record a meeting 2) Get meeting transcriptions 3) Stream meeting audio 4) Monitor meeting attendance",
+    "Send an AI bot to join a video meeting. The bot can record the meeting, transcribe speech, and provide real-time audio streams. Use this when you want to: 1) Record a meeting 2) Get meeting transcriptions 3) Stream meeting audio 4) Monitor meeting attendance",
     {
       meetingUrl: z.string().url().describe("URL of the meeting to join"),
       botName: z.string().describe("Name to display for the bot in the meeting"),
       botImage: z.string().url().optional().describe("The image to use for the bot, must be a URL. Recommended ratio is 4:3."),
       entryMessage: z.string().optional().describe("There are no entry messages on Microsoft Teams as guests outside of an organization do not have access to the chat."),
       webhookUrl: z.string().url().optional().describe("A webhook URL to send events to, overrides the webhook URL set in your account settings."),
       recordingMode: z.enum(RECORDING_MODES).optional().describe("The recording mode for the bot, defaults to 'speaker_view'."),
       speechToText: z.object({
         provider: z.nativeEnum(SpeechToTextProvider).default(SpeechToTextProvider.gladia),
         apiKey: z.string().optional()
       }).default({ provider: SpeechToTextProvider.default }).describe("The speech to text provider, defaults to Gladia."),
       streaming: z.object({
         input: z.string().url().optional().describe("WebSocket URL for audio input"),
         output: z.string().url().optional().describe("WebSocket URL for audio output"),
         audioFrequency: z.nativeEnum(AudioFrequency).optional().describe("Audio frequency for streaming")
       }).optional().describe("Configure streaming capabilities for the bot"),
       automaticLeave: z.object({
         nooneJoinedTimeout: z.number().optional().describe("Timeout in seconds when no one joins"),
         waitingRoomTimeout: z.number().optional().describe("Timeout in seconds when in waiting room")
       }).optional().describe("Configure automatic leave behavior"),
       reserved: z.boolean().default(false).describe("Whether or not the bot should come from the available pool of bots or be a dedicated bot. Reserved bots come in exactly 4 minutes after the request."),
       startTime: z.number().optional().describe("Unix timestamp (in milliseconds) for when the bot should join the meeting. The bot joins 4 minutes before the start time."),
       deduplicationKey: z.string().optional().describe("We prevent multiple bots with same API key joining a meeting within 5 mins, unless overridden by deduplication_key."),
       extra: z.record(z.unknown()).optional().describe("A Json object that allows you to add custom data to a bot for your convenience, e.g. your end user's ID.")
     },
     async (params) => {
       try {
         // Join the meeting using the BaaS SDK
         const joinRequest = {
           joinRequest: {
             meeting_url: params.meetingUrl,
             bot_name: params.botName,
             bot_image: params.botImage,
             webhook_url: params.webhookUrl,
             recording_mode: params.recordingMode || 'speaker_view',
             speech_to_text: {
               provider: params.speechToText?.provider || SpeechToTextProvider.gladia,
               api_key: params.speechToText?.apiKey
             },
             reserved: params.reserved,
             streaming: params.streaming && {
               input: params.streaming.input,
               output: params.streaming.output,
               audio_frequency: params.streaming.audioFrequency
             },
             automatic_leave: params.automaticLeave && {
               noone_joined_timeout: params.automaticLeave.nooneJoinedTimeout,
               waiting_room_timeout: params.automaticLeave.waitingRoomTimeout
             },
             start_time: params.startTime,
             deduplication_key: params.deduplicationKey,
             extra: params.extra
           }
         };
 
         const response = await baasClient.defaultApi.join(joinRequest);
 
         if (response.data.bot_id) {
           return {
             content: [{
               type: "text",
-              text: `Successfully joined meeting with bot ID: ${response.data.bot_id} (Speech-to-text enabled by default using ${params.speechToText?.provider || SpeechToTextProvider.default} provider)`
+              text: `Successfully joined meeting with bot ID: ${response.data.bot_id}${params.speechToText ? ` (Speech-to-text provider: ${params.speechToText.provider})` : ''}`
             }]
           };
         }
 
         return {
           content: [{
             type: "text",
             text: "No bot ID received in the response"
           }],
           isError: true
         };
       } catch (error) {
         console.error("Failed to join meeting:", error);
         
         let errorMessage = "Failed to join meeting: ";
         if (error instanceof Error) {
           errorMessage += error.message;
         } else if (typeof error === 'string') {
           errorMessage += error;
         } else {
           errorMessage += "Unknown error occurred";
         }
 
         return {
           content: [
             {
               type: "text",
               text: errorMessage
             }
           ],
           isError: true
         };
       }
     }
   );
 
   return server;
 } 
\ No newline at end of file
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 9b480aee7667c33ea10e12b49cfadfe5e46727df
#KEY#COMMIT_DATE# 2025-04-23 11:43:09 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# feat: bump SDK version, update tools
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools/bots/join.ts

#KEY#DIFF_RANGE# FROM: 74c2981e73199b316d4a1ea756fd04069c6fc758 TO: 9b480aee7667c33ea10e12b49cfadfe5e46727df
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools/bots/join.ts b/api/tools/bots/join.ts
index cec4a5a..18523d0 100644
--- a/api/tools/bots/join.ts
+++ b/api/tools/bots/join.ts
@@ -1,114 +1,114 @@
 import { BaasClient } from "@meeting-baas/sdk/dist/generated/baas/api/client";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { z } from "zod";
 
 // Constants for configuration based on OpenAPI spec
 const RECORDING_MODES = ['speaker_view', 'gallery_view', 'audio_only'] as const;
 
 // Import the enums from the SDK's generated types
 import { AudioFrequency, SpeechToTextProvider } from "@meeting-baas/sdk/dist/generated/baas/models";
 
 export function registerJoinTool(server: McpServer, baasClient: BaasClient): McpServer {
   server.tool(
     "joinMeeting",
     "Send an AI bot to join a video meeting. The bot can record the meeting, transcribe speech, and provide real-time audio streams. Use this when you want to: 1) Record a meeting 2) Get meeting transcriptions 3) Stream meeting audio 4) Monitor meeting attendance",
     {
       meetingUrl: z.string().url().describe("URL of the meeting to join"),
       botName: z.string().describe("Name to display for the bot in the meeting"),
       botImage: z.string().url().optional().describe("The image to use for the bot, must be a URL. Recommended ratio is 4:3."),
       entryMessage: z.string().optional().describe("There are no entry messages on Microsoft Teams as guests outside of an organization do not have access to the chat."),
       webhookUrl: z.string().url().optional().describe("A webhook URL to send events to, overrides the webhook URL set in your account settings."),
       recordingMode: z.enum(RECORDING_MODES).optional().describe("The recording mode for the bot, defaults to 'speaker_view'."),
       speechToText: z.object({
-        provider: z.nativeEnum(SpeechToTextProvider).default(SpeechToTextProvider.gladia),
+        provider: z.nativeEnum(SpeechToTextProvider),
         apiKey: z.string().optional()
-      }).default({ provider: SpeechToTextProvider.default }).describe("The speech to text provider, defaults to Gladia."),
+      }).optional().describe("The default speech to text provider is Gladia."),
       streaming: z.object({
         input: z.string().url().optional().describe("WebSocket URL for audio input"),
         output: z.string().url().optional().describe("WebSocket URL for audio output"),
         audioFrequency: z.nativeEnum(AudioFrequency).optional().describe("Audio frequency for streaming")
       }).optional().describe("Configure streaming capabilities for the bot"),
       automaticLeave: z.object({
         nooneJoinedTimeout: z.number().optional().describe("Timeout in seconds when no one joins"),
         waitingRoomTimeout: z.number().optional().describe("Timeout in seconds when in waiting room")
       }).optional().describe("Configure automatic leave behavior"),
       reserved: z.boolean().default(false).describe("Whether or not the bot should come from the available pool of bots or be a dedicated bot. Reserved bots come in exactly 4 minutes after the request."),
       startTime: z.number().optional().describe("Unix timestamp (in milliseconds) for when the bot should join the meeting. The bot joins 4 minutes before the start time."),
       deduplicationKey: z.string().optional().describe("We prevent multiple bots with same API key joining a meeting within 5 mins, unless overridden by deduplication_key."),
       extra: z.record(z.unknown()).optional().describe("A Json object that allows you to add custom data to a bot for your convenience, e.g. your end user's ID.")
     },
     async (params) => {
       try {
         // Join the meeting using the BaaS SDK
         const joinRequest = {
           joinRequest: {
             meeting_url: params.meetingUrl,
             bot_name: params.botName,
             bot_image: params.botImage,
             webhook_url: params.webhookUrl,
             recording_mode: params.recordingMode || 'speaker_view',
-            speech_to_text: {
-              provider: params.speechToText?.provider || SpeechToTextProvider.gladia,
-              api_key: params.speechToText?.apiKey
+            speech_to_text: params.speechToText && {
+              provider: params.speechToText.provider,
+              api_key: params.speechToText.apiKey
             },
             reserved: params.reserved,
             streaming: params.streaming && {
               input: params.streaming.input,
               output: params.streaming.output,
               audio_frequency: params.streaming.audioFrequency
             },
             automatic_leave: params.automaticLeave && {
               noone_joined_timeout: params.automaticLeave.nooneJoinedTimeout,
               waiting_room_timeout: params.automaticLeave.waitingRoomTimeout
             },
             start_time: params.startTime,
             deduplication_key: params.deduplicationKey,
             extra: params.extra
           }
         };
 
         const response = await baasClient.defaultApi.join(joinRequest);
 
         if (response.data.bot_id) {
           return {
             content: [{
               type: "text",
               text: `Successfully joined meeting with bot ID: ${response.data.bot_id}${params.speechToText ? ` (Speech-to-text provider: ${params.speechToText.provider})` : ''}`
             }]
           };
         }
 
         return {
           content: [{
             type: "text",
             text: "No bot ID received in the response"
           }],
           isError: true
         };
       } catch (error) {
         console.error("Failed to join meeting:", error);
         
         let errorMessage = "Failed to join meeting: ";
         if (error instanceof Error) {
           errorMessage += error.message;
         } else if (typeof error === 'string') {
           errorMessage += error;
         } else {
           errorMessage += "Unknown error occurred";
         }
 
         return {
           content: [
             {
               type: "text",
               text: errorMessage
             }
           ],
           isError: true
         };
       }
     }
   );
 
   return server;
 } 
\ No newline at end of file
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# c012ef7222bde8face7407e41f00b74e3b3ceee6
#KEY#COMMIT_DATE# 2025-04-23 11:42:13 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# fix
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools.ts
- api/tools/bots/index.ts
- api/tools/bots/join.ts
- api/tools/bots/missing-methods.md
- package.json

#KEY#DIFF_RANGE# FROM: 9b480aee7667c33ea10e12b49cfadfe5e46727df TO: c012ef7222bde8face7407e41f00b74e3b3ceee6
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools.ts b/api/tools.ts
index 2526328..aac15af 100644
--- a/api/tools.ts
+++ b/api/tools.ts
@@ -1,461 +1,536 @@
-import { BaasClient } from "@meeting-baas/sdk/dist/generated/baas/api/client";
-import { CreateCalendarParams } from "@meeting-baas/sdk/dist/generated/baas/models/create-calendar-params";
-import { UpdateCalendarParams } from "@meeting-baas/sdk/dist/generated/baas/models/update-calendar-params";
-import { BotParam2 } from "@meeting-baas/sdk/dist/generated/baas/models/bot-param2";
+import { BaasClient } from "@meeting-baas/sdk";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import z from "zod";
 import { registerJoinTool } from "./tools/bots/join";
-import { registerEchoTool } from "./tools/utils/echo";
-import { Provider } from "@meeting-baas/sdk/dist/generated/baas/models/provider";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
   });
 
   // Register bot tools
   const updatedServer = registerJoinTool(server, baasClient);
 
   // Register Meeting BaaS SDK tools
   updatedServer.tool(
     "leaveMeeting",
     "Remove an AI bot from a meeting. Use this when you want to: 1) End a meeting recording 2) Stop transcription 3) Disconnect the bot from the meeting",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
-        // @ts-ignore - SDK type definition issue
-        const response = await baasClient.defaultApi.leave({ bot_id: botId });
+        const success = await baasClient.leaveMeeting(botId);
         return {
           content: [
             {
               type: "text",
-              text: "Successfully left meeting",
+              text: success
+                ? "Successfully left meeting"
+                : "Failed to leave meeting",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to leave meeting:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to leave meeting",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "getMeetingData",
-    "Get data about a meeting that a bot has joined. Use this when you want to: 1) Check meeting status 2) Get recording information 3) Access transcription data",
+    "Get all data from a meeting including recording, transcript, and metadata. Use this when you want to: 1) Search through meeting transcripts 2) Get meeting recordings 3) Review meeting details 4) Access speaker information",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
-        // @ts-ignore - SDK type definition issue
-        const response = await baasClient.defaultApi.getMeetingData({ bot_id: botId });
+        const data = await baasClient.getMeetingData(botId);
         return {
           content: [
             {
               type: "text",
-              text: JSON.stringify(response.data, null, 2),
+              text: JSON.stringify(data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get meeting data:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get meeting data",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "deleteData",
-    "Delete data associated with a meeting bot. Use this when you want to: 1) Remove meeting recordings 2) Delete transcription data 3) Clean up bot data",
+    "Delete all data from a meeting including recording, transcript, and logs. Use this when you want to: 1) Remove sensitive meeting data 2) Clear meeting recordings 3) Delete transcripts 4) Free up storage space",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
-        // @ts-ignore - SDK type definition issue
-        const response = await baasClient.defaultApi.deleteData({ bot_id: botId });
+        const result = await baasClient.deleteData(botId);
         return {
           content: [
             {
               type: "text",
               text: "Successfully deleted meeting data",
             },
           ],
         };
       } catch (error) {
-        console.error("Failed to delete meeting data:", error);
+        console.error("Failed to delete data:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to delete meeting data",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "createCalendar",
-    "Create a new calendar integration. Use this when you want to: 1) Set up automatic meeting recordings 2) Configure calendar-based bot scheduling 3) Enable recurring meeting coverage",
+    "Connect a Google or Microsoft calendar to Meeting BaaS. Use this when you want to: 1) Link your work calendar 2) Enable automatic meeting recordings 3) Schedule bots for future meetings 4) Sync your calendar events",
     {
       oauthClientId: z.string(),
       oauthClientSecret: z.string(),
       oauthRefreshToken: z.string(),
       platform: z.enum(["Google", "Microsoft"]),
       rawCalendarId: z.string(),
     },
-    async ({ oauthClientId, oauthClientSecret, oauthRefreshToken, platform, rawCalendarId }) => {
+    async ({
+      oauthClientId,
+      oauthClientSecret,
+      oauthRefreshToken,
+      platform,
+      rawCalendarId,
+    }: {
+      oauthClientId: string;
+      oauthClientSecret: string;
+      oauthRefreshToken: string;
+      platform: "Google" | "Microsoft";
+      rawCalendarId: string;
+    }) => {
       try {
-      let createCalendarParams: CreateCalendarParams = {
-        oauth_client_id: oauthClientId,
-        oauth_client_secret: oauthClientSecret,
-        oauth_refresh_token: oauthRefreshToken,
-        platform: platform === "Google" ? Provider.google : Provider.microsoft
-      };
-        // @ts-ignore - SDK type definition issue
-        const response = await baasClient.calendarsApi.createCalendar(createCalendarParams);
+        const calendar = await baasClient.createCalendar({
+          oauthClientId,
+          oauthClientSecret,
+          oauthRefreshToken,
+          platform: platform === "Google" ? "Google" : "Microsoft",
+          rawCalendarId,
+        });
         return {
           content: [
             {
               type: "text",
-              text: "Successfully created calendar",
+              text: `Successfully created calendar: ${JSON.stringify(
+                calendar,
+                null,
+                2
+              )}`,
             },
           ],
         };
       } catch (error) {
         console.error("Failed to create calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to create calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "listCalendars",
-    "List all calendar integrations. Use this when you want to: 1) View configured calendars 2) Check calendar status 3) Manage calendar integrations",
+    "View all connected calendars. Use this when you want to: 1) See which calendars are linked 2) Check calendar connection status 3) View calendar details 4) Manage calendar integrations",
     {},
     async () => {
       try {
-        const response = await baasClient.calendarsApi.listCalendars();
+        const calendars = await baasClient.listCalendars();
         return {
           content: [
             {
               type: "text",
-              text: JSON.stringify(response.data, null, 2),
+              text: JSON.stringify(calendars, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to list calendars:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to list calendars",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "getCalendar",
-    "Get details about a specific calendar integration. Use this when you want to: 1) View calendar configuration 2) Check calendar status 3) Verify calendar settings",
-    { calendarId: z.string() },
-    async ({ calendarId }: { calendarId: string }) => {
+    "Get detailed information about a specific calendar. Use this when you want to: 1) View calendar settings 2) Check sync status 3) See calendar events 4) Verify calendar connection",
+    { uuid: z.string() },
+    async ({ uuid }: { uuid: string }) => {
       try {
-        // @ts-ignore - SDK type definition issue
-        const response = await baasClient.calendarsApi.getCalendar({ calendar_id: calendarId });
+        const calendar = await baasClient.getCalendar(uuid);
         return {
           content: [
             {
               type: "text",
-              text: JSON.stringify(response.data, null, 2),
+              text: JSON.stringify(calendar, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "deleteCalendar",
-    "Delete a calendar integration. Use this when you want to: 1) Remove a calendar connection 2) Stop automatic recordings 3) Clean up calendar data",
-    { calendarId: z.string() },
-    async ({ calendarId }: { calendarId: string }) => {
+    "Remove a calendar connection. Use this when you want to: 1) Unlink a calendar 2) Stop automatic recordings 3) Remove calendar access 4) Clean up old integrations",
+    { uuid: z.string() },
+    async ({ uuid }: { uuid: string }) => {
       try {
-        // @ts-ignore - SDK type definition issue
-        const response = await baasClient.calendarsApi.deleteCalendar({ calendar_id: calendarId });
+        const success = await baasClient.deleteCalendar(uuid);
         return {
           content: [
             {
               type: "text",
-              text: "Successfully deleted calendar",
+              text: success
+                ? "Successfully deleted calendar"
+                : "Failed to delete calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to delete calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to delete calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "resyncAllCalendars",
-    "Resynchronize all calendar integrations. Use this when you want to: 1) Update calendar data 2) Fix sync issues 3) Refresh calendar connections",
+    "Refresh all calendar data to ensure it's up to date. Use this when you want to: 1) Update meeting schedules 2) Sync new calendar changes 3) Refresh calendar data 4) Fix sync issues",
     {},
     async () => {
       try {
-        const response = await baasClient.calendarsApi.resyncAllCalendars();
+        const result = await baasClient.resyncAllCalendars();
         return {
           content: [
             {
               type: "text",
               text: "Successfully resynced all calendars",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to resync calendars:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to resync calendars",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "botsWithMetadata",
-    "Get a list of all bots with their metadata. Use this when you want to: 1) View active bots 2) Check bot status 3) Monitor bot activity",
-    {},
-    async () => {
+    "Search and filter through your meeting bots. Use this when you want to: 1) Find specific meetings 2) Filter by date range 3) Search by meeting name 4) View meeting history",
+    {
+      botName: z.string().optional(),
+      createdAfter: z.string().optional(),
+      createdBefore: z.string().optional(),
+      cursor: z.string().optional(),
+      filterByExtra: z.string().optional(),
+      limit: z.number().optional(),
+      meetingUrl: z.string().optional(),
+      sortByExtra: z.string().optional(),
+      speakerName: z.string().optional(),
+    },
+    async ({
+      botName,
+      createdAfter,
+      createdBefore,
+      cursor,
+      filterByExtra,
+      limit,
+      meetingUrl,
+      sortByExtra,
+      speakerName,
+    }: {
+      botName?: string;
+      createdAfter?: string;
+      createdBefore?: string;
+      cursor?: string;
+      filterByExtra?: string;
+      limit?: number;
+      meetingUrl?: string;
+      sortByExtra?: string;
+      speakerName?: string;
+    }) => {
       try {
-        // @ts-ignore - SDK type definition issue
-        const response = await baasClient.defaultApi.listRecentBots();
+        const bots = await baasClient.listRecentBots({
+          botName,
+          createdAfter,
+          createdBefore,
+          cursor,
+          filterByExtra,
+          limit,
+          meetingUrl,
+          sortByExtra,
+          speakerName,
+        });
         return {
           content: [
             {
               type: "text",
-              text: JSON.stringify(response.data, null, 2),
+              text: JSON.stringify(bots, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get bots with metadata:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get bots with metadata",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "listEvents",
-    "List all scheduled events. Use this when you want to: 1) View upcoming recordings 2) Check scheduled transcriptions 3) Monitor planned bot activity",
-    { calendarId: z.string() },
-    async ({ calendarId }) => {
+    "View all events in a calendar. Use this when you want to: 1) See upcoming meetings 2) View past meetings 3) Check meeting schedules 4) Browse calendar events",
+    { calendarUuid: z.string() },
+    async ({ calendarUuid }: { calendarUuid: string }) => {
       try {
-        // @ts-ignore - SDK type definition issue
-        const response = await baasClient.calendarsApi.listEvents({ calendar_id: calendarId });
+        const events = await baasClient.listEvents(calendarUuid);
         return {
           content: [
             {
               type: "text",
-              text: JSON.stringify(response.data, null, 2),
+              text: JSON.stringify(events, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to list events:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to list events",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "scheduleRecordEvent",
-    "Schedule a recording. Use this when you want to: 1) Set up automatic recording 2) Schedule future transcriptions 3) Plan meeting recordings",
+    "Schedule a bot to automatically record a future meeting. Use this when you want to: 1) Set up automatic recording 2) Schedule future transcriptions 3) Plan meeting recordings 4) Enable recurring recordings",
     {
       eventUuid: z.string(),
       botName: z.string(),
-      extra: z.record(z.unknown()).optional(),
+      extra: z.record(z.any()).optional(),
     },
-    async ({ eventUuid, botName, extra }) => {
+    async ({
+      eventUuid,
+      botName,
+      extra,
+    }: {
+      eventUuid: string;
+      botName: string;
+      extra?: Record<string, any>;
+    }) => {
       try {
-        // @ts-ignore - SDK type definition issue
-        const response = await baasClient.calendarsApi.scheduleRecordEvent({
-          botParam2: {
-            bot_name: botName,
-            extra: extra || {},
-          },
-          allOccurrences: false,
+        const result = await baasClient.scheduleRecordEvent(eventUuid, {
+          botName,
+          extra,
         });
         return {
           content: [
             {
               type: "text",
               text: "Successfully scheduled event recording",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to schedule event recording:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to schedule event recording",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "unscheduleRecordEvent",
-    "Cancel a scheduled recording. Use this when you want to: 1) Cancel automatic recording 2) Stop planned transcription 3) Remove scheduled bot activity",
+    "Cancel a scheduled recording for a meeting. Use this when you want to: 1) Stop automatic recording 2) Cancel future transcriptions 3) Remove scheduled recordings 4) Disable recurring recordings",
     { eventUuid: z.string() },
     async ({ eventUuid }: { eventUuid: string }) => {
       try {
-        // @ts-ignore - SDK type definition issue
-        const response = await baasClient.calendarsApi.unscheduleRecordEvent({ uuid: eventUuid });
+        const result = await baasClient.unscheduleRecordEvent(eventUuid);
         return {
           content: [
             {
               type: "text",
               text: "Successfully unscheduled event recording",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to unschedule event recording:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to unschedule event recording",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   updatedServer.tool(
     "updateCalendar",
-    "Update a calendar integration configuration. Use this when you want to: 1) Modify calendar settings 2) Update connection details 3) Change calendar configuration",
+    "Update calendar connection settings. Use this when you want to: 1) Refresh calendar access 2) Update calendar credentials 3) Change calendar settings 4) Fix connection issues",
     {
-      calendarId: z.string(),
-      name: z.string(),
-      type: z.string(),
-      config: z.record(z.unknown()),
+      uuid: z.string(),
+      oauthClientId: z.string().optional(),
+      oauthClientSecret: z.string().optional(),
+      oauthRefreshToken: z.string().optional(),
+      platform: z.enum(["Google", "Microsoft"]).optional(),
+      rawCalendarId: z.string().optional(),
     },
-    async ({ calendarId, name, type, config }) => {
-      let updateCalendarParams: UpdateCalendarParams = {
-        oauth_client_id: calendarId,
-        oauth_client_secret: name,
-        oauth_refresh_token: type,
-        platform: type === "Google" ? Provider.google : Provider.microsoft
-      };
-
+    async ({
+      uuid,
+      oauthClientId,
+      oauthClientSecret,
+      oauthRefreshToken,
+      platform,
+      rawCalendarId,
+    }: {
+      uuid: string;
+      oauthClientId?: string;
+      oauthClientSecret?: string;
+      oauthRefreshToken?: string;
+      platform?: "Google" | "Microsoft";
+      rawCalendarId?: string;
+    }) => {
       try {
-        // @ts-ignore - SDK type definition issue
-        const response = await baasClient.calendarsApi.updateCalendar(updateCalendarParams);
+        const calendar = await baasClient.updateCalendar(uuid, {
+          oauthClientId,
+          oauthClientSecret,
+          oauthRefreshToken,
+          platform: platform === "Google" ? "Google" : "Microsoft",
+          rawCalendarId,
+        });
         return {
           content: [
             {
               type: "text",
-              text: "Successfully updated calendar",
+              text: `Successfully updated calendar: ${JSON.stringify(
+                calendar,
+                null,
+                2
+              )}`,
             },
           ],
         };
       } catch (error) {
         console.error("Failed to update calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to update calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  // Add echo tool for testing
-  const finalServer = registerEchoTool(updatedServer);
+  // Add a simple echo tool for testing
+  updatedServer.tool("echo", { message: z.string() }, async ({ message }) => ({
+    content: [
+      {
+        type: "text",
+        text: `Tool echo: ${message}`,
+      },
+    ],
+  }));
 
-  return finalServer;
+  return updatedServer;
 }
 
 export default registerTools;
diff --git a/api/tools/bots/index.ts b/api/tools/bots/index.ts
index e0d4048..8ea5890 100644
--- a/api/tools/bots/index.ts
+++ b/api/tools/bots/index.ts
@@ -1,10 +1,10 @@
-import { BaasClient } from "@meeting-baas/sdk/dist/generated/baas/api/client";
+import { BaasClient } from "@meeting-baas/sdk";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { registerJoinTool } from "./join";
 
 export function registerBotTools(server: McpServer, baasClient: BaasClient): McpServer {
   // Register all bot-related tools
   const updatedServer = registerJoinTool(server, baasClient);
   
   return updatedServer;
 } 
\ No newline at end of file
diff --git a/api/tools/bots/join.ts b/api/tools/bots/join.ts
index 18523d0..3fa0122 100644
--- a/api/tools/bots/join.ts
+++ b/api/tools/bots/join.ts
@@ -1,114 +1,84 @@
-import { BaasClient } from "@meeting-baas/sdk/dist/generated/baas/api/client";
+import { BaasClient } from "@meeting-baas/sdk";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { z } from "zod";
 
 // Constants for configuration based on OpenAPI spec
 const RECORDING_MODES = ['speaker_view', 'gallery_view', 'audio_only'] as const;
-
-// Import the enums from the SDK's generated types
-import { AudioFrequency, SpeechToTextProvider } from "@meeting-baas/sdk/dist/generated/baas/models";
+const SPEECH_TO_TEXT_PROVIDERS = ['Gladia', 'Runpod', 'Default'] as const;
 
 export function registerJoinTool(server: McpServer, baasClient: BaasClient): McpServer {
   server.tool(
     "joinMeeting",
     "Send an AI bot to join a video meeting. The bot can record the meeting, transcribe speech, and provide real-time audio streams. Use this when you want to: 1) Record a meeting 2) Get meeting transcriptions 3) Stream meeting audio 4) Monitor meeting attendance",
     {
       meetingUrl: z.string().url().describe("URL of the meeting to join"),
       botName: z.string().describe("Name to display for the bot in the meeting"),
       botImage: z.string().url().optional().describe("The image to use for the bot, must be a URL. Recommended ratio is 4:3."),
       entryMessage: z.string().optional().describe("There are no entry messages on Microsoft Teams as guests outside of an organization do not have access to the chat."),
       webhookUrl: z.string().url().optional().describe("A webhook URL to send events to, overrides the webhook URL set in your account settings."),
       recordingMode: z.enum(RECORDING_MODES).optional().describe("The recording mode for the bot, defaults to 'speaker_view'."),
       speechToText: z.object({
-        provider: z.nativeEnum(SpeechToTextProvider),
+        provider: z.enum(SPEECH_TO_TEXT_PROVIDERS),
         apiKey: z.string().optional()
       }).optional().describe("The default speech to text provider is Gladia."),
-      streaming: z.object({
-        input: z.string().url().optional().describe("WebSocket URL for audio input"),
-        output: z.string().url().optional().describe("WebSocket URL for audio output"),
-        audioFrequency: z.nativeEnum(AudioFrequency).optional().describe("Audio frequency for streaming")
-      }).optional().describe("Configure streaming capabilities for the bot"),
-      automaticLeave: z.object({
-        nooneJoinedTimeout: z.number().optional().describe("Timeout in seconds when no one joins"),
-        waitingRoomTimeout: z.number().optional().describe("Timeout in seconds when in waiting room")
-      }).optional().describe("Configure automatic leave behavior"),
       reserved: z.boolean().default(false).describe("Whether or not the bot should come from the available pool of bots or be a dedicated bot. Reserved bots come in exactly 4 minutes after the request."),
       startTime: z.number().optional().describe("Unix timestamp (in milliseconds) for when the bot should join the meeting. The bot joins 4 minutes before the start time."),
       deduplicationKey: z.string().optional().describe("We prevent multiple bots with same API key joining a meeting within 5 mins, unless overridden by deduplication_key."),
       extra: z.record(z.unknown()).optional().describe("A Json object that allows you to add custom data to a bot for your convenience, e.g. your end user's ID.")
     },
     async (params) => {
       try {
         // Join the meeting using the BaaS SDK
-        const joinRequest = {
-          joinRequest: {
-            meeting_url: params.meetingUrl,
-            bot_name: params.botName,
-            bot_image: params.botImage,
-            webhook_url: params.webhookUrl,
-            recording_mode: params.recordingMode || 'speaker_view',
-            speech_to_text: params.speechToText && {
-              provider: params.speechToText.provider,
-              api_key: params.speechToText.apiKey
-            },
-            reserved: params.reserved,
-            streaming: params.streaming && {
-              input: params.streaming.input,
-              output: params.streaming.output,
-              audio_frequency: params.streaming.audioFrequency
-            },
-            automatic_leave: params.automaticLeave && {
-              noone_joined_timeout: params.automaticLeave.nooneJoinedTimeout,
-              waiting_room_timeout: params.automaticLeave.waitingRoomTimeout
-            },
-            start_time: params.startTime,
-            deduplication_key: params.deduplicationKey,
-            extra: params.extra
-          }
-        };
-
-        const response = await baasClient.defaultApi.join(joinRequest);
-
-        if (response.data.bot_id) {
-          return {
-            content: [{
-              type: "text",
-              text: `Successfully joined meeting with bot ID: ${response.data.bot_id}${params.speechToText ? ` (Speech-to-text provider: ${params.speechToText.provider})` : ''}`
-            }]
-          };
-        }
+        const botId = await baasClient.joinMeeting({
+          meetingUrl: params.meetingUrl,
+          botName: params.botName,
+          botImage: params.botImage,
+          entryMessage: params.entryMessage,
+          webhookUrl: params.webhookUrl,
+          recordingMode: params.recordingMode || 'speaker_view',
+          speechToText: params.speechToText && {
+            provider: params.speechToText.provider,
+            api_key: params.speechToText.apiKey
+          },
+          reserved: params.reserved,
+          startTime: params.startTime,
+          deduplicationKey: params.deduplicationKey,
+          extra: params.extra
+        });
 
         return {
-          content: [{
-            type: "text",
-            text: "No bot ID received in the response"
-          }],
-          isError: true
+          content: [
+            {
+              type: "text",
+              text: `Successfully joined meeting with bot ID: ${botId}`
+            }
+          ]
         };
+
       } catch (error) {
         console.error("Failed to join meeting:", error);
         
         let errorMessage = "Failed to join meeting: ";
         if (error instanceof Error) {
           errorMessage += error.message;
         } else if (typeof error === 'string') {
           errorMessage += error;
         } else {
           errorMessage += "Unknown error occurred";
         }
 
         return {
           content: [
             {
               type: "text",
               text: errorMessage
             }
           ],
           isError: true
         };
       }
     }
   );
 
   return server;
 } 
\ No newline at end of file
diff --git a/package.json b/package.json
index 33c4644..6498653 100644
--- a/package.json
+++ b/package.json
@@ -1,31 +1,30 @@
 {
   "name": "meetingbaas-mcp",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
     "build": "tsc",
     "build:watch": "tsc --watch",
     "start": "node -r dotenv/config dist/api/server.js",
     "dev": "tsc --watch & node -r dotenv/config dist/api/server.js"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
-    "@meeting-baas/sdk": "^0.3.6",
+    "@meeting-baas/sdk": "^0.3.3",
     "@modelcontextprotocol/sdk": "^1.6.1",
     "content-type": "^1.0.5",
     "dotenv": "^16.4.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
     "@types/node": "^20.17.30",
-    "tsup": "^8.4.0",
     "typescript": "^5.3.3"
   }
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 98125d4f71ee6f1f8f23fde550a5fd6a050ad16b
#KEY#COMMIT_DATE# 2025-04-23 11:41:47 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# Feat: try complete join tools with API options
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools/bots/join.ts
- package.json

#KEY#DIFF_RANGE# FROM: c012ef7222bde8face7407e41f00b74e3b3ceee6 TO: 98125d4f71ee6f1f8f23fde550a5fd6a050ad16b
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools/bots/join.ts b/api/tools/bots/join.ts
index 3fa0122..8a635ac 100644
--- a/api/tools/bots/join.ts
+++ b/api/tools/bots/join.ts
@@ -1,84 +1,162 @@
 import { BaasClient } from "@meeting-baas/sdk";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { z } from "zod";
+import * as fs from 'fs';
+import * as os from 'os';
+import * as path from 'path';
 
 // Constants for configuration based on OpenAPI spec
 const RECORDING_MODES = ['speaker_view', 'gallery_view', 'audio_only'] as const;
+const AUDIO_FREQUENCIES = ['16khz', '24khz'] as const;
 const SPEECH_TO_TEXT_PROVIDERS = ['Gladia', 'Runpod', 'Default'] as const;
 
+// Default bot configuration
+const DEFAULT_BOT_CONFIG = {
+  name: 'Meeting Assistant',
+  image: 'https://meetingbaas.com/bot-avatar.png',
+  entryMessage: 'Hello! I\'m here to assist with the meeting.',
+  extra: {
+    type: 'assistant',
+    capabilities: ['recording', 'transcription']
+  }
+};
+
+// Helper function to read Claude Desktop config
+function readClaudeDesktopConfig(): any {
+  try {
+    const configPath = path.join(
+      os.homedir(),
+      'Library/Application Support/Claude/claude_desktop_config.json'
+    );
+
+    if (fs.existsSync(configPath)) {
+      const configContent = fs.readFileSync(configPath, 'utf8');
+      const configJson = JSON.parse(configContent);
+
+      if (configJson.mcpServers?.meetingbaas?.botConfig) {
+        return configJson.mcpServers.meetingbaas.botConfig;
+      }
+    }
+    return null;
+  } catch (error) {
+    console.error('Error reading Claude Desktop config:', error);
+    return null;
+  }
+}
+
 export function registerJoinTool(server: McpServer, baasClient: BaasClient): McpServer {
   server.tool(
     "joinMeeting",
     "Send an AI bot to join a video meeting. The bot can record the meeting, transcribe speech, and provide real-time audio streams. Use this when you want to: 1) Record a meeting 2) Get meeting transcriptions 3) Stream meeting audio 4) Monitor meeting attendance",
     {
       meetingUrl: z.string().url().describe("URL of the meeting to join"),
-      botName: z.string().describe("Name to display for the bot in the meeting"),
-      botImage: z.string().url().optional().describe("The image to use for the bot, must be a URL. Recommended ratio is 4:3."),
-      entryMessage: z.string().optional().describe("There are no entry messages on Microsoft Teams as guests outside of an organization do not have access to the chat."),
+      botName: z.string().optional().describe("Name to display for the bot in the meeting"),
+      botImage: z.string().url().optional().describe("URL to an image to use for the bot's avatar. Recommended ratio is 4:3."),
+      entryMessage: z.string().optional().describe("Message the bot will send upon joining the meeting. Not available for Microsoft Teams."),
       webhookUrl: z.string().url().optional().describe("A webhook URL to send events to, overrides the webhook URL set in your account settings."),
       recordingMode: z.enum(RECORDING_MODES).optional().describe("The recording mode for the bot, defaults to 'speaker_view'."),
       speechToText: z.object({
         provider: z.enum(SPEECH_TO_TEXT_PROVIDERS),
         apiKey: z.string().optional()
-      }).optional().describe("The default speech to text provider is Gladia."),
-      reserved: z.boolean().default(false).describe("Whether or not the bot should come from the available pool of bots or be a dedicated bot. Reserved bots come in exactly 4 minutes after the request."),
-      startTime: z.number().optional().describe("Unix timestamp (in milliseconds) for when the bot should join the meeting. The bot joins 4 minutes before the start time."),
-      deduplicationKey: z.string().optional().describe("We prevent multiple bots with same API key joining a meeting within 5 mins, unless overridden by deduplication_key."),
-      extra: z.record(z.unknown()).optional().describe("A Json object that allows you to add custom data to a bot for your convenience, e.g. your end user's ID.")
+      }).optional().describe("Speech-to-text configuration. Default provider is 'Default'."),
+      streaming: z.object({
+        input: z.string().url().optional(),
+        output: z.string().url().optional(),
+        audioFrequency: z.enum(AUDIO_FREQUENCIES).optional()
+      }).optional().describe("WebSocket streams for audio. Input receives audio sent to bot, output receives audio from bot."),
+      automaticLeave: z.object({
+        nooneJoinedTimeout: z.number().int().min(0).optional(),
+        waitingRoomTimeout: z.number().int().min(0).optional()
+      }).optional().describe("Automatic leave configuration with timeouts in seconds."),
+      reserved: z.boolean().default(false).describe("Whether to use a dedicated bot (takes 4 minutes to boot) or one from the pool."),
+      startTime: z.number().optional().describe("Unix timestamp (ms) for when the bot should join. Bot joins 4 minutes before."),
+      extra: z.record(z.unknown()).optional().describe("Custom data object for your convenience.")
     },
     async (params) => {
       try {
-        // Join the meeting using the BaaS SDK
-        const botId = await baasClient.joinMeeting({
+        // Load Claude Desktop config for defaults
+        const claudeConfig = readClaudeDesktopConfig();
+        
+        // Merge configurations with priority: params > claudeConfig > DEFAULT_BOT_CONFIG
+        const botName = params.botName || claudeConfig?.name || DEFAULT_BOT_CONFIG.name;
+        const botImage = params.botImage || claudeConfig?.image || DEFAULT_BOT_CONFIG.image;
+        const entryMessage = params.entryMessage || claudeConfig?.entryMessage || DEFAULT_BOT_CONFIG.entryMessage;
+        const extra = { 
+          ...DEFAULT_BOT_CONFIG.extra,
+          ...claudeConfig?.extra,
+          ...params.extra
+        };
+
+        // Prepare the join meeting request according to SDK format
+        const joinRequest = {
+          botName,
           meetingUrl: params.meetingUrl,
-          botName: params.botName,
-          botImage: params.botImage,
-          entryMessage: params.entryMessage,
+          botImage,
+          entryMessage,
           webhookUrl: params.webhookUrl,
           recordingMode: params.recordingMode || 'speaker_view',
           speechToText: params.speechToText && {
             provider: params.speechToText.provider,
-            api_key: params.speechToText.apiKey
+            apiKey: params.speechToText.apiKey
+          },
+          streaming: params.streaming && {
+            input: params.streaming.input,
+            output: params.streaming.output,
+            audioFrequency: params.streaming.audioFrequency
+          },
+          automaticLeave: params.automaticLeave && {
+            nooneJoinedTimeout: params.automaticLeave.nooneJoinedTimeout,
+            waitingRoomTimeout: params.automaticLeave.waitingRoomTimeout
           },
           reserved: params.reserved,
           startTime: params.startTime,
-          deduplicationKey: params.deduplicationKey,
-          extra: params.extra
-        });
+          extra
+        };
+
+        // Join the meeting using the BaaS SDK
+        const botId = await baasClient.joinMeeting(joinRequest);
+
+        // Prepare success response with details
+        let responseMessage = `Successfully joined meeting with bot ID: ${botId}\n`;
+        responseMessage += `Bot Name: ${botName}\n`;
+        if (params.recordingMode) responseMessage += `Recording Mode: ${params.recordingMode}\n`;
+        if (params.speechToText) responseMessage += `Speech-to-Text: Enabled (${params.speechToText.provider})\n`;
+        if (params.startTime) responseMessage += `Scheduled Start: ${new Date(params.startTime).toISOString()}\n`;
 
         return {
           content: [
             {
               type: "text",
-              text: `Successfully joined meeting with bot ID: ${botId}`
+              text: responseMessage
             }
           ]
         };
 
       } catch (error) {
         console.error("Failed to join meeting:", error);
         
+        // Prepare error message with details
         let errorMessage = "Failed to join meeting: ";
         if (error instanceof Error) {
           errorMessage += error.message;
         } else if (typeof error === 'string') {
           errorMessage += error;
         } else {
           errorMessage += "Unknown error occurred";
         }
 
         return {
           content: [
             {
               type: "text",
               text: errorMessage
             }
           ],
           isError: true
         };
       }
     }
   );
 
   return server;
 } 
\ No newline at end of file
diff --git a/package.json b/package.json
index 6498653..90be9ef 100644
--- a/package.json
+++ b/package.json
@@ -1,30 +1,30 @@
 {
   "name": "meetingbaas-mcp",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
     "build": "tsc",
     "build:watch": "tsc --watch",
     "start": "node -r dotenv/config dist/api/server.js",
     "dev": "tsc --watch & node -r dotenv/config dist/api/server.js"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
-    "@meeting-baas/sdk": "^0.3.3",
+    "@meeting-baas/sdk": "^0.2.4",
     "@modelcontextprotocol/sdk": "^1.6.1",
     "content-type": "^1.0.5",
     "dotenv": "^16.4.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
-    "@types/node": "^20.17.30",
+    "@types/node": "^20.11.24",
     "typescript": "^5.3.3"
   }
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# da6bc3e6292aa4500456551f6fc131c567bd1ad9
#KEY#COMMIT_DATE# 2025-04-23 11:41:47 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# factorize: put echo in own file
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools/bots/join.ts

#KEY#DIFF_RANGE# FROM: 98125d4f71ee6f1f8f23fde550a5fd6a050ad16b TO: da6bc3e6292aa4500456551f6fc131c567bd1ad9
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools/bots/join.ts b/api/tools/bots/join.ts
index 8a635ac..2d57874 100644
--- a/api/tools/bots/join.ts
+++ b/api/tools/bots/join.ts
@@ -1,162 +1,65 @@
 import { BaasClient } from "@meeting-baas/sdk";
-import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { z } from "zod";
-import * as fs from 'fs';
-import * as os from 'os';
-import * as path from 'path';
-
-// Constants for configuration based on OpenAPI spec
-const RECORDING_MODES = ['speaker_view', 'gallery_view', 'audio_only'] as const;
-const AUDIO_FREQUENCIES = ['16khz', '24khz'] as const;
-const SPEECH_TO_TEXT_PROVIDERS = ['Gladia', 'Runpod', 'Default'] as const;
-
-// Default bot configuration
-const DEFAULT_BOT_CONFIG = {
-  name: 'Meeting Assistant',
-  image: 'https://meetingbaas.com/bot-avatar.png',
-  entryMessage: 'Hello! I\'m here to assist with the meeting.',
-  extra: {
-    type: 'assistant',
-    capabilities: ['recording', 'transcription']
-  }
-};
-
-// Helper function to read Claude Desktop config
-function readClaudeDesktopConfig(): any {
-  try {
-    const configPath = path.join(
-      os.homedir(),
-      'Library/Application Support/Claude/claude_desktop_config.json'
-    );
-
-    if (fs.existsSync(configPath)) {
-      const configContent = fs.readFileSync(configPath, 'utf8');
-      const configJson = JSON.parse(configContent);
-
-      if (configJson.mcpServers?.meetingbaas?.botConfig) {
-        return configJson.mcpServers.meetingbaas.botConfig;
-      }
-    }
-    return null;
-  } catch (error) {
-    console.error('Error reading Claude Desktop config:', error);
-    return null;
-  }
-}
+import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 
 export function registerJoinTool(server: McpServer, baasClient: BaasClient): McpServer {
   server.tool(
     "joinMeeting",
     "Send an AI bot to join a video meeting. The bot can record the meeting, transcribe speech, and provide real-time audio streams. Use this when you want to: 1) Record a meeting 2) Get meeting transcriptions 3) Stream meeting audio 4) Monitor meeting attendance",
     {
-      meetingUrl: z.string().url().describe("URL of the meeting to join"),
-      botName: z.string().optional().describe("Name to display for the bot in the meeting"),
-      botImage: z.string().url().optional().describe("URL to an image to use for the bot's avatar. Recommended ratio is 4:3."),
-      entryMessage: z.string().optional().describe("Message the bot will send upon joining the meeting. Not available for Microsoft Teams."),
-      webhookUrl: z.string().url().optional().describe("A webhook URL to send events to, overrides the webhook URL set in your account settings."),
-      recordingMode: z.enum(RECORDING_MODES).optional().describe("The recording mode for the bot, defaults to 'speaker_view'."),
-      speechToText: z.object({
-        provider: z.enum(SPEECH_TO_TEXT_PROVIDERS),
-        apiKey: z.string().optional()
-      }).optional().describe("Speech-to-text configuration. Default provider is 'Default'."),
-      streaming: z.object({
-        input: z.string().url().optional(),
-        output: z.string().url().optional(),
-        audioFrequency: z.enum(AUDIO_FREQUENCIES).optional()
-      }).optional().describe("WebSocket streams for audio. Input receives audio sent to bot, output receives audio from bot."),
-      automaticLeave: z.object({
-        nooneJoinedTimeout: z.number().int().min(0).optional(),
-        waitingRoomTimeout: z.number().int().min(0).optional()
-      }).optional().describe("Automatic leave configuration with timeouts in seconds."),
-      reserved: z.boolean().default(false).describe("Whether to use a dedicated bot (takes 4 minutes to boot) or one from the pool."),
-      startTime: z.number().optional().describe("Unix timestamp (ms) for when the bot should join. Bot joins 4 minutes before."),
-      extra: z.record(z.unknown()).optional().describe("Custom data object for your convenience.")
+      meetingUrl: z.string(),
+      botName: z.string(),
+      webhookUrl: z.string().optional(),
+      recordingMode: z.string().optional(),
+      speechToText: z.boolean().optional(),
+      reserved: z.boolean(),
     },
-    async (params) => {
+    async ({
+      meetingUrl,
+      botName,
+      webhookUrl,
+      recordingMode,
+      speechToText,
+      reserved,
+    }: {
+      meetingUrl: string;
+      botName: string;
+      webhookUrl?: string;
+      recordingMode?: string;
+      speechToText?: boolean;
+      reserved: boolean;
+    }) => {
       try {
-        // Load Claude Desktop config for defaults
-        const claudeConfig = readClaudeDesktopConfig();
-        
-        // Merge configurations with priority: params > claudeConfig > DEFAULT_BOT_CONFIG
-        const botName = params.botName || claudeConfig?.name || DEFAULT_BOT_CONFIG.name;
-        const botImage = params.botImage || claudeConfig?.image || DEFAULT_BOT_CONFIG.image;
-        const entryMessage = params.entryMessage || claudeConfig?.entryMessage || DEFAULT_BOT_CONFIG.entryMessage;
-        const extra = { 
-          ...DEFAULT_BOT_CONFIG.extra,
-          ...claudeConfig?.extra,
-          ...params.extra
-        };
-
-        // Prepare the join meeting request according to SDK format
-        const joinRequest = {
+        const botId = await baasClient.joinMeeting({
+          meetingUrl,
           botName,
-          meetingUrl: params.meetingUrl,
-          botImage,
-          entryMessage,
-          webhookUrl: params.webhookUrl,
-          recordingMode: params.recordingMode || 'speaker_view',
-          speechToText: params.speechToText && {
-            provider: params.speechToText.provider,
-            apiKey: params.speechToText.apiKey
-          },
-          streaming: params.streaming && {
-            input: params.streaming.input,
-            output: params.streaming.output,
-            audioFrequency: params.streaming.audioFrequency
-          },
-          automaticLeave: params.automaticLeave && {
-            nooneJoinedTimeout: params.automaticLeave.nooneJoinedTimeout,
-            waitingRoomTimeout: params.automaticLeave.waitingRoomTimeout
-          },
-          reserved: params.reserved,
-          startTime: params.startTime,
-          extra
-        };
-
-        // Join the meeting using the BaaS SDK
-        const botId = await baasClient.joinMeeting(joinRequest);
-
-        // Prepare success response with details
-        let responseMessage = `Successfully joined meeting with bot ID: ${botId}\n`;
-        responseMessage += `Bot Name: ${botName}\n`;
-        if (params.recordingMode) responseMessage += `Recording Mode: ${params.recordingMode}\n`;
-        if (params.speechToText) responseMessage += `Speech-to-Text: Enabled (${params.speechToText.provider})\n`;
-        if (params.startTime) responseMessage += `Scheduled Start: ${new Date(params.startTime).toISOString()}\n`;
-
+          webhookUrl,
+          recordingMode,
+          speechToText: speechToText ? { provider: "Default" } : undefined,
+          reserved,
+        });
         return {
           content: [
             {
               type: "text",
-              text: responseMessage
-            }
-          ]
+              text: `Successfully joined meeting with bot ID: ${botId}`,
+            },
+          ],
         };
-
       } catch (error) {
         console.error("Failed to join meeting:", error);
-        
-        // Prepare error message with details
-        let errorMessage = "Failed to join meeting: ";
-        if (error instanceof Error) {
-          errorMessage += error.message;
-        } else if (typeof error === 'string') {
-          errorMessage += error;
-        } else {
-          errorMessage += "Unknown error occurred";
-        }
-
         return {
           content: [
             {
               type: "text",
-              text: errorMessage
-            }
+              text: "Failed to join meeting",
+            },
           ],
-          isError: true
+          isError: true,
         };
       }
     }
   );
 
   return server;
 } 
\ No newline at end of file
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 11eb1e7ca51f10d64754f4dd0d9f60b25bc11a2d
#KEY#COMMIT_DATE# 2025-04-23 11:41:47 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# refactor: avoid parameter reassignment in tool registration
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools/index.ts
- api/tools/utils/echo.ts

#KEY#DIFF_RANGE# FROM: da6bc3e6292aa4500456551f6fc131c567bd1ad9 TO: 11eb1e7ca51f10d64754f4dd0d9f60b25bc11a2d
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools/index.ts b/api/tools/index.ts
index d9f0bda..f5f669c 100644
--- a/api/tools/index.ts
+++ b/api/tools/index.ts
@@ -1,20 +1,27 @@
 import { BaasClient } from "@meeting-baas/sdk";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
+import { z } from "zod";
 import { registerBotTools } from "./bots";
-import { registerEchoTool } from "./utils/echo";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
   });
 
   // Register bot tools
   const updatedServer = registerBotTools(server, baasClient);
 
-  // Add echo tool for testing
-  const finalServer = registerEchoTool(updatedServer);
+  // Add a simple echo tool for testing
+  updatedServer.tool("echo", { message: z.string() }, async ({ message }: { message: string }) => ({
+    content: [
+      {
+        type: "text",
+        text: `Tool echo: ${message}`,
+      },
+    ],
+  }));
 
-  return finalServer;
+  return updatedServer;
 }
 
 export default registerTools; 
\ No newline at end of file
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 52851576a3ed6fc55f27fafbd1ee9c199dccca4d
#KEY#COMMIT_DATE# 2025-04-23 11:41:45 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# fix: try move join meeting tool to separate module for deployment testing
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools.ts
- api/tools/bots/index.ts
- api/tools/index.ts

#KEY#DIFF_RANGE# FROM: 11eb1e7ca51f10d64754f4dd0d9f60b25bc11a2d TO: 52851576a3ed6fc55f27fafbd1ee9c199dccca4d
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools.ts b/api/tools.ts
index aac15af..032aef0 100644
--- a/api/tools.ts
+++ b/api/tools.ts
@@ -1,536 +1,536 @@
 import { BaasClient } from "@meeting-baas/sdk";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import z from "zod";
 import { registerJoinTool } from "./tools/bots/join";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
   });
 
   // Register bot tools
-  const updatedServer = registerJoinTool(server, baasClient);
+  server = registerJoinTool(server, baasClient);
 
   // Register Meeting BaaS SDK tools
-  updatedServer.tool(
+  server.tool(
     "leaveMeeting",
     "Remove an AI bot from a meeting. Use this when you want to: 1) End a meeting recording 2) Stop transcription 3) Disconnect the bot from the meeting",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         const success = await baasClient.leaveMeeting(botId);
         return {
           content: [
             {
               type: "text",
               text: success
                 ? "Successfully left meeting"
                 : "Failed to leave meeting",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to leave meeting:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to leave meeting",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  updatedServer.tool(
+  server.tool(
     "getMeetingData",
     "Get all data from a meeting including recording, transcript, and metadata. Use this when you want to: 1) Search through meeting transcripts 2) Get meeting recordings 3) Review meeting details 4) Access speaker information",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         const data = await baasClient.getMeetingData(botId);
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get meeting data:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get meeting data",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  updatedServer.tool(
+  server.tool(
     "deleteData",
     "Delete all data from a meeting including recording, transcript, and logs. Use this when you want to: 1) Remove sensitive meeting data 2) Clear meeting recordings 3) Delete transcripts 4) Free up storage space",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         const result = await baasClient.deleteData(botId);
         return {
           content: [
             {
               type: "text",
               text: "Successfully deleted meeting data",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to delete data:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to delete meeting data",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  updatedServer.tool(
+  server.tool(
     "createCalendar",
     "Connect a Google or Microsoft calendar to Meeting BaaS. Use this when you want to: 1) Link your work calendar 2) Enable automatic meeting recordings 3) Schedule bots for future meetings 4) Sync your calendar events",
     {
       oauthClientId: z.string(),
       oauthClientSecret: z.string(),
       oauthRefreshToken: z.string(),
       platform: z.enum(["Google", "Microsoft"]),
       rawCalendarId: z.string(),
     },
     async ({
       oauthClientId,
       oauthClientSecret,
       oauthRefreshToken,
       platform,
       rawCalendarId,
     }: {
       oauthClientId: string;
       oauthClientSecret: string;
       oauthRefreshToken: string;
       platform: "Google" | "Microsoft";
       rawCalendarId: string;
     }) => {
       try {
         const calendar = await baasClient.createCalendar({
           oauthClientId,
           oauthClientSecret,
           oauthRefreshToken,
           platform: platform === "Google" ? "Google" : "Microsoft",
           rawCalendarId,
         });
         return {
           content: [
             {
               type: "text",
               text: `Successfully created calendar: ${JSON.stringify(
                 calendar,
                 null,
                 2
               )}`,
             },
           ],
         };
       } catch (error) {
         console.error("Failed to create calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to create calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  updatedServer.tool(
+  server.tool(
     "listCalendars",
     "View all connected calendars. Use this when you want to: 1) See which calendars are linked 2) Check calendar connection status 3) View calendar details 4) Manage calendar integrations",
     {},
     async () => {
       try {
         const calendars = await baasClient.listCalendars();
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(calendars, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to list calendars:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to list calendars",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  updatedServer.tool(
+  server.tool(
     "getCalendar",
     "Get detailed information about a specific calendar. Use this when you want to: 1) View calendar settings 2) Check sync status 3) See calendar events 4) Verify calendar connection",
     { uuid: z.string() },
     async ({ uuid }: { uuid: string }) => {
       try {
         const calendar = await baasClient.getCalendar(uuid);
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(calendar, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  updatedServer.tool(
+  server.tool(
     "deleteCalendar",
     "Remove a calendar connection. Use this when you want to: 1) Unlink a calendar 2) Stop automatic recordings 3) Remove calendar access 4) Clean up old integrations",
     { uuid: z.string() },
     async ({ uuid }: { uuid: string }) => {
       try {
         const success = await baasClient.deleteCalendar(uuid);
         return {
           content: [
             {
               type: "text",
               text: success
                 ? "Successfully deleted calendar"
                 : "Failed to delete calendar",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to delete calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to delete calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  updatedServer.tool(
+  server.tool(
     "resyncAllCalendars",
     "Refresh all calendar data to ensure it's up to date. Use this when you want to: 1) Update meeting schedules 2) Sync new calendar changes 3) Refresh calendar data 4) Fix sync issues",
     {},
     async () => {
       try {
         const result = await baasClient.resyncAllCalendars();
         return {
           content: [
             {
               type: "text",
               text: "Successfully resynced all calendars",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to resync calendars:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to resync calendars",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  updatedServer.tool(
+  server.tool(
     "botsWithMetadata",
     "Search and filter through your meeting bots. Use this when you want to: 1) Find specific meetings 2) Filter by date range 3) Search by meeting name 4) View meeting history",
     {
       botName: z.string().optional(),
       createdAfter: z.string().optional(),
       createdBefore: z.string().optional(),
       cursor: z.string().optional(),
       filterByExtra: z.string().optional(),
       limit: z.number().optional(),
       meetingUrl: z.string().optional(),
       sortByExtra: z.string().optional(),
       speakerName: z.string().optional(),
     },
     async ({
       botName,
       createdAfter,
       createdBefore,
       cursor,
       filterByExtra,
       limit,
       meetingUrl,
       sortByExtra,
       speakerName,
     }: {
       botName?: string;
       createdAfter?: string;
       createdBefore?: string;
       cursor?: string;
       filterByExtra?: string;
       limit?: number;
       meetingUrl?: string;
       sortByExtra?: string;
       speakerName?: string;
     }) => {
       try {
         const bots = await baasClient.listRecentBots({
           botName,
           createdAfter,
           createdBefore,
           cursor,
           filterByExtra,
           limit,
           meetingUrl,
           sortByExtra,
           speakerName,
         });
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(bots, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get bots with metadata:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get bots with metadata",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  updatedServer.tool(
+  server.tool(
     "listEvents",
     "View all events in a calendar. Use this when you want to: 1) See upcoming meetings 2) View past meetings 3) Check meeting schedules 4) Browse calendar events",
     { calendarUuid: z.string() },
     async ({ calendarUuid }: { calendarUuid: string }) => {
       try {
         const events = await baasClient.listEvents(calendarUuid);
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(events, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to list events:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to list events",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  updatedServer.tool(
+  server.tool(
     "scheduleRecordEvent",
     "Schedule a bot to automatically record a future meeting. Use this when you want to: 1) Set up automatic recording 2) Schedule future transcriptions 3) Plan meeting recordings 4) Enable recurring recordings",
     {
       eventUuid: z.string(),
       botName: z.string(),
       extra: z.record(z.any()).optional(),
     },
     async ({
       eventUuid,
       botName,
       extra,
     }: {
       eventUuid: string;
       botName: string;
       extra?: Record<string, any>;
     }) => {
       try {
         const result = await baasClient.scheduleRecordEvent(eventUuid, {
           botName,
           extra,
         });
         return {
           content: [
             {
               type: "text",
               text: "Successfully scheduled event recording",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to schedule event recording:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to schedule event recording",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  updatedServer.tool(
+  server.tool(
     "unscheduleRecordEvent",
     "Cancel a scheduled recording for a meeting. Use this when you want to: 1) Stop automatic recording 2) Cancel future transcriptions 3) Remove scheduled recordings 4) Disable recurring recordings",
     { eventUuid: z.string() },
     async ({ eventUuid }: { eventUuid: string }) => {
       try {
         const result = await baasClient.unscheduleRecordEvent(eventUuid);
         return {
           content: [
             {
               type: "text",
               text: "Successfully unscheduled event recording",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to unschedule event recording:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to unschedule event recording",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
-  updatedServer.tool(
+  server.tool(
     "updateCalendar",
     "Update calendar connection settings. Use this when you want to: 1) Refresh calendar access 2) Update calendar credentials 3) Change calendar settings 4) Fix connection issues",
     {
       uuid: z.string(),
       oauthClientId: z.string().optional(),
       oauthClientSecret: z.string().optional(),
       oauthRefreshToken: z.string().optional(),
       platform: z.enum(["Google", "Microsoft"]).optional(),
       rawCalendarId: z.string().optional(),
     },
     async ({
       uuid,
       oauthClientId,
       oauthClientSecret,
       oauthRefreshToken,
       platform,
       rawCalendarId,
     }: {
       uuid: string;
       oauthClientId?: string;
       oauthClientSecret?: string;
       oauthRefreshToken?: string;
       platform?: "Google" | "Microsoft";
       rawCalendarId?: string;
     }) => {
       try {
         const calendar = await baasClient.updateCalendar(uuid, {
           oauthClientId,
           oauthClientSecret,
           oauthRefreshToken,
           platform: platform === "Google" ? "Google" : "Microsoft",
           rawCalendarId,
         });
         return {
           content: [
             {
               type: "text",
               text: `Successfully updated calendar: ${JSON.stringify(
                 calendar,
                 null,
                 2
               )}`,
             },
           ],
         };
       } catch (error) {
         console.error("Failed to update calendar:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to update calendar",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   // Add a simple echo tool for testing
-  updatedServer.tool("echo", { message: z.string() }, async ({ message }) => ({
+  server.tool("echo", { message: z.string() }, async ({ message }) => ({
     content: [
       {
         type: "text",
         text: `Tool echo: ${message}`,
       },
     ],
   }));
 
-  return updatedServer;
+  return server;
 }
 
 export default registerTools;
diff --git a/api/tools/bots/index.ts b/api/tools/bots/index.ts
index 8ea5890..853102f 100644
--- a/api/tools/bots/index.ts
+++ b/api/tools/bots/index.ts
@@ -1,10 +1,10 @@
 import { BaasClient } from "@meeting-baas/sdk";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { registerJoinTool } from "./join";
 
 export function registerBotTools(server: McpServer, baasClient: BaasClient): McpServer {
   // Register all bot-related tools
-  const updatedServer = registerJoinTool(server, baasClient);
+  server = registerJoinTool(server, baasClient);
   
-  return updatedServer;
+  return server;
 } 
\ No newline at end of file
diff --git a/api/tools/index.ts b/api/tools/index.ts
index f5f669c..8e3e3e9 100644
--- a/api/tools/index.ts
+++ b/api/tools/index.ts
@@ -1,27 +1,27 @@
 import { BaasClient } from "@meeting-baas/sdk";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { z } from "zod";
 import { registerBotTools } from "./bots";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
   });
 
   // Register bot tools
-  const updatedServer = registerBotTools(server, baasClient);
+  server = registerBotTools(server, baasClient);
 
   // Add a simple echo tool for testing
-  updatedServer.tool("echo", { message: z.string() }, async ({ message }: { message: string }) => ({
+  server.tool("echo", { message: z.string() }, async ({ message }: { message: string }) => ({
     content: [
       {
         type: "text",
         text: `Tool echo: ${message}`,
       },
     ],
   }));
 
-  return updatedServer;
+  return server;
 }
 
 export default registerTools; 
\ No newline at end of file
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 07bea5f6e1105f24c02b45fd601f263d3e192e71
#KEY#COMMIT_DATE# 2025-04-23 11:41:29 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# feat-fix: no errors if no auth
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/tools.ts
- api/tools/bots/index.ts
- api/tools/bots/join.ts
- api/tools/index.ts

#KEY#DIFF_RANGE# FROM: 52851576a3ed6fc55f27fafbd1ee9c199dccca4d TO: 07bea5f6e1105f24c02b45fd601f263d3e192e71
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/tools.ts b/api/tools.ts
index 032aef0..d9cd64c 100644
--- a/api/tools.ts
+++ b/api/tools.ts
@@ -1,114 +1,168 @@
 import { BaasClient } from "@meeting-baas/sdk";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import z from "zod";
-import { registerJoinTool } from "./tools/bots/join";
 
 export function registerTools(server: McpServer, apiKey: string): McpServer {
   const baasClient = new BaasClient({
     apiKey: apiKey,
   });
 
-  // Register bot tools
-  server = registerJoinTool(server, baasClient);
-
   // Register Meeting BaaS SDK tools
+  server.tool(
+    "joinMeeting",
+    "Send an AI bot to join a video meeting. The bot can record the meeting, transcribe speech, and provide real-time audio streams. Use this when you want to: 1) Record a meeting 2) Get meeting transcriptions 3) Stream meeting audio 4) Monitor meeting attendance",
+    {
+      meetingUrl: z.string(),
+      botName: z.string(),
+      webhookUrl: z.string().optional(),
+      recordingMode: z.string().optional(),
+      speechToText: z.boolean().optional(),
+      reserved: z.boolean(),
+    },
+    async ({
+      meetingUrl,
+      botName,
+      webhookUrl,
+      recordingMode,
+      speechToText,
+      reserved,
+    }: {
+      meetingUrl: string;
+      botName: string;
+      webhookUrl?: string;
+      recordingMode?: string;
+      speechToText?: boolean;
+      reserved: boolean;
+    }) => {
+      try {
+        const botId = await baasClient.joinMeeting({
+          meetingUrl,
+          botName,
+          webhookUrl,
+          recordingMode,
+          speechToText: speechToText ? { provider: "Default" } : undefined,
+          reserved,
+        });
+        return {
+          content: [
+            {
+              type: "text",
+              text: `Successfully joined meeting with bot ID: ${botId}`,
+            },
+          ],
+        };
+      } catch (error) {
+        console.error("Failed to join meeting:", error);
+        return {
+          content: [
+            {
+              type: "text",
+              text: "Failed to join meeting",
+            },
+          ],
+          isError: true,
+        };
+      }
+    }
+  );
+
   server.tool(
     "leaveMeeting",
     "Remove an AI bot from a meeting. Use this when you want to: 1) End a meeting recording 2) Stop transcription 3) Disconnect the bot from the meeting",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         const success = await baasClient.leaveMeeting(botId);
         return {
           content: [
             {
               type: "text",
               text: success
                 ? "Successfully left meeting"
                 : "Failed to leave meeting",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to leave meeting:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to leave meeting",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   server.tool(
     "getMeetingData",
     "Get all data from a meeting including recording, transcript, and metadata. Use this when you want to: 1) Search through meeting transcripts 2) Get meeting recordings 3) Review meeting details 4) Access speaker information",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         const data = await baasClient.getMeetingData(botId);
         return {
           content: [
             {
               type: "text",
               text: JSON.stringify(data, null, 2),
             },
           ],
         };
       } catch (error) {
         console.error("Failed to get meeting data:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to get meeting data",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   server.tool(
     "deleteData",
     "Delete all data from a meeting including recording, transcript, and logs. Use this when you want to: 1) Remove sensitive meeting data 2) Clear meeting recordings 3) Delete transcripts 4) Free up storage space",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         const result = await baasClient.deleteData(botId);
         return {
           content: [
             {
               type: "text",
               text: "Successfully deleted meeting data",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to delete data:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to delete meeting data",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   server.tool(
     "createCalendar",
     "Connect a Google or Microsoft calendar to Meeting BaaS. Use this when you want to: 1) Link your work calendar 2) Enable automatic meeting recordings 3) Schedule bots for future meetings 4) Sync your calendar events",
     {
       oauthClientId: z.string(),
       oauthClientSecret: z.string(),
       oauthRefreshToken: z.string(),
       platform: z.enum(["Google", "Microsoft"]),
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 0b1f6e6a3a14762691e0a1de173725f5872524ce
#KEY#COMMIT_DATE# 2025-04-23 11:40:18 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# fix baas api key
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: 07bea5f6e1105f24c02b45fd601f263d3e192e71 TO: 0b1f6e6a3a14762691e0a1de173725f5872524ce
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index 7ec37a8..5871ca6 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -9,271 +9,266 @@ import { createClient } from "redis";
 import { Readable } from "stream";
 import z from "zod";
 import vercelJson from "../vercel.json";
 import { RedisClientType } from "redis";
 import { registerTools } from "../api/tools.js";
 
 interface ServerOptions extends McpServerOptions {
   parameters?: {
     schema: z.ZodSchema;
   };
 }
 
 interface SerializedRequest {
   requestId: string;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer, apiKey: string) => void,
   serverOptions: ServerOptions = {}
 ) {
   const maxDuration =
     vercelJson?.functions?.["api/server.ts"]?.maxDuration || 800;
   const redisUrl = process.env.REDIS_URL || process.env.KV_URL;
   if (!redisUrl) {
     throw new Error("REDIS_URL environment variable is not set");
   }
   const redis = createClient({
     url: redisUrl,
   });
   const redisPublisher = createClient({
     url: redisUrl,
   });
   redis.on("error", (err) => {
     console.error("Redis error", err);
   });
   redisPublisher.on("error", (err) => {
     console.error("Redis error", err);
   });
   const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 
   let servers: McpServer[] = [];
 
   let statelessServer: McpServer;
   const statelessTransport = new StreamableHTTPServerTransport({
     sessionIdGenerator: undefined,
   });
 
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://mcp.meetingbaas.com");
 
     // Skip validation for static files
     if (url.pathname.endsWith(".ico") || url.pathname.endsWith(".png")) {
       return;
     }
 
     // Only validate API key for SSE and chat endpoints
     let apiKey: string | null = null;
     if (url.pathname === "/sse" || url.pathname === "/message") {
       // Try schema-based validation first if available
       if (
         serverOptions.parameters?.schema &&
         req.method === "POST" &&
         req.headers["content-length"]
       ) {
         try {
           const body = await getRawBody(req, {
             length: req.headers["content-length"],
             encoding: "utf-8",
           });
           const params = JSON.parse(body);
           const result = serverOptions.parameters.schema.safeParse(params);
           if (result.success) {
             apiKey = result.data.apiKey;
           }
         } catch (error) {
           console.error("Error parsing parameters:", error);
         }
       }
 
       // If schema validation failed or not available, try headers
       if (!apiKey) {
         apiKey =
           (req.headers["x-meeting-baas-api-key"] as string) ||
           (req.headers["x-meetingbaas-apikey"] as string) ||
           (req.headers["x-api-key"] as string) ||
           (req.headers["authorization"] as string)?.replace(/bearer\s+/i, "") ||
           (process.env.NODE_ENV === "development"
             ? process.env.BAAS_API_KEY
             : null) ||
           null;
       }
 
-      // Authentication is optional, so we don't return an error if no API key is found
+      if (!apiKey) {
+        res.statusCode = 401;
+        res.end(
+          "Meeting BaaS API key is required in request body, x-meeting-baas-api-key, x-meetingbaas-apikey, x-api-key, or Authorization header"
+        );
+        return;
+      }
     }
 
     if (url.pathname === "/mcp") {
       if (req.method === "GET") {
         console.log("Received GET MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       if (req.method === "DELETE") {
         console.log("Received DELETE MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       console.log("Got new MCP connection", req.url, req.method);
 
       if (!statelessServer) {
         statelessServer = new McpServer(
           {
             name: "mcp-typescript server on vercel",
             version: "0.1.0",
           },
           serverOptions
         );
 
-        try {
-          initializeServer(statelessServer, apiKey || "");
-        } catch (error) {
-          console.error("Error initializing server:", error);
-          // Continue without failing - authentication is optional
-        }
+        initializeServer(statelessServer, apiKey || "");
         await statelessServer.connect(statelessTransport);
       }
       await statelessTransport.handleRequest(req, res);
     } else if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript server on vercel",
           version: "0.1.0",
         },
         serverOptions
       );
-
-      try {
-        initializeServer(server, apiKey || "");
-      } catch (error) {
-        console.error("Error initializing server:", error);
-        // Continue without failing - authentication is optional
-      }
+      initializeServer(server, apiKey || "");
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       // Handles messages originally received via /message
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b: unknown) => {
           body = b as string;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         await redisPublisher.publish(
           `responses:${sessionId}:${request.requestId}`,
           JSON.stringify({
             status,
             body,
           })
         );
 
         if (status >= 200 && status < 300) {
           logInContext(
             "log",
             `Request ${sessionId}:${request.requestId} succeeded: ${body}`
           );
         } else {
           logInContext(
             "error",
             `Message for ${sessionId}:${request.requestId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, (maxDuration - 5) * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# dedbfbe3d5b74d3cf5feefbfcb048db44fe2f7a1
#KEY#COMMIT_DATE# 2025-04-23 11:39:44 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# fix: check auth per req
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: 0b1f6e6a3a14762691e0a1de173725f5872524ce TO: dedbfbe3d5b74d3cf5feefbfcb048db44fe2f7a1
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index 5871ca6..9ca56dc 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,212 +1,211 @@
 import { ServerOptions as McpServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { Socket } from "net";
 import getRawBody from "raw-body";
 import { createClient } from "redis";
 import { Readable } from "stream";
 import z from "zod";
 import vercelJson from "../vercel.json";
 import { RedisClientType } from "redis";
 import { registerTools } from "../api/tools.js";
 
 interface ServerOptions extends McpServerOptions {
   parameters?: {
     schema: z.ZodSchema;
   };
 }
 
 interface SerializedRequest {
   requestId: string;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer, apiKey: string) => void,
   serverOptions: ServerOptions = {}
 ) {
   const maxDuration =
     vercelJson?.functions?.["api/server.ts"]?.maxDuration || 800;
   const redisUrl = process.env.REDIS_URL || process.env.KV_URL;
   if (!redisUrl) {
     throw new Error("REDIS_URL environment variable is not set");
   }
   const redis = createClient({
     url: redisUrl,
   });
   const redisPublisher = createClient({
     url: redisUrl,
   });
   redis.on("error", (err) => {
     console.error("Redis error", err);
   });
   redisPublisher.on("error", (err) => {
     console.error("Redis error", err);
   });
   const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 
   let servers: McpServer[] = [];
 
   let statelessServer: McpServer;
   const statelessTransport = new StreamableHTTPServerTransport({
     sessionIdGenerator: undefined,
   });
 
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://mcp.meetingbaas.com");
 
     // Skip validation for static files
     if (url.pathname.endsWith(".ico") || url.pathname.endsWith(".png")) {
       return;
     }
 
     // Only validate API key for SSE and chat endpoints
     let apiKey: string | null = null;
     if (url.pathname === "/sse" || url.pathname === "/message") {
       // Try schema-based validation first if available
       if (
         serverOptions.parameters?.schema &&
         req.method === "POST" &&
         req.headers["content-length"]
       ) {
         try {
           const body = await getRawBody(req, {
             length: req.headers["content-length"],
             encoding: "utf-8",
           });
           const params = JSON.parse(body);
           const result = serverOptions.parameters.schema.safeParse(params);
           if (result.success) {
             apiKey = result.data.apiKey;
           }
         } catch (error) {
           console.error("Error parsing parameters:", error);
         }
       }
 
       // If schema validation failed or not available, try headers
       if (!apiKey) {
         apiKey =
           (req.headers["x-meeting-baas-api-key"] as string) ||
-          (req.headers["x-meetingbaas-apikey"] as string) ||
           (req.headers["x-api-key"] as string) ||
-          (req.headers["authorization"] as string)?.replace(/bearer\s+/i, "") ||
+          (req.headers["authorization"] as string)?.replace("Bearer ", "") ||
           (process.env.NODE_ENV === "development"
             ? process.env.BAAS_API_KEY
             : null) ||
           null;
       }
 
       if (!apiKey) {
         res.statusCode = 401;
         res.end(
-          "Meeting BaaS API key is required in request body, x-meeting-baas-api-key, x-meetingbaas-apikey, x-api-key, or Authorization header"
+          "Meeting BaaS API key is required in request body, x-meeting-baas-api-key, x-api-key, or Authorization header"
         );
         return;
       }
     }
 
     if (url.pathname === "/mcp") {
       if (req.method === "GET") {
         console.log("Received GET MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       if (req.method === "DELETE") {
         console.log("Received DELETE MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       console.log("Got new MCP connection", req.url, req.method);
 
       if (!statelessServer) {
         statelessServer = new McpServer(
           {
             name: "mcp-typescript server on vercel",
             version: "0.1.0",
           },
           serverOptions
         );
 
         initializeServer(statelessServer, apiKey || "");
         await statelessServer.connect(statelessTransport);
       }
       await statelessTransport.handleRequest(req, res);
     } else if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript server on vercel",
           version: "0.1.0",
         },
         serverOptions
       );
       initializeServer(server, apiKey || "");
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       // Handles messages originally received via /message
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 0186a34c93cf0a1e41b7c0fb524651f6c50fac4c
#KEY#COMMIT_DATE# 2025-04-23 11:39:28 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# try fix
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/server.ts

#KEY#DIFF_RANGE# FROM: dedbfbe3d5b74d3cf5feefbfcb048db44fe2f7a1 TO: 0186a34c93cf0a1e41b7c0fb524651f6c50fac4c
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/server.ts b/api/server.ts
index 22a0843..f9bd1ef 100644
--- a/api/server.ts
+++ b/api/server.ts
@@ -1,62 +1,70 @@
+import z from "zod";
 import { initializeMcpApiHandler } from "../lib/mcp-api-handler";
 import registerTools from "./tools";
 
+const apiKeySchema = z.object({
+  apiKey: z.string().min(1, "API key is required"),
+});
+
 const handler = initializeMcpApiHandler(
   (server, apiKey) => {
     // Register Meeting BaaS SDK tools with the provided API key
     server = registerTools(server, apiKey);
   },
   {
+    parameters: {
+      schema: apiKeySchema,
+    },
     capabilities: {
       tools: {
         joinMeeting: {
           description: "Join's a meeting using the MeetingBaas api",
         },
         leaveMeeting: {
           description: "Leave a meeting using the MeetingBaas api",
         },
         getMeetingData: {
           description: "Get meeting data using the MeetingBaas api",
         },
         deleteData: {
           description: "Delete meeting data using the MeetingBaas api",
         },
         createCalendar: {
           description: "Create a calendar using the MeetingBaas api",
         },
         listCalendars: {
           description: "List calendars using the MeetingBaas api",
         },
         getCalendar: {
           description: "Get calendar using the MeetingBaas api",
         },
         deleteCalendar: {
           description: "Delete calendar using the MeetingBaas api",
         },
         resyncAllCalendars: {
           description: "Resync all calendars using the MeetingBaas api",
         },
         botsWithMetadata: {
           description: "Get bots with metadata using the MeetingBaas api",
         },
         listEvents: {
           description: "List events using the MeetingBaas api",
         },
         scheduleRecordEvent: {
           description: "Schedule a recording using the MeetingBaas api",
         },
         unscheduleRecordEvent: {
           description: "Unschedule a recording using the MeetingBaas api",
         },
         updateCalendar: {
           description: "Update calendar using the MeetingBaas api",
         },
         echo: {
           description: "Echo a message",
         },
       },
     },
   }
 );
 
 export default handler;
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 42490055bd8089df238b84ad42adb885869380f8
#KEY#COMMIT_DATE# 2025-04-23 11:37:46 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# refactor: simplify API key validation using headers
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: 0186a34c93cf0a1e41b7c0fb524651f6c50fac4c TO: 42490055bd8089df238b84ad42adb885869380f8
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index 9ca56dc..359fbab 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,211 +1,188 @@
 import { ServerOptions as McpServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { Socket } from "net";
 import getRawBody from "raw-body";
 import { createClient } from "redis";
 import { Readable } from "stream";
 import z from "zod";
 import vercelJson from "../vercel.json";
 import { RedisClientType } from "redis";
 import { registerTools } from "../api/tools.js";
 
 interface ServerOptions extends McpServerOptions {
   parameters?: {
     schema: z.ZodSchema;
   };
 }
 
 interface SerializedRequest {
   requestId: string;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer, apiKey: string) => void,
   serverOptions: ServerOptions = {}
 ) {
   const maxDuration =
     vercelJson?.functions?.["api/server.ts"]?.maxDuration || 800;
   const redisUrl = process.env.REDIS_URL || process.env.KV_URL;
   if (!redisUrl) {
     throw new Error("REDIS_URL environment variable is not set");
   }
   const redis = createClient({
     url: redisUrl,
   });
   const redisPublisher = createClient({
     url: redisUrl,
   });
   redis.on("error", (err) => {
     console.error("Redis error", err);
   });
   redisPublisher.on("error", (err) => {
     console.error("Redis error", err);
   });
   const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 
   let servers: McpServer[] = [];
 
   let statelessServer: McpServer;
   const statelessTransport = new StreamableHTTPServerTransport({
     sessionIdGenerator: undefined,
   });
 
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://mcp.meetingbaas.com");
 
     // Skip validation for static files
     if (url.pathname.endsWith(".ico") || url.pathname.endsWith(".png")) {
       return;
     }
 
     // Only validate API key for SSE and chat endpoints
     let apiKey: string | null = null;
     if (url.pathname === "/sse" || url.pathname === "/message") {
-      // Try schema-based validation first if available
-      if (
-        serverOptions.parameters?.schema &&
-        req.method === "POST" &&
-        req.headers["content-length"]
-      ) {
-        try {
-          const body = await getRawBody(req, {
-            length: req.headers["content-length"],
-            encoding: "utf-8",
-          });
-          const params = JSON.parse(body);
-          const result = serverOptions.parameters.schema.safeParse(params);
-          if (result.success) {
-            apiKey = result.data.apiKey;
-          }
-        } catch (error) {
-          console.error("Error parsing parameters:", error);
-        }
-      }
-
-      // If schema validation failed or not available, try headers
-      if (!apiKey) {
-        apiKey =
-          (req.headers["x-meeting-baas-api-key"] as string) ||
-          (req.headers["x-api-key"] as string) ||
-          (req.headers["authorization"] as string)?.replace("Bearer ", "") ||
-          (process.env.NODE_ENV === "development"
-            ? process.env.BAAS_API_KEY
-            : null) ||
-          null;
-      }
+      // Check for API key in headers first, then fall back to environment variable in dev mode
+      apiKey =
+        (req.headers["x-meeting-baas-api-key"] as string) ||
+        (req.headers["x-api-key"] as string) ||
+        (req.headers["authorization"] as string)?.replace("Bearer ", "") ||
+        (process.env.NODE_ENV === "development"
+          ? process.env.BAAS_API_KEY
+          : null) ||
+        null;
 
       if (!apiKey) {
         res.statusCode = 401;
         res.end(
-          "Meeting BaaS API key is required in request body, x-meeting-baas-api-key, x-api-key, or Authorization header"
+          "Meeting BaaS API key is required in x-meeting-baas-api-key, x-api-key, or Authorization header"
         );
         return;
       }
     }
 
     if (url.pathname === "/mcp") {
       if (req.method === "GET") {
         console.log("Received GET MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       if (req.method === "DELETE") {
         console.log("Received DELETE MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       console.log("Got new MCP connection", req.url, req.method);
 
       if (!statelessServer) {
         statelessServer = new McpServer(
           {
             name: "mcp-typescript server on vercel",
             version: "0.1.0",
           },
           serverOptions
         );
 
         initializeServer(statelessServer, apiKey || "");
         await statelessServer.connect(statelessTransport);
       }
       await statelessTransport.handleRequest(req, res);
     } else if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript server on vercel",
           version: "0.1.0",
         },
         serverOptions
       );
       initializeServer(server, apiKey || "");
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       // Handles messages originally received via /message
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 20fff2e3fad153104c425642e1700ba336f3816f
#KEY#COMMIT_DATE# 2025-04-23 11:36:08 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# feat: add schema-based API key validation
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: 42490055bd8089df238b84ad42adb885869380f8 TO: 20fff2e3fad153104c425642e1700ba336f3816f
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index 359fbab..d10fb0b 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,250 +1,270 @@
 import { ServerOptions as McpServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { Socket } from "net";
 import getRawBody from "raw-body";
 import { createClient } from "redis";
 import { Readable } from "stream";
 import z from "zod";
 import vercelJson from "../vercel.json";
 import { RedisClientType } from "redis";
 import { registerTools } from "../api/tools.js";
 
 interface ServerOptions extends McpServerOptions {
   parameters?: {
     schema: z.ZodSchema;
   };
 }
 
 interface SerializedRequest {
   requestId: string;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer, apiKey: string) => void,
   serverOptions: ServerOptions = {}
 ) {
   const maxDuration =
     vercelJson?.functions?.["api/server.ts"]?.maxDuration || 800;
   const redisUrl = process.env.REDIS_URL || process.env.KV_URL;
   if (!redisUrl) {
     throw new Error("REDIS_URL environment variable is not set");
   }
   const redis = createClient({
     url: redisUrl,
   });
   const redisPublisher = createClient({
     url: redisUrl,
   });
   redis.on("error", (err) => {
     console.error("Redis error", err);
   });
   redisPublisher.on("error", (err) => {
     console.error("Redis error", err);
   });
   const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 
   let servers: McpServer[] = [];
 
   let statelessServer: McpServer;
   const statelessTransport = new StreamableHTTPServerTransport({
     sessionIdGenerator: undefined,
   });
 
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
-    const url = new URL(req.url || "", "https://mcp.meetingbaas.com");
-
-    // Skip validation for static files
-    if (url.pathname.endsWith(".ico") || url.pathname.endsWith(".png")) {
-      return;
-    }
-
-    // Only validate API key for SSE and chat endpoints
-    let apiKey: string | null = null;
-    if (url.pathname === "/sse" || url.pathname === "/message") {
-      // Check for API key in headers first, then fall back to environment variable in dev mode
-      apiKey =
-        (req.headers["x-meeting-baas-api-key"] as string) ||
-        (req.headers["x-api-key"] as string) ||
-        (req.headers["authorization"] as string)?.replace("Bearer ", "") ||
-        (process.env.NODE_ENV === "development"
-          ? process.env.BAAS_API_KEY
-          : null) ||
-        null;
-
-      if (!apiKey) {
-        res.statusCode = 401;
-        res.end(
-          "Meeting BaaS API key is required in x-meeting-baas-api-key, x-api-key, or Authorization header"
-        );
-        return;
-      }
-    }
-
+    const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/mcp") {
       if (req.method === "GET") {
         console.log("Received GET MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       if (req.method === "DELETE") {
         console.log("Received DELETE MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       console.log("Got new MCP connection", req.url, req.method);
 
+      // Get API key from parameters schema if available
+      let apiKey: string | null = null;
+      if (serverOptions.parameters?.schema) {
+        try {
+          const body = await getRawBody(req, {
+            length: req.headers["content-length"],
+            encoding: "utf-8",
+          });
+          const params = JSON.parse(body);
+          const result = serverOptions.parameters.schema.safeParse(params);
+          if (result.success) {
+            apiKey = result.data.apiKey;
+          }
+        } catch (error) {
+          console.error("Error parsing parameters:", error);
+        }
+      }
+
+      if (!apiKey) {
+        res.statusCode = 401;
+        res.end("Meeting BaaS API key is required");
+        return;
+      }
+
       if (!statelessServer) {
         statelessServer = new McpServer(
           {
             name: "mcp-typescript server on vercel",
             version: "0.1.0",
           },
           serverOptions
         );
 
-        initializeServer(statelessServer, apiKey || "");
+        initializeServer(statelessServer, apiKey);
         await statelessServer.connect(statelessTransport);
       }
       await statelessTransport.handleRequest(req, res);
     } else if (url.pathname === "/sse") {
+      // Get API key from parameters schema if available
+      let apiKey: string | null = null;
+      if (serverOptions.parameters?.schema) {
+        try {
+          const body = await getRawBody(req, {
+            length: req.headers["content-length"],
+            encoding: "utf-8",
+          });
+          const params = JSON.parse(body);
+          const result = serverOptions.parameters.schema.safeParse(params);
+          if (result.success) {
+            apiKey = result.data.apiKey;
+          }
+        } catch (error) {
+          console.error("Error parsing parameters:", error);
+        }
+      }
+
+      if (!apiKey) {
+        res.statusCode = 401;
+        res.end("Meeting BaaS API key is required");
+        return;
+      }
+
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript server on vercel",
           version: "0.1.0",
         },
         serverOptions
       );
-      initializeServer(server, apiKey || "");
+      initializeServer(server, apiKey);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       // Handles messages originally received via /message
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b: unknown) => {
           body = b as string;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         await redisPublisher.publish(
           `responses:${sessionId}:${request.requestId}`,
           JSON.stringify({
             status,
             body,
           })
         );
 
         if (status >= 200 && status < 300) {
           logInContext(
             "log",
             `Request ${sessionId}:${request.requestId} succeeded: ${body}`
           );
         } else {
           logInContext(
             "error",
             `Message for ${sessionId}:${request.requestId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, (maxDuration - 5) * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 34433c78ebaca9c8e98f7bcc1ef1cfb7e7530223
#KEY#COMMIT_DATE# 2025-04-23 11:35:30 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE#  revert the API key check from headers to query parameter
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/server.ts
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: 20fff2e3fad153104c425642e1700ba336f3816f TO: 34433c78ebaca9c8e98f7bcc1ef1cfb7e7530223
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/server.ts b/api/server.ts
index f9bd1ef..22a0843 100644
--- a/api/server.ts
+++ b/api/server.ts
@@ -1,70 +1,62 @@
-import z from "zod";
 import { initializeMcpApiHandler } from "../lib/mcp-api-handler";
 import registerTools from "./tools";
 
-const apiKeySchema = z.object({
-  apiKey: z.string().min(1, "API key is required"),
-});
-
 const handler = initializeMcpApiHandler(
   (server, apiKey) => {
     // Register Meeting BaaS SDK tools with the provided API key
     server = registerTools(server, apiKey);
   },
   {
-    parameters: {
-      schema: apiKeySchema,
-    },
     capabilities: {
       tools: {
         joinMeeting: {
           description: "Join's a meeting using the MeetingBaas api",
         },
         leaveMeeting: {
           description: "Leave a meeting using the MeetingBaas api",
         },
         getMeetingData: {
           description: "Get meeting data using the MeetingBaas api",
         },
         deleteData: {
           description: "Delete meeting data using the MeetingBaas api",
         },
         createCalendar: {
           description: "Create a calendar using the MeetingBaas api",
         },
         listCalendars: {
           description: "List calendars using the MeetingBaas api",
         },
         getCalendar: {
           description: "Get calendar using the MeetingBaas api",
         },
         deleteCalendar: {
           description: "Delete calendar using the MeetingBaas api",
         },
         resyncAllCalendars: {
           description: "Resync all calendars using the MeetingBaas api",
         },
         botsWithMetadata: {
           description: "Get bots with metadata using the MeetingBaas api",
         },
         listEvents: {
           description: "List events using the MeetingBaas api",
         },
         scheduleRecordEvent: {
           description: "Schedule a recording using the MeetingBaas api",
         },
         unscheduleRecordEvent: {
           description: "Unschedule a recording using the MeetingBaas api",
         },
         updateCalendar: {
           description: "Update calendar using the MeetingBaas api",
         },
         echo: {
           description: "Echo a message",
         },
       },
     },
   }
 );
 
 export default handler;
diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index d10fb0b..7d62966 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,252 +1,213 @@
-import { ServerOptions as McpServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
+import { ServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { Socket } from "net";
 import getRawBody from "raw-body";
 import { createClient } from "redis";
 import { Readable } from "stream";
-import z from "zod";
 import vercelJson from "../vercel.json";
 import { RedisClientType } from "redis";
 import { registerTools } from "../api/tools.js";
 
-interface ServerOptions extends McpServerOptions {
-  parameters?: {
-    schema: z.ZodSchema;
-  };
-}
-
 interface SerializedRequest {
   requestId: string;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer, apiKey: string) => void,
   serverOptions: ServerOptions = {}
 ) {
   const maxDuration =
     vercelJson?.functions?.["api/server.ts"]?.maxDuration || 800;
   const redisUrl = process.env.REDIS_URL || process.env.KV_URL;
   if (!redisUrl) {
     throw new Error("REDIS_URL environment variable is not set");
   }
   const redis = createClient({
     url: redisUrl,
   });
   const redisPublisher = createClient({
     url: redisUrl,
   });
   redis.on("error", (err) => {
     console.error("Redis error", err);
   });
   redisPublisher.on("error", (err) => {
     console.error("Redis error", err);
   });
   const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 
   let servers: McpServer[] = [];
 
   let statelessServer: McpServer;
   const statelessTransport = new StreamableHTTPServerTransport({
     sessionIdGenerator: undefined,
   });
 
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/mcp") {
       if (req.method === "GET") {
         console.log("Received GET MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       if (req.method === "DELETE") {
         console.log("Received DELETE MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       console.log("Got new MCP connection", req.url, req.method);
 
-      // Get API key from parameters schema if available
-      let apiKey: string | null = null;
-      if (serverOptions.parameters?.schema) {
-        try {
-          const body = await getRawBody(req, {
-            length: req.headers["content-length"],
-            encoding: "utf-8",
-          });
-          const params = JSON.parse(body);
-          const result = serverOptions.parameters.schema.safeParse(params);
-          if (result.success) {
-            apiKey = result.data.apiKey;
-          }
-        } catch (error) {
-          console.error("Error parsing parameters:", error);
-        }
-      }
-
-      if (!apiKey) {
-        res.statusCode = 401;
-        res.end("Meeting BaaS API key is required");
-        return;
-      }
-
       if (!statelessServer) {
         statelessServer = new McpServer(
           {
             name: "mcp-typescript server on vercel",
             version: "0.1.0",
           },
           serverOptions
         );
 
+        // Get API key from query parameters
+        const apiKey = url.searchParams.get("apiKey");
+        if (!apiKey) {
+          res.statusCode = 401;
+          res.end("Meeting BaaS API key is required");
+          return;
+        }
+
         initializeServer(statelessServer, apiKey);
         await statelessServer.connect(statelessTransport);
       }
       await statelessTransport.handleRequest(req, res);
     } else if (url.pathname === "/sse") {
-      // Get API key from parameters schema if available
-      let apiKey: string | null = null;
-      if (serverOptions.parameters?.schema) {
-        try {
-          const body = await getRawBody(req, {
-            length: req.headers["content-length"],
-            encoding: "utf-8",
-          });
-          const params = JSON.parse(body);
-          const result = serverOptions.parameters.schema.safeParse(params);
-          if (result.success) {
-            apiKey = result.data.apiKey;
-          }
-        } catch (error) {
-          console.error("Error parsing parameters:", error);
-        }
-      }
-
+      // Get API key from query parameters
+      const apiKey = url.searchParams.get("apiKey");
       if (!apiKey) {
         res.statusCode = 401;
         res.end("Meeting BaaS API key is required");
         return;
       }
 
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript server on vercel",
           version: "0.1.0",
         },
         serverOptions
       );
       initializeServer(server, apiKey);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       // Handles messages originally received via /message
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b: unknown) => {
           body = b as string;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         await redisPublisher.publish(
           `responses:${sessionId}:${request.requestId}`,
           JSON.stringify({
             status,
             body,
           })
         );
 
         if (status >= 200 && status < 300) {
           logInContext(
             "log",
             `Request ${sessionId}:${request.requestId} succeeded: ${body}`
           );
         } else {
           logInContext(
             "error",
             `Message for ${sessionId}:${request.requestId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 2469eec4a0ca5998f150bd7ed152683a222983e0
#KEY#COMMIT_DATE# 2025-04-23 11:34:42 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# refactor: improve API key handling and type definitions
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: 34433c78ebaca9c8e98f7bcc1ef1cfb7e7530223 TO: 2469eec4a0ca5998f150bd7ed152683a222983e0
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index 7d62966..bfbbc0c 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,213 +1,213 @@
 import { ServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { Socket } from "net";
 import getRawBody from "raw-body";
 import { createClient } from "redis";
 import { Readable } from "stream";
 import vercelJson from "../vercel.json";
 import { RedisClientType } from "redis";
 import { registerTools } from "../api/tools.js";
 
 interface SerializedRequest {
   requestId: string;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer, apiKey: string) => void,
   serverOptions: ServerOptions = {}
 ) {
   const maxDuration =
     vercelJson?.functions?.["api/server.ts"]?.maxDuration || 800;
   const redisUrl = process.env.REDIS_URL || process.env.KV_URL;
   if (!redisUrl) {
     throw new Error("REDIS_URL environment variable is not set");
   }
   const redis = createClient({
     url: redisUrl,
   });
   const redisPublisher = createClient({
     url: redisUrl,
   });
   redis.on("error", (err) => {
     console.error("Redis error", err);
   });
   redisPublisher.on("error", (err) => {
     console.error("Redis error", err);
   });
   const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 
   let servers: McpServer[] = [];
 
   let statelessServer: McpServer;
   const statelessTransport = new StreamableHTTPServerTransport({
     sessionIdGenerator: undefined,
   });
 
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/mcp") {
       if (req.method === "GET") {
         console.log("Received GET MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       if (req.method === "DELETE") {
         console.log("Received DELETE MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       console.log("Got new MCP connection", req.url, req.method);
 
       if (!statelessServer) {
         statelessServer = new McpServer(
           {
             name: "mcp-typescript server on vercel",
             version: "0.1.0",
           },
           serverOptions
         );
 
-        // Get API key from query parameters
-        const apiKey = url.searchParams.get("apiKey");
+        // Get API key from headers for MCP connection
+        const apiKey = req.headers["x-meeting-baas-api-key"] as string;
         if (!apiKey) {
           res.statusCode = 401;
           res.end("Meeting BaaS API key is required");
           return;
         }
 
         initializeServer(statelessServer, apiKey);
         await statelessServer.connect(statelessTransport);
       }
       await statelessTransport.handleRequest(req, res);
     } else if (url.pathname === "/sse") {
-      // Get API key from query parameters
-      const apiKey = url.searchParams.get("apiKey");
+      // Get API key from headers
+      const apiKey = req.headers["x-meeting-baas-api-key"] as string;
       if (!apiKey) {
         res.statusCode = 401;
         res.end("Meeting BaaS API key is required");
         return;
       }
 
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript server on vercel",
           version: "0.1.0",
         },
         serverOptions
       );
       initializeServer(server, apiKey);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       // Handles messages originally received via /message
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b: unknown) => {
           body = b as string;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         await redisPublisher.publish(
           `responses:${sessionId}:${request.requestId}`,
           JSON.stringify({
             status,
             body,
           })
         );
 
         if (status >= 200 && status < 300) {
           logInContext(
             "log",
             `Request ${sessionId}:${request.requestId} succeeded: ${body}`
           );
         } else {
           logInContext(
             "error",
             `Message for ${sessionId}:${request.requestId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# ee552d3943306535656a22d02be834235f8406c4
#KEY#COMMIT_DATE# 2025-04-23 11:32:41 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# fix compil
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/server.ts
- api/tools.ts
- lib/mcp-api-handler.ts
- package.json

#KEY#DIFF_RANGE# FROM: 2469eec4a0ca5998f150bd7ed152683a222983e0 TO: ee552d3943306535656a22d02be834235f8406c4
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/server.ts b/api/server.ts
index 22a0843..e2c47d9 100644
--- a/api/server.ts
+++ b/api/server.ts
@@ -1,62 +1,67 @@
+import { BaasClient } from "@meeting-baas/sdk";
 import { initializeMcpApiHandler } from "../lib/mcp-api-handler";
 import registerTools from "./tools";
 
 const handler = initializeMcpApiHandler(
-  (server, apiKey) => {
-    // Register Meeting BaaS SDK tools with the provided API key
-    server = registerTools(server, apiKey);
+  (server) => {
+    const baasClient = new BaasClient({
+      apiKey: process.env.BAAS_API_KEY || "",
+    });
+
+    // Register Meeting BaaS SDK tools
+    server = registerTools(server);
   },
   {
     capabilities: {
       tools: {
         joinMeeting: {
           description: "Join's a meeting using the MeetingBaas api",
         },
         leaveMeeting: {
           description: "Leave a meeting using the MeetingBaas api",
         },
         getMeetingData: {
           description: "Get meeting data using the MeetingBaas api",
         },
         deleteData: {
           description: "Delete meeting data using the MeetingBaas api",
         },
         createCalendar: {
           description: "Create a calendar using the MeetingBaas api",
         },
         listCalendars: {
           description: "List calendars using the MeetingBaas api",
         },
         getCalendar: {
           description: "Get calendar using the MeetingBaas api",
         },
         deleteCalendar: {
           description: "Delete calendar using the MeetingBaas api",
         },
         resyncAllCalendars: {
           description: "Resync all calendars using the MeetingBaas api",
         },
         botsWithMetadata: {
           description: "Get bots with metadata using the MeetingBaas api",
         },
         listEvents: {
           description: "List events using the MeetingBaas api",
         },
         scheduleRecordEvent: {
           description: "Schedule a recording using the MeetingBaas api",
         },
         unscheduleRecordEvent: {
           description: "Unschedule a recording using the MeetingBaas api",
         },
         updateCalendar: {
           description: "Update calendar using the MeetingBaas api",
         },
         echo: {
           description: "Echo a message",
         },
       },
     },
   }
 );
 
 export default handler;
diff --git a/api/tools.ts b/api/tools.ts
index d9cd64c..fed1a62 100644
--- a/api/tools.ts
+++ b/api/tools.ts
@@ -1,107 +1,107 @@
 import { BaasClient } from "@meeting-baas/sdk";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import z from "zod";
 
-export function registerTools(server: McpServer, apiKey: string): McpServer {
+export function registerTools(server: McpServer): McpServer {
   const baasClient = new BaasClient({
-    apiKey: apiKey,
+    apiKey: process.env.BAAS_API_KEY || "",
   });
 
   // Register Meeting BaaS SDK tools
   server.tool(
     "joinMeeting",
     "Send an AI bot to join a video meeting. The bot can record the meeting, transcribe speech, and provide real-time audio streams. Use this when you want to: 1) Record a meeting 2) Get meeting transcriptions 3) Stream meeting audio 4) Monitor meeting attendance",
     {
       meetingUrl: z.string(),
       botName: z.string(),
       webhookUrl: z.string().optional(),
       recordingMode: z.string().optional(),
       speechToText: z.boolean().optional(),
       reserved: z.boolean(),
     },
     async ({
       meetingUrl,
       botName,
       webhookUrl,
       recordingMode,
       speechToText,
       reserved,
     }: {
       meetingUrl: string;
       botName: string;
       webhookUrl?: string;
       recordingMode?: string;
       speechToText?: boolean;
       reserved: boolean;
     }) => {
       try {
         const botId = await baasClient.joinMeeting({
           meetingUrl,
           botName,
           webhookUrl,
           recordingMode,
           speechToText: speechToText ? { provider: "Default" } : undefined,
           reserved,
         });
         return {
           content: [
             {
               type: "text",
               text: `Successfully joined meeting with bot ID: ${botId}`,
             },
           ],
         };
       } catch (error) {
         console.error("Failed to join meeting:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to join meeting",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   server.tool(
     "leaveMeeting",
     "Remove an AI bot from a meeting. Use this when you want to: 1) End a meeting recording 2) Stop transcription 3) Disconnect the bot from the meeting",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         const success = await baasClient.leaveMeeting(botId);
         return {
           content: [
             {
               type: "text",
               text: success
                 ? "Successfully left meeting"
                 : "Failed to leave meeting",
             },
           ],
         };
       } catch (error) {
         console.error("Failed to leave meeting:", error);
         return {
           content: [
             {
               type: "text",
               text: "Failed to leave meeting",
             },
           ],
           isError: true,
         };
       }
     }
   );
 
   server.tool(
     "getMeetingData",
     "Get all data from a meeting including recording, transcript, and metadata. Use this when you want to: 1) Search through meeting transcripts 2) Get meeting recordings 3) Review meeting details 4) Access speaker information",
     { botId: z.string() },
     async ({ botId }: { botId: string }) => {
       try {
         const data = await baasClient.getMeetingData(botId);
diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index bfbbc0c..028dda2 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,231 +1,213 @@
 import { ServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
 import { Socket } from "net";
 import getRawBody from "raw-body";
 import { createClient } from "redis";
 import { Readable } from "stream";
 import vercelJson from "../vercel.json";
-import { RedisClientType } from "redis";
-import { registerTools } from "../api/tools.js";
 
 interface SerializedRequest {
   requestId: string;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 export function initializeMcpApiHandler(
-  initializeServer: (server: McpServer, apiKey: string) => void,
+  initializeServer: (server: McpServer) => void,
   serverOptions: ServerOptions = {}
 ) {
   const maxDuration =
     vercelJson?.functions?.["api/server.ts"]?.maxDuration || 800;
   const redisUrl = process.env.REDIS_URL || process.env.KV_URL;
   if (!redisUrl) {
     throw new Error("REDIS_URL environment variable is not set");
   }
   const redis = createClient({
     url: redisUrl,
   });
   const redisPublisher = createClient({
     url: redisUrl,
   });
   redis.on("error", (err) => {
     console.error("Redis error", err);
   });
   redisPublisher.on("error", (err) => {
     console.error("Redis error", err);
   });
   const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 
   let servers: McpServer[] = [];
 
   let statelessServer: McpServer;
   const statelessTransport = new StreamableHTTPServerTransport({
     sessionIdGenerator: undefined,
   });
 
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/mcp") {
       if (req.method === "GET") {
         console.log("Received GET MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       if (req.method === "DELETE") {
         console.log("Received DELETE MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       console.log("Got new MCP connection", req.url, req.method);
 
       if (!statelessServer) {
         statelessServer = new McpServer(
           {
             name: "mcp-typescript server on vercel",
             version: "0.1.0",
           },
           serverOptions
         );
 
-        // Get API key from headers for MCP connection
-        const apiKey = req.headers["x-meeting-baas-api-key"] as string;
-        if (!apiKey) {
-          res.statusCode = 401;
-          res.end("Meeting BaaS API key is required");
-          return;
-        }
-
-        initializeServer(statelessServer, apiKey);
+        initializeServer(statelessServer);
         await statelessServer.connect(statelessTransport);
       }
       await statelessTransport.handleRequest(req, res);
     } else if (url.pathname === "/sse") {
-      // Get API key from headers
-      const apiKey = req.headers["x-meeting-baas-api-key"] as string;
-      if (!apiKey) {
-        res.statusCode = 401;
-        res.end("Meeting BaaS API key is required");
-        return;
-      }
-
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript server on vercel",
           version: "0.1.0",
         },
         serverOptions
       );
-      initializeServer(server, apiKey);
+      initializeServer(server);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       // Handles messages originally received via /message
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b: unknown) => {
           body = b as string;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         await redisPublisher.publish(
           `responses:${sessionId}:${request.requestId}`,
           JSON.stringify({
             status,
             body,
           })
         );
 
         if (status >= 200 && status < 300) {
           logInContext(
             "log",
             `Request ${sessionId}:${request.requestId} succeeded: ${body}`
           );
         } else {
           logInContext(
             "error",
             `Message for ${sessionId}:${request.requestId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, (maxDuration - 5) * 1000);
       });
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
diff --git a/package.json b/package.json
index 90be9ef..e30a78c 100644
--- a/package.json
+++ b/package.json
@@ -1,30 +1,30 @@
 {
   "name": "meetingbaas-mcp",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
     "build": "tsc",
     "build:watch": "tsc --watch",
     "start": "node -r dotenv/config dist/api/server.js",
     "dev": "tsc --watch & node -r dotenv/config dist/api/server.js"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
     "@meeting-baas/sdk": "^0.2.4",
     "@modelcontextprotocol/sdk": "^1.6.1",
     "content-type": "^1.0.5",
     "dotenv": "^16.4.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
-    "@types/node": "^20.11.24",
+    "@types/node": "^22.13.10",
     "typescript": "^5.3.3"
   }
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 18aa4cc5d60efde669ab04c1a271c9d75b164e73
#KEY#COMMIT_DATE# 2025-04-23 11:32:41 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# refactor: move tools to separate file and add TypeScript setup
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: ee552d3943306535656a22d02be834235f8406c4 TO: 18aa4cc5d60efde669ab04c1a271c9d75b164e73
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index 028dda2..6f89b42 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,109 +1,109 @@
-import { ServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
+import getRawBody from "raw-body";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
-import { Socket } from "net";
-import getRawBody from "raw-body";
 import { createClient } from "redis";
+import { Socket } from "net";
 import { Readable } from "stream";
+import { ServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
 import vercelJson from "../vercel.json";
 
 interface SerializedRequest {
   requestId: string;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer) => void,
   serverOptions: ServerOptions = {}
 ) {
   const maxDuration =
     vercelJson?.functions?.["api/server.ts"]?.maxDuration || 800;
   const redisUrl = process.env.REDIS_URL || process.env.KV_URL;
   if (!redisUrl) {
     throw new Error("REDIS_URL environment variable is not set");
   }
   const redis = createClient({
     url: redisUrl,
   });
   const redisPublisher = createClient({
     url: redisUrl,
   });
   redis.on("error", (err) => {
     console.error("Redis error", err);
   });
   redisPublisher.on("error", (err) => {
     console.error("Redis error", err);
   });
   const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 
   let servers: McpServer[] = [];
 
   let statelessServer: McpServer;
   const statelessTransport = new StreamableHTTPServerTransport({
     sessionIdGenerator: undefined,
   });
 
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/mcp") {
       if (req.method === "GET") {
         console.log("Received GET MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       if (req.method === "DELETE") {
         console.log("Received DELETE MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       console.log("Got new MCP connection", req.url, req.method);
 
       if (!statelessServer) {
         statelessServer = new McpServer(
           {
             name: "mcp-typescript server on vercel",
             version: "0.1.0",
           },
           serverOptions
         );
 
         initializeServer(statelessServer);
         await statelessServer.connect(statelessTransport);
       }
       await statelessTransport.handleRequest(req, res);
     } else if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript server on vercel",
           version: "0.1.0",
@@ -200,130 +200,130 @@ export function initializeMcpApiHandler(
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
       const requestId = crypto.randomUUID();
       const serializedRequest: SerializedRequest = {
         requestId,
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Handles responses from the /sse endpoint.
       await redis.subscribe(
         `responses:${sessionId}:${requestId}`,
         (message) => {
           clearTimeout(timeout);
           const response = JSON.parse(message) as {
             status: number;
             body: string;
           };
           res.statusCode = response.status;
           res.end(response.body);
         }
       );
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await redisPublisher.publish(
         `requests:${sessionId}`,
         JSON.stringify(serializedRequest)
       );
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
       let timeout = setTimeout(async () => {
         await redis.unsubscribe(`responses:${sessionId}:${requestId}`);
         res.statusCode = 408;
         res.end("Request timed out");
       }, 10 * 1000);
 
       res.on("close", async () => {
         clearTimeout(timeout);
         await redis.unsubscribe(`responses:${sessionId}:${requestId}`);
       });
     } else {
       res.statusCode = 404;
       res.end("Not found");
     }
   };
 }
 
 // Define the options interface
 interface FakeIncomingMessageOptions {
   method?: string;
   url?: string;
   headers?: IncomingHttpHeaders;
   body?: string | Buffer | Record<string, any> | null;
   socket?: Socket;
 }
 
 // Create a fake IncomingMessage
 function createFakeIncomingMessage(
   options: FakeIncomingMessageOptions = {}
 ): IncomingMessage {
   const {
     method = "GET",
     url = "/",
     headers = {},
     body = null,
     socket = new Socket(),
   } = options;
 
   // Create a readable stream that will be used as the base for IncomingMessage
   const readable = new Readable();
-  readable._read = (): void => {}; // Required implementation
+  readable._read = (): void => { }; // Required implementation
 
   // Add the body content if provided
   if (body) {
     if (typeof body === "string") {
       readable.push(body);
     } else if (Buffer.isBuffer(body)) {
       readable.push(body);
     } else {
       readable.push(JSON.stringify(body));
     }
     readable.push(null); // Signal the end of the stream
   }
 
   // Create the IncomingMessage instance
   const req = new IncomingMessage(socket);
 
   // Set the properties
   req.method = method;
   req.url = url;
   req.headers = headers;
 
   // Copy over the stream methods
   req.push = readable.push.bind(readable);
   req.read = readable.read.bind(readable);
-  req.on = readable.on.bind(readable) as IncomingMessage["on"];
+  req.on = readable.on.bind(readable);
   req.pipe = readable.pipe.bind(readable);
 
   return req;
-}
+}
\ No newline at end of file
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 0a4825094385cfba0a45fc74c03b0106f619b862
#KEY#COMMIT_DATE# 2025-04-23 11:32:41 +0200
#KEY#COMMIT_AUTHOR# Anirudh
#KEY#COMMIT_MESSAGE# fix: docs
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/server.ts
- api/tools.ts
- package.json
- tsconfig.json

#KEY#DIFF_RANGE# FROM: 18aa4cc5d60efde669ab04c1a271c9d75b164e73 TO: 0a4825094385cfba0a45fc74c03b0106f619b862
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/server.ts b/api/server.ts
index e2c47d9..6ae9009 100644
--- a/api/server.ts
+++ b/api/server.ts
@@ -1,67 +1,641 @@
 import { BaasClient } from "@meeting-baas/sdk";
+import { z } from "zod";
 import { initializeMcpApiHandler } from "../lib/mcp-api-handler";
-import registerTools from "./tools";
 
 const handler = initializeMcpApiHandler(
   (server) => {
     const baasClient = new BaasClient({
       apiKey: process.env.BAAS_API_KEY || "",
     });
 
     // Register Meeting BaaS SDK tools
-    server = registerTools(server);
+    server.tool(
+      "joinMeeting",
+      "Send an AI bot to join a video meeting. The bot can record the meeting, transcribe speech, and provide real-time audio streams. Use this when you want to: 1) Record a meeting 2) Get meeting transcriptions 3) Stream meeting audio 4) Monitor meeting attendance",
+      {
+        meetingUrl: z.string(),
+        botName: z.string(),
+        webhookUrl: z.string().optional(),
+        recordingMode: z.string().optional(),
+        speechToText: z.boolean().optional(),
+        reserved: z.boolean(),
+      },
+      async ({
+        meetingUrl,
+        botName,
+        webhookUrl,
+        recordingMode,
+        speechToText,
+        reserved,
+      }: {
+        meetingUrl: string;
+        botName: string;
+        webhookUrl?: string;
+        recordingMode?: string;
+        speechToText?: boolean;
+        reserved: boolean;
+      }) => {
+        try {
+          const botId = await baasClient.joinMeeting({
+            meetingUrl,
+            botName,
+            webhookUrl,
+            recordingMode,
+            speechToText: speechToText ? { provider: "Default" } : undefined,
+            reserved,
+          });
+          return {
+            content: [
+              {
+                type: "text",
+                text: `Successfully joined meeting with bot ID: ${botId}`,
+              },
+            ],
+          };
+        } catch (error) {
+          console.error("Failed to join meeting:", error);
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Failed to join meeting",
+              },
+            ],
+            isError: true,
+          };
+        }
+      }
+    );
+
+    server.tool(
+      "leaveMeeting",
+      "Remove an AI bot from a meeting. Use this when you want to: 1) End a meeting recording 2) Stop transcription 3) Disconnect the bot from the meeting",
+      { botId: z.string() },
+      async ({ botId }: { botId: string }) => {
+        try {
+          const success = await baasClient.leaveMeeting(botId);
+          return {
+            content: [
+              {
+                type: "text",
+                text: success
+                  ? "Successfully left meeting"
+                  : "Failed to leave meeting",
+              },
+            ],
+          };
+        } catch (error) {
+          console.error("Failed to leave meeting:", error);
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Failed to leave meeting",
+              },
+            ],
+            isError: true,
+          };
+        }
+      }
+    );
+
+    server.tool(
+      "getMeetingData",
+      "Get all data from a meeting including recording, transcript, and metadata. Use this when you want to: 1) Search through meeting transcripts 2) Get meeting recordings 3) Review meeting details 4) Access speaker information",
+      { botId: z.string() },
+      async ({ botId }: { botId: string }) => {
+        try {
+          const data = await baasClient.getMeetingData(botId);
+          return {
+            content: [
+              {
+                type: "text",
+                text: JSON.stringify(data, null, 2),
+              },
+            ],
+          };
+        } catch (error) {
+          console.error("Failed to get meeting data:", error);
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Failed to get meeting data",
+              },
+            ],
+            isError: true,
+          };
+        }
+      }
+    );
+
+    server.tool(
+      "deleteData",
+      "Delete all data from a meeting including recording, transcript, and logs. Use this when you want to: 1) Remove sensitive meeting data 2) Clear meeting recordings 3) Delete transcripts 4) Free up storage space",
+      { botId: z.string() },
+      async ({ botId }: { botId: string }) => {
+        try {
+          const result = await baasClient.deleteData(botId);
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Successfully deleted meeting data",
+              },
+            ],
+          };
+        } catch (error) {
+          console.error("Failed to delete data:", error);
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Failed to delete meeting data",
+              },
+            ],
+            isError: true,
+          };
+        }
+      }
+    );
+
+    server.tool(
+      "createCalendar",
+      "Connect a Google or Microsoft calendar to Meeting BaaS. Use this when you want to: 1) Link your work calendar 2) Enable automatic meeting recordings 3) Schedule bots for future meetings 4) Sync your calendar events",
+      {
+        oauthClientId: z.string(),
+        oauthClientSecret: z.string(),
+        oauthRefreshToken: z.string(),
+        platform: z.enum(["Google", "Microsoft"]),
+        rawCalendarId: z.string(),
+      },
+      async ({
+        oauthClientId,
+        oauthClientSecret,
+        oauthRefreshToken,
+        platform,
+        rawCalendarId,
+      }: {
+        oauthClientId: string;
+        oauthClientSecret: string;
+        oauthRefreshToken: string;
+        platform: "Google" | "Microsoft";
+        rawCalendarId: string;
+      }) => {
+        try {
+          const calendar = await baasClient.createCalendar({
+            oauthClientId,
+            oauthClientSecret,
+            oauthRefreshToken,
+            platform: platform === "Google" ? "Google" : "Microsoft",
+            rawCalendarId,
+          });
+          return {
+            content: [
+              {
+                type: "text",
+                text: `Successfully created calendar: ${JSON.stringify(
+                  calendar,
+                  null,
+                  2
+                )}`,
+              },
+            ],
+          };
+        } catch (error) {
+          console.error("Failed to create calendar:", error);
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Failed to create calendar",
+              },
+            ],
+            isError: true,
+          };
+        }
+      }
+    );
+
+    server.tool(
+      "listCalendars",
+      "View all connected calendars. Use this when you want to: 1) See which calendars are linked 2) Check calendar connection status 3) View calendar details 4) Manage calendar integrations",
+      {},
+      async () => {
+        try {
+          const calendars = await baasClient.listCalendars();
+          return {
+            content: [
+              {
+                type: "text",
+                text: JSON.stringify(calendars, null, 2),
+              },
+            ],
+          };
+        } catch (error) {
+          console.error("Failed to list calendars:", error);
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Failed to list calendars",
+              },
+            ],
+            isError: true,
+          };
+        }
+      }
+    );
+
+    server.tool(
+      "getCalendar",
+      "Get detailed information about a specific calendar. Use this when you want to: 1) View calendar settings 2) Check sync status 3) See calendar events 4) Verify calendar connection",
+      { uuid: z.string() },
+      async ({ uuid }: { uuid: string }) => {
+        try {
+          const calendar = await baasClient.getCalendar(uuid);
+          return {
+            content: [
+              {
+                type: "text",
+                text: JSON.stringify(calendar, null, 2),
+              },
+            ],
+          };
+        } catch (error) {
+          console.error("Failed to get calendar:", error);
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Failed to get calendar",
+              },
+            ],
+            isError: true,
+          };
+        }
+      }
+    );
+
+    server.tool(
+      "deleteCalendar",
+      "Remove a calendar connection. Use this when you want to: 1) Unlink a calendar 2) Stop automatic recordings 3) Remove calendar access 4) Clean up old integrations",
+      { uuid: z.string() },
+      async ({ uuid }: { uuid: string }) => {
+        try {
+          const success = await baasClient.deleteCalendar(uuid);
+          return {
+            content: [
+              {
+                type: "text",
+                text: success
+                  ? "Successfully deleted calendar"
+                  : "Failed to delete calendar",
+              },
+            ],
+          };
+        } catch (error) {
+          console.error("Failed to delete calendar:", error);
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Failed to delete calendar",
+              },
+            ],
+            isError: true,
+          };
+        }
+      }
+    );
+
+    server.tool(
+      "resyncAllCalendars",
+      "Refresh all calendar data to ensure it's up to date. Use this when you want to: 1) Update meeting schedules 2) Sync new calendar changes 3) Refresh calendar data 4) Fix sync issues",
+      {},
+      async () => {
+        try {
+          const result = await baasClient.resyncAllCalendars();
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Successfully resynced all calendars",
+              },
+            ],
+          };
+        } catch (error) {
+          console.error("Failed to resync calendars:", error);
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Failed to resync calendars",
+              },
+            ],
+            isError: true,
+          };
+        }
+      }
+    );
+
+    server.tool(
+      "botsWithMetadata",
+      "Search and filter through your meeting bots. Use this when you want to: 1) Find specific meetings 2) Filter by date range 3) Search by meeting name 4) View meeting history",
+      {
+        botName: z.string().optional(),
+        createdAfter: z.string().optional(),
+        createdBefore: z.string().optional(),
+        cursor: z.string().optional(),
+        filterByExtra: z.string().optional(),
+        limit: z.number().optional(),
+        meetingUrl: z.string().optional(),
+        sortByExtra: z.string().optional(),
+        speakerName: z.string().optional(),
+      },
+      async ({
+        botName,
+        createdAfter,
+        createdBefore,
+        cursor,
+        filterByExtra,
+        limit,
+        meetingUrl,
+        sortByExtra,
+        speakerName,
+      }: {
+        botName?: string;
+        createdAfter?: string;
+        createdBefore?: string;
+        cursor?: string;
+        filterByExtra?: string;
+        limit?: number;
+        meetingUrl?: string;
+        sortByExtra?: string;
+        speakerName?: string;
+      }) => {
+        try {
+          const bots = await baasClient.listRecentBots({
+            botName,
+            createdAfter,
+            createdBefore,
+            cursor,
+            filterByExtra,
+            limit,
+            meetingUrl,
+            sortByExtra,
+            speakerName,
+          });
+          return {
+            content: [
+              {
+                type: "text",
+                text: JSON.stringify(bots, null, 2),
+              },
+            ],
+          };
+        } catch (error) {
+          console.error("Failed to get bots with metadata:", error);
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Failed to get bots with metadata",
+              },
+            ],
+            isError: true,
+          };
+        }
+      }
+    );
+
+    server.tool(
+      "listEvents",
+      "View all events in a calendar. Use this when you want to: 1) See upcoming meetings 2) View past meetings 3) Check meeting schedules 4) Browse calendar events",
+      { calendarUuid: z.string() },
+      async ({ calendarUuid }: { calendarUuid: string }) => {
+        try {
+          const events = await baasClient.listEvents(calendarUuid);
+          return {
+            content: [
+              {
+                type: "text",
+                text: JSON.stringify(events, null, 2),
+              },
+            ],
+          };
+        } catch (error) {
+          console.error("Failed to list events:", error);
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Failed to list events",
+              },
+            ],
+            isError: true,
+          };
+        }
+      }
+    );
+
+    server.tool(
+      "scheduleRecordEvent",
+      "Schedule a bot to automatically record a future meeting. Use this when you want to: 1) Set up automatic recording 2) Schedule future transcriptions 3) Plan meeting recordings 4) Enable recurring recordings",
+      {
+        eventUuid: z.string(),
+        botName: z.string(),
+        extra: z.record(z.any()).optional(),
+      },
+      async ({
+        eventUuid,
+        botName,
+        extra,
+      }: {
+        eventUuid: string;
+        botName: string;
+        extra?: Record<string, any>;
+      }) => {
+        try {
+          const result = await baasClient.scheduleRecordEvent(eventUuid, {
+            botName,
+            extra,
+          });
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Successfully scheduled event recording",
+              },
+            ],
+          };
+        } catch (error) {
+          console.error("Failed to schedule event recording:", error);
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Failed to schedule event recording",
+              },
+            ],
+            isError: true,
+          };
+        }
+      }
+    );
+
+    server.tool(
+      "unscheduleRecordEvent",
+      "Cancel a scheduled recording for a meeting. Use this when you want to: 1) Stop automatic recording 2) Cancel future transcriptions 3) Remove scheduled recordings 4) Disable recurring recordings",
+      { eventUuid: z.string() },
+      async ({ eventUuid }: { eventUuid: string }) => {
+        try {
+          const result = await baasClient.unscheduleRecordEvent(eventUuid);
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Successfully unscheduled event recording",
+              },
+            ],
+          };
+        } catch (error) {
+          console.error("Failed to unschedule event recording:", error);
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Failed to unschedule event recording",
+              },
+            ],
+            isError: true,
+          };
+        }
+      }
+    );
+
+    server.tool(
+      "updateCalendar",
+      "Update calendar connection settings. Use this when you want to: 1) Refresh calendar access 2) Update calendar credentials 3) Change calendar settings 4) Fix connection issues",
+      {
+        uuid: z.string(),
+        oauthClientId: z.string().optional(),
+        oauthClientSecret: z.string().optional(),
+        oauthRefreshToken: z.string().optional(),
+        platform: z.enum(["Google", "Microsoft"]).optional(),
+        rawCalendarId: z.string().optional(),
+      },
+      async ({
+        uuid,
+        oauthClientId,
+        oauthClientSecret,
+        oauthRefreshToken,
+        platform,
+        rawCalendarId,
+      }: {
+        uuid: string;
+        oauthClientId?: string;
+        oauthClientSecret?: string;
+        oauthRefreshToken?: string;
+        platform?: "Google" | "Microsoft";
+        rawCalendarId?: string;
+      }) => {
+        try {
+          const calendar = await baasClient.updateCalendar(uuid, {
+            oauthClientId,
+            oauthClientSecret,
+            oauthRefreshToken,
+            platform: platform === "Google" ? "Google" : "Microsoft",
+            rawCalendarId,
+          });
+          return {
+            content: [
+              {
+                type: "text",
+                text: `Successfully updated calendar: ${JSON.stringify(
+                  calendar,
+                  null,
+                  2
+                )}`,
+              },
+            ],
+          };
+        } catch (error) {
+          console.error("Failed to update calendar:", error);
+          return {
+            content: [
+              {
+                type: "text",
+                text: "Failed to update calendar",
+              },
+            ],
+            isError: true,
+          };
+        }
+      }
+    );
+
+    // Add a simple echo tool for testing
+    server.tool("echo", { message: z.string() }, async ({ message }) => ({
+      content: [
+        {
+          type: "text",
+          text: `Tool echo: ${message}`,
+        },
+      ],
+    }));
   },
   {
     capabilities: {
       tools: {
         joinMeeting: {
           description: "Join's a meeting using the MeetingBaas api",
         },
         leaveMeeting: {
           description: "Leave a meeting using the MeetingBaas api",
         },
         getMeetingData: {
           description: "Get meeting data using the MeetingBaas api",
         },
         deleteData: {
           description: "Delete meeting data using the MeetingBaas api",
         },
         createCalendar: {
           description: "Create a calendar using the MeetingBaas api",
         },
         listCalendars: {
           description: "List calendars using the MeetingBaas api",
         },
         getCalendar: {
           description: "Get calendar using the MeetingBaas api",
         },
         deleteCalendar: {
           description: "Delete calendar using the MeetingBaas api",
         },
         resyncAllCalendars: {
           description: "Resync all calendars using the MeetingBaas api",
         },
         botsWithMetadata: {
           description: "Get bots with metadata using the MeetingBaas api",
         },
         listEvents: {
           description: "List events using the MeetingBaas api",
         },
         scheduleRecordEvent: {
           description: "Schedule a recording using the MeetingBaas api",
         },
         unscheduleRecordEvent: {
           description: "Unschedule a recording using the MeetingBaas api",
         },
         updateCalendar: {
           description: "Update calendar using the MeetingBaas api",
         },
         echo: {
           description: "Echo a message",
         },
       },
     },
   }
 );
 
 export default handler;
diff --git a/package.json b/package.json
index e30a78c..ae9f7d3 100644
--- a/package.json
+++ b/package.json
@@ -1,30 +1,24 @@
 {
   "name": "meetingbaas-mcp",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
-    "test": "echo \"Error: no test specified\" && exit 1",
-    "build": "tsc",
-    "build:watch": "tsc --watch",
-    "start": "node -r dotenv/config dist/api/server.js",
-    "dev": "tsc --watch & node -r dotenv/config dist/api/server.js"
+    "test": "echo \"Error: no test specified\" && exit 1"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
     "@meeting-baas/sdk": "^0.2.4",
     "@modelcontextprotocol/sdk": "^1.6.1",
     "content-type": "^1.0.5",
-    "dotenv": "^16.4.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
-    "@types/node": "^22.13.10",
-    "typescript": "^5.3.3"
+    "@types/node": "^22.13.10"
   }
-}
+}
\ No newline at end of file
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# bafcf83334107e093338493404aee35e7d7199a2
#KEY#COMMIT_DATE# 2025-04-23 11:32:41 +0200
#KEY#COMMIT_AUTHOR# Anirudh
#KEY#COMMIT_MESSAGE# fix: git ignore
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- public/index.html

#KEY#DIFF_RANGE# FROM: 0a4825094385cfba0a45fc74c03b0106f619b862 TO: bafcf83334107e093338493404aee35e7d7199a2
=================================================================

#KEY#GIT_DIFF#

diff --git a/public/index.html b/public/index.html
index 49bae11..ee251a5 100644
--- a/public/index.html
+++ b/public/index.html
@@ -1,3 +1,10 @@
-<h1>MeetingBaas MCP</h1>
+<h1>MCP on Vercel</h1>
 
 <p>Protocol is mounted below /.</p>
+
+<p>
+  <a
+    href="https://vercel.com/templates/other/model-context-protocol-mcp-with-vercel-functions"
+    >Clone template on Vercel</a
+  >
+</p>
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 9aba037a12afca49f55f75bd81c3e5bf6a69f1d6
#KEY#COMMIT_DATE# 2025-04-23 11:32:39 +0200
#KEY#COMMIT_AUTHOR# Anirudh
#KEY#COMMIT_MESSAGE# fix: revert pkg json
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- .gitignore

#KEY#DIFF_RANGE# FROM: bafcf83334107e093338493404aee35e7d7199a2 TO: 9aba037a12afca49f55f75bd81c3e5bf6a69f1d6
=================================================================

#KEY#GIT_DIFF#

diff --git a/.gitignore b/.gitignore
index e0a64ea..470c0d5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,2 +1,3 @@
 .vercel
-node_modules
\ No newline at end of file
+node_modules
+dist
\ No newline at end of file
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# bbd754ad1256585eec313147894052fc9ec76bd7
#KEY#COMMIT_DATE# 2025-04-23 11:32:19 +0200
#KEY#COMMIT_AUTHOR# Anirudh
#KEY#COMMIT_MESSAGE# fix: tsc
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- package.json

#KEY#DIFF_RANGE# FROM: 9aba037a12afca49f55f75bd81c3e5bf6a69f1d6 TO: bbd754ad1256585eec313147894052fc9ec76bd7
=================================================================

#KEY#GIT_DIFF#

diff --git a/package.json b/package.json
index ae9f7d3..f30ef71 100644
--- a/package.json
+++ b/package.json
@@ -1,24 +1,28 @@
 {
-  "name": "meetingbaas-mcp",
+  "name": "mcp-on-vercel",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
-    "test": "echo \"Error: no test specified\" && exit 1"
+    "test": "echo \"Error: no test specified\" && exit 1",
+    "build": "tsc",
+    "test:redis": "tsx scripts/test-redis.ts"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
     "@meeting-baas/sdk": "^0.2.4",
     "@modelcontextprotocol/sdk": "^1.6.1",
     "content-type": "^1.0.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
-    "@types/node": "^22.13.10"
+    "@types/node": "^20.11.24",
+    "tsx": "^4.7.1",
+    "typescript": "^5.4.2"
   }
-}
\ No newline at end of file
+}
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# cea9b60971c40c9136d6e611e148c617fbe25330
#KEY#COMMIT_DATE# 2025-04-23 11:32:19 +0200
#KEY#COMMIT_AUTHOR# Anirudh
#KEY#COMMIT_MESSAGE# fix: url
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- tsconfig.json

#KEY#DIFF_RANGE# FROM: bbd754ad1256585eec313147894052fc9ec76bd7 TO: cea9b60971c40c9136d6e611e148c617fbe25330
=================================================================

#KEY#GIT_DIFF#

diff --git a/tsconfig.json b/tsconfig.json
new file mode 100644
index 0000000..565801f
--- /dev/null
+++ b/tsconfig.json
@@ -0,0 +1,20 @@
+{
+  "compilerOptions": {
+    "target": "es2017",
+    "lib": ["es2017", "esnext.asynciterable"],
+    "module": "commonjs",
+    "moduleResolution": "node",
+    "esModuleInterop": true,
+    "strict": true,
+    "skipLibCheck": true,
+    "forceConsistentCasingInFileNames": true,
+    "outDir": "dist",
+    "rootDir": ".",
+    "baseUrl": ".",
+    "paths": {
+      "@/*": ["./*"]
+    }
+  },
+  "include": ["api/**/*", "lib/**/*"],
+  "exclude": ["node_modules", "dist"]
+}
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# d9e4eb1a87ffddbc95610bade9dfd42c6851a3b4
#KEY#COMMIT_DATE# 2025-04-23 11:32:19 +0200
#KEY#COMMIT_AUTHOR# Anirudh
#KEY#COMMIT_MESSAGE# fix: client
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- scripts/test-client.mjs

#KEY#DIFF_RANGE# FROM: cea9b60971c40c9136d6e611e148c617fbe25330 TO: d9e4eb1a87ffddbc95610bade9dfd42c6851a3b4
=================================================================

#KEY#GIT_DIFF#

diff --git a/scripts/test-client.mjs b/scripts/test-client.mjs
index b61cae7..9fd759a 100644
--- a/scripts/test-client.mjs
+++ b/scripts/test-client.mjs
@@ -1,31 +1,31 @@
 import { Client } from "@modelcontextprotocol/sdk/client/index.js";
 import { SSEClientTransport } from "@modelcontextprotocol/sdk/client/sse.js";
 
-const origin = process.argv[2] || "https://mcp.meetingbaas.com";
+const origin = process.argv[2] || "https://mcp-on-vercel.vercel.app";
 
 async function main() {
   const transport = new SSEClientTransport(new URL(`${origin}/sse`));
 
   const client = new Client(
     {
       name: "example-client",
       version: "1.0.0",
     },
     {
       capabilities: {
         prompts: {},
         resources: {},
         tools: {},
       },
     }
   );
 
   await client.connect(transport);
 
   console.log("Connected", client.getServerCapabilities());
 
   const result = await client.listTools();
   console.log(result);
 }
 
 main();
\ No newline at end of file
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# d8ee0d95df9d7c0d77455b76cb8209f4fc769bf0
#KEY#COMMIT_DATE# 2025-04-23 11:32:19 +0200
#KEY#COMMIT_AUTHOR# Anirudh
#KEY#COMMIT_MESSAGE# fixL revert to vercel
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts
- scripts/test-client.mjs

#KEY#DIFF_RANGE# FROM: d9e4eb1a87ffddbc95610bade9dfd42c6851a3b4 TO: d8ee0d95df9d7c0d77455b76cb8209f4fc769bf0
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index 6f89b42..5ed8af8 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -200,130 +200,130 @@ export function initializeMcpApiHandler(
 
       async function cleanup() {
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
         res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
       const requestId = crypto.randomUUID();
       const serializedRequest: SerializedRequest = {
         requestId,
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Handles responses from the /sse endpoint.
       await redis.subscribe(
         `responses:${sessionId}:${requestId}`,
         (message) => {
           clearTimeout(timeout);
           const response = JSON.parse(message) as {
             status: number;
             body: string;
           };
           res.statusCode = response.status;
           res.end(response.body);
         }
       );
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await redisPublisher.publish(
         `requests:${sessionId}`,
         JSON.stringify(serializedRequest)
       );
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
       let timeout = setTimeout(async () => {
         await redis.unsubscribe(`responses:${sessionId}:${requestId}`);
         res.statusCode = 408;
         res.end("Request timed out");
       }, 10 * 1000);
 
       res.on("close", async () => {
         clearTimeout(timeout);
         await redis.unsubscribe(`responses:${sessionId}:${requestId}`);
       });
     } else {
       res.statusCode = 404;
       res.end("Not found");
     }
   };
 }
 
 // Define the options interface
 interface FakeIncomingMessageOptions {
   method?: string;
   url?: string;
   headers?: IncomingHttpHeaders;
   body?: string | Buffer | Record<string, any> | null;
   socket?: Socket;
 }
 
 // Create a fake IncomingMessage
 function createFakeIncomingMessage(
   options: FakeIncomingMessageOptions = {}
 ): IncomingMessage {
   const {
     method = "GET",
     url = "/",
     headers = {},
     body = null,
     socket = new Socket(),
   } = options;
 
   // Create a readable stream that will be used as the base for IncomingMessage
   const readable = new Readable();
-  readable._read = (): void => { }; // Required implementation
+  readable._read = (): void => {}; // Required implementation
 
   // Add the body content if provided
   if (body) {
     if (typeof body === "string") {
       readable.push(body);
     } else if (Buffer.isBuffer(body)) {
       readable.push(body);
     } else {
       readable.push(JSON.stringify(body));
     }
     readable.push(null); // Signal the end of the stream
   }
 
   // Create the IncomingMessage instance
   const req = new IncomingMessage(socket);
 
   // Set the properties
   req.method = method;
   req.url = url;
   req.headers = headers;
 
   // Copy over the stream methods
   req.push = readable.push.bind(readable);
   req.read = readable.read.bind(readable);
   req.on = readable.on.bind(readable);
   req.pipe = readable.pipe.bind(readable);
 
   return req;
 }
\ No newline at end of file
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 5fea48c91e3948f252c39efa9b5b0e8ac7381842
#KEY#COMMIT_DATE# 2025-04-23 11:32:17 +0200
#KEY#COMMIT_AUTHOR# Anirudh
#KEY#COMMIT_MESSAGE# fix: server
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- lib/mcp-api-handler.ts

#KEY#DIFF_RANGE# FROM: d8ee0d95df9d7c0d77455b76cb8209f4fc769bf0 TO: 5fea48c91e3948f252c39efa9b5b0e8ac7381842
=================================================================

#KEY#GIT_DIFF#

diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index 5ed8af8..c569f29 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,329 +1,351 @@
-import getRawBody from "raw-body";
+import { ServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
-import { createClient } from "redis";
 import { Socket } from "net";
+import getRawBody from "raw-body";
+import { createClient } from "redis";
 import { Readable } from "stream";
-import { ServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
-import vercelJson from "../vercel.json";
+
+// Increase max duration to match vercel.json
+const MAX_DURATION = 300;
+// Keep-alive interval in seconds
+const KEEP_ALIVE_INTERVAL = 30;
 
 interface SerializedRequest {
   requestId: string;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer) => void,
   serverOptions: ServerOptions = {}
 ) {
-  const maxDuration =
-    vercelJson?.functions?.["api/server.ts"]?.maxDuration || 800;
+  const maxDuration = MAX_DURATION;
   const redisUrl = process.env.REDIS_URL || process.env.KV_URL;
   if (!redisUrl) {
     throw new Error("REDIS_URL environment variable is not set");
   }
   const redis = createClient({
     url: redisUrl,
   });
   const redisPublisher = createClient({
     url: redisUrl,
   });
   redis.on("error", (err) => {
     console.error("Redis error", err);
   });
   redisPublisher.on("error", (err) => {
     console.error("Redis error", err);
   });
   const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 
   let servers: McpServer[] = [];
 
   let statelessServer: McpServer;
   const statelessTransport = new StreamableHTTPServerTransport({
     sessionIdGenerator: undefined,
   });
 
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/mcp") {
       if (req.method === "GET") {
         console.log("Received GET MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       if (req.method === "DELETE") {
         console.log("Received DELETE MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       console.log("Got new MCP connection", req.url, req.method);
 
       if (!statelessServer) {
         statelessServer = new McpServer(
           {
             name: "mcp-typescript server on vercel",
             version: "0.1.0",
           },
           serverOptions
         );
 
         initializeServer(statelessServer);
         await statelessServer.connect(statelessTransport);
       }
       await statelessTransport.handleRequest(req, res);
     } else if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
+      // Set headers for SSE
+      res.writeHead(200, {
+        "Content-Type": "text/event-stream",
+        "Cache-Control": "no-cache",
+        Connection: "keep-alive",
+      });
+
+      // Send keep-alive comments periodically
+      const keepAliveInterval = setInterval(() => {
+        res.write(": keep-alive\n\n");
+      }, KEEP_ALIVE_INTERVAL * 1000);
+
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript server on vercel",
           version: "0.1.0",
         },
         serverOptions
       );
       initializeServer(server);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
+        clearInterval(keepAliveInterval);
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       // Handles messages originally received via /message
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b: unknown) => {
           body = b as string;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         await redisPublisher.publish(
           `responses:${sessionId}:${request.requestId}`,
           JSON.stringify({
             status,
             body,
           })
         );
 
         if (status >= 200 && status < 300) {
           logInContext(
             "log",
             `Request ${sessionId}:${request.requestId} succeeded: ${body}`
           );
         } else {
           logInContext(
             "error",
             `Message for ${sessionId}:${request.requestId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, (maxDuration - 5) * 1000);
       });
 
       async function cleanup() {
+        clearInterval(keepAliveInterval);
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
-        res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
       const requestId = crypto.randomUUID();
       const serializedRequest: SerializedRequest = {
         requestId,
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Handles responses from the /sse endpoint.
       await redis.subscribe(
         `responses:${sessionId}:${requestId}`,
         (message) => {
           clearTimeout(timeout);
           const response = JSON.parse(message) as {
             status: number;
             body: string;
           };
           res.statusCode = response.status;
           res.end(response.body);
         }
       );
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await redisPublisher.publish(
         `requests:${sessionId}`,
         JSON.stringify(serializedRequest)
       );
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
       let timeout = setTimeout(async () => {
         await redis.unsubscribe(`responses:${sessionId}:${requestId}`);
         res.statusCode = 408;
         res.end("Request timed out");
       }, 10 * 1000);
 
       res.on("close", async () => {
         clearTimeout(timeout);
         await redis.unsubscribe(`responses:${sessionId}:${requestId}`);
       });
     } else {
       res.statusCode = 404;
       res.end("Not found");
     }
   };
 }
 
 // Define the options interface
 interface FakeIncomingMessageOptions {
   method?: string;
   url?: string;
   headers?: IncomingHttpHeaders;
   body?: string | Buffer | Record<string, any> | null;
   socket?: Socket;
 }
 
 // Create a fake IncomingMessage
 function createFakeIncomingMessage(
   options: FakeIncomingMessageOptions = {}
 ): IncomingMessage {
   const {
     method = "GET",
     url = "/",
     headers = {},
     body = null,
     socket = new Socket(),
   } = options;
 
-  // Create a readable stream that will be used as the base for IncomingMessage
-  const readable = new Readable();
-  readable._read = (): void => {}; // Required implementation
+  // Create a proper IncomingMessage instance
+  const req = Object.create(IncomingMessage.prototype);
+  Object.assign(req, new Readable(), {
+    method,
+    url,
+    headers,
+    socket,
+    // Add required IncomingMessage properties
+    httpVersion: "1.1",
+    httpVersionMajor: 1,
+    httpVersionMinor: 1,
+    aborted: false,
+    complete: true,
+    connection: socket,
+    // Bind necessary methods
+    _read: function () {},
+    push: function (chunk: any) {
+      if (chunk !== null) {
+        return Readable.prototype.push.call(this, chunk);
+      }
+      return false;
+    },
+  });
 
-  // Add the body content if provided
+  // Add the body if provided
   if (body) {
     if (typeof body === "string") {
-      readable.push(body);
+      req.push(body);
     } else if (Buffer.isBuffer(body)) {
-      readable.push(body);
+      req.push(body);
     } else {
-      readable.push(JSON.stringify(body));
+      req.push(JSON.stringify(body));
     }
-    readable.push(null); // Signal the end of the stream
   }
-
-  // Create the IncomingMessage instance
-  const req = new IncomingMessage(socket);
-
-  // Set the properties
-  req.method = method;
-  req.url = url;
-  req.headers = headers;
-
-  // Copy over the stream methods
-  req.push = readable.push.bind(readable);
-  req.read = readable.read.bind(readable);
-  req.on = readable.on.bind(readable);
-  req.pipe = readable.pipe.bind(readable);
+  req.push(null); // Signal end of stream
 
   return req;
-}
\ No newline at end of file
+}
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# c7aa469c1094d714d71c83b002b8a4fbee346cf9
#KEY#COMMIT_DATE# 2025-04-23 11:31:41 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# feat: Add type-safe Meeting BaaS tool execution
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- .gitignore
- api/server.ts
- package.json
- scripts/test-client.mjs
- scripts/test-redis.ts

#KEY#DIFF_RANGE# FROM: 5fea48c91e3948f252c39efa9b5b0e8ac7381842 TO: c7aa469c1094d714d71c83b002b8a4fbee346cf9
=================================================================

#KEY#GIT_DIFF#

diff --git a/.gitignore b/.gitignore
index 470c0d5..e0a64ea 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,2 @@
 .vercel
-node_modules
-dist
\ No newline at end of file
+node_modules
\ No newline at end of file
diff --git a/api/server.ts b/api/server.ts
index 6ae9009..1b24bb2 100644
--- a/api/server.ts
+++ b/api/server.ts
@@ -1,641 +1,250 @@
-import { BaasClient } from "@meeting-baas/sdk";
+import type { BaasTypes } from "@meeting-baas/sdk";
+import { BaasClient, MpcClient } from "@meeting-baas/sdk";
+import { IncomingMessage } from "http";
+import { createClient } from "redis";
 import { z } from "zod";
 import { initializeMcpApiHandler } from "../lib/mcp-api-handler";
 
+// Initialize Redis client
+const redis = createClient({
+  url: process.env.REDIS_URL,
+});
+
+redis.on("error", (err) => console.error("Redis Client Error", err));
+
+// Initialize MPC client for tool registration
+const mpcClient = new MpcClient({
+  serverUrl: process.env.MPC_SERVER_URL || "",
+});
+
+interface ToolParameter {
+  name: string;
+  required?: boolean;
+  schema?: {
+    type: string;
+  };
+}
+
+// Helper function to convert MPC parameter definition to Zod schema
+function convertToZodSchema(parameters: ToolParameter[]): z.ZodRawShape {
+  const schema: z.ZodRawShape = {};
+  for (const param of parameters) {
+    if (param.required) {
+      schema[param.name] = z.string();
+    } else {
+      schema[param.name] = z.string().optional();
+    }
+  }
+  return schema;
+}
+
+// Helper to get BaaS client for each request
+function getBaasClient(req: IncomingMessage): BaasClient {
+  const url = new URL(req.url || "", "https://example.com");
+  const apiKey = url.searchParams.get("X-Meeting-BaaS-Key") || "";
+  return new BaasClient({
+    apiKey,
+  });
+}
+
+// Type guard to check if an object has required properties
+function hasRequiredProperties<T extends object>(
+  obj: unknown,
+  required: (keyof T)[]
+): obj is T {
+  if (typeof obj !== "object" || obj === null) {
+    return false;
+  }
+  return required.every((prop) => prop in obj);
+}
+
 const handler = initializeMcpApiHandler(
   (server) => {
-    const baasClient = new BaasClient({
-      apiKey: process.env.BAAS_API_KEY || "",
-    });
-
-    // Register Meeting BaaS SDK tools
-    server.tool(
-      "joinMeeting",
-      "Send an AI bot to join a video meeting. The bot can record the meeting, transcribe speech, and provide real-time audio streams. Use this when you want to: 1) Record a meeting 2) Get meeting transcriptions 3) Stream meeting audio 4) Monitor meeting attendance",
-      {
-        meetingUrl: z.string(),
-        botName: z.string(),
-        webhookUrl: z.string().optional(),
-        recordingMode: z.string().optional(),
-        speechToText: z.boolean().optional(),
-        reserved: z.boolean(),
-      },
-      async ({
-        meetingUrl,
-        botName,
-        webhookUrl,
-        recordingMode,
-        speechToText,
-        reserved,
-      }: {
-        meetingUrl: string;
-        botName: string;
-        webhookUrl?: string;
-        recordingMode?: string;
-        speechToText?: boolean;
-        reserved: boolean;
-      }) => {
-        try {
-          const botId = await baasClient.joinMeeting({
-            meetingUrl,
-            botName,
-            webhookUrl,
-            recordingMode,
-            speechToText: speechToText ? { provider: "Default" } : undefined,
-            reserved,
-          });
-          return {
-            content: [
-              {
-                type: "text",
-                text: `Successfully joined meeting with bot ID: ${botId}`,
-              },
-            ],
-          };
-        } catch (error) {
-          console.error("Failed to join meeting:", error);
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Failed to join meeting",
-              },
-            ],
-            isError: true,
-          };
-        }
-      }
-    );
-
-    server.tool(
-      "leaveMeeting",
-      "Remove an AI bot from a meeting. Use this when you want to: 1) End a meeting recording 2) Stop transcription 3) Disconnect the bot from the meeting",
-      { botId: z.string() },
-      async ({ botId }: { botId: string }) => {
-        try {
-          const success = await baasClient.leaveMeeting(botId);
-          return {
-            content: [
-              {
-                type: "text",
-                text: success
-                  ? "Successfully left meeting"
-                  : "Failed to leave meeting",
-              },
-            ],
-          };
-        } catch (error) {
-          console.error("Failed to leave meeting:", error);
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Failed to leave meeting",
-              },
-            ],
-            isError: true,
-          };
-        }
-      }
-    );
-
-    server.tool(
-      "getMeetingData",
-      "Get all data from a meeting including recording, transcript, and metadata. Use this when you want to: 1) Search through meeting transcripts 2) Get meeting recordings 3) Review meeting details 4) Access speaker information",
-      { botId: z.string() },
-      async ({ botId }: { botId: string }) => {
-        try {
-          const data = await baasClient.getMeetingData(botId);
-          return {
-            content: [
-              {
-                type: "text",
-                text: JSON.stringify(data, null, 2),
-              },
-            ],
-          };
-        } catch (error) {
-          console.error("Failed to get meeting data:", error);
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Failed to get meeting data",
-              },
-            ],
-            isError: true,
-          };
-        }
+    return async (req: IncomingMessage) => {
+      // Connect to Redis
+      await redis.connect();
+
+      // Get BaaS client for this request
+      const baasClient = getBaasClient(req);
+
+      // Register all Meeting BaaS tools automatically
+      const tools = mpcClient.getRegisteredTools();
+      for (const tool of tools) {
+        const paramsSchema = convertToZodSchema(tool.parameters || []);
+        server.tool(
+          tool.name,
+          paramsSchema,
+          async (params: Record<string, string>) => {
+            // Transform string parameters to their proper types
+            const transformedParams = Object.entries(params).reduce(
+              (acc, [key, value]) => {
+                // Handle boolean parameters
+                if (value === "true" || value === "false") {
+                  acc[key] = value === "true";
+                }
+                // Handle number parameters
+                else if (!isNaN(Number(value))) {
+                  acc[key] = Number(value);
+                }
+                // Handle object parameters (like speechToText)
+                else if (value.startsWith("{")) {
+                  try {
+                    acc[key] = JSON.parse(value);
+                  } catch (e) {
+                    acc[key] = value;
+                  }
+                }
+                // Keep string parameters as is
+                else {
+                  acc[key] = value;
+                }
+                return acc;
+              },
+              {} as Record<string, any>
+            );
+
+            // Use the corresponding BaaS client method
+            const method = tool.name as keyof typeof baasClient;
+
+            // Type check based on the method
+            switch (method) {
+              case "joinMeeting":
+                if (
+                  !hasRequiredProperties<BaasTypes.JoinRequest>(
+                    transformedParams,
+                    ["botName", "meetingUrl", "reserved"]
+                  )
+                ) {
+                  throw new Error(
+                    "Missing required parameters for joinMeeting"
+                  );
+                }
+                break;
+              case "createCalendar":
+                if (
+                  !hasRequiredProperties<BaasTypes.CreateCalendarParams>(
+                    transformedParams,
+                    [
+                      "oauth_client_id",
+                      "oauth_client_secret",
+                      "oauth_refresh_token",
+                      "platform",
+                    ]
+                  )
+                ) {
+                  throw new Error(
+                    "Missing required parameters for createCalendar"
+                  );
+                }
+                break;
+              case "getMeetingData":
+                if (
+                  !hasRequiredProperties<BaasTypes.GetMeetingDataQuery>(
+                    transformedParams,
+                    ["bot_id"]
+                  )
+                ) {
+                  throw new Error(
+                    "Missing required parameters for getMeetingData"
+                  );
+                }
+                break;
+              case "deleteData":
+                if (
+                  !hasRequiredProperties<BaasTypes.BotIdParam>(
+                    transformedParams,
+                    ["bot_id"]
+                  )
+                ) {
+                  throw new Error("Missing required parameters for deleteData");
+                }
+                break;
+              case "listCalendars":
+                // No required parameters
+                break;
+              case "getCalendar":
+                if (
+                  !hasRequiredProperties<BaasTypes.CalendarUuidParam>(
+                    transformedParams,
+                    ["calendar_uuid"]
+                  )
+                ) {
+                  throw new Error(
+                    "Missing required parameters for getCalendar"
+                  );
+                }
+                break;
+              case "deleteCalendar":
+                if (
+                  !hasRequiredProperties<BaasTypes.CalendarUuidParam>(
+                    transformedParams,
+                    ["calendar_uuid"]
+                  )
+                ) {
+                  throw new Error(
+                    "Missing required parameters for deleteCalendar"
+                  );
+                }
+                break;
+              case "resyncAllCalendars":
+                // No required parameters
+                break;
+            }
+
+            const result = await baasClient[method](transformedParams as any);
+            return {
+              content: [
+                {
+                  type: "text",
+                  text: JSON.stringify(result),
+                },
+              ],
+            };
+          }
+        );
       }
-    );
 
-    server.tool(
-      "deleteData",
-      "Delete all data from a meeting including recording, transcript, and logs. Use this when you want to: 1) Remove sensitive meeting data 2) Clear meeting recordings 3) Delete transcripts 4) Free up storage space",
-      { botId: z.string() },
-      async ({ botId }: { botId: string }) => {
-        try {
-          const result = await baasClient.deleteData(botId);
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Successfully deleted meeting data",
-              },
-            ],
-          };
-        } catch (error) {
-          console.error("Failed to delete data:", error);
+      // Add a Redis test tool
+      server.tool(
+        "redis_test",
+        { key: z.string(), value: z.string() },
+        async ({ key, value }: { key: string; value: string }) => {
+          await redis.set(key, value);
+          const result = await redis.get(key);
           return {
             content: [
               {
                 type: "text",
-                text: "Failed to delete meeting data",
+                text: `Redis test: stored ${key}=${value}, retrieved ${result}`,
               },
             ],
-            isError: true,
           };
         }
-      }
-    );
-
-    server.tool(
-      "createCalendar",
-      "Connect a Google or Microsoft calendar to Meeting BaaS. Use this when you want to: 1) Link your work calendar 2) Enable automatic meeting recordings 3) Schedule bots for future meetings 4) Sync your calendar events",
-      {
-        oauthClientId: z.string(),
-        oauthClientSecret: z.string(),
-        oauthRefreshToken: z.string(),
-        platform: z.enum(["Google", "Microsoft"]),
-        rawCalendarId: z.string(),
-      },
-      async ({
-        oauthClientId,
-        oauthClientSecret,
-        oauthRefreshToken,
-        platform,
-        rawCalendarId,
-      }: {
-        oauthClientId: string;
-        oauthClientSecret: string;
-        oauthRefreshToken: string;
-        platform: "Google" | "Microsoft";
-        rawCalendarId: string;
-      }) => {
-        try {
-          const calendar = await baasClient.createCalendar({
-            oauthClientId,
-            oauthClientSecret,
-            oauthRefreshToken,
-            platform: platform === "Google" ? "Google" : "Microsoft",
-            rawCalendarId,
-          });
-          return {
-            content: [
-              {
-                type: "text",
-                text: `Successfully created calendar: ${JSON.stringify(
-                  calendar,
-                  null,
-                  2
-                )}`,
-              },
-            ],
-          };
-        } catch (error) {
-          console.error("Failed to create calendar:", error);
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Failed to create calendar",
-              },
-            ],
-            isError: true,
-          };
-        }
-      }
-    );
-
-    server.tool(
-      "listCalendars",
-      "View all connected calendars. Use this when you want to: 1) See which calendars are linked 2) Check calendar connection status 3) View calendar details 4) Manage calendar integrations",
-      {},
-      async () => {
-        try {
-          const calendars = await baasClient.listCalendars();
-          return {
-            content: [
-              {
-                type: "text",
-                text: JSON.stringify(calendars, null, 2),
-              },
-            ],
-          };
-        } catch (error) {
-          console.error("Failed to list calendars:", error);
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Failed to list calendars",
-              },
-            ],
-            isError: true,
-          };
-        }
-      }
-    );
-
-    server.tool(
-      "getCalendar",
-      "Get detailed information about a specific calendar. Use this when you want to: 1) View calendar settings 2) Check sync status 3) See calendar events 4) Verify calendar connection",
-      { uuid: z.string() },
-      async ({ uuid }: { uuid: string }) => {
-        try {
-          const calendar = await baasClient.getCalendar(uuid);
-          return {
-            content: [
-              {
-                type: "text",
-                text: JSON.stringify(calendar, null, 2),
-              },
-            ],
-          };
-        } catch (error) {
-          console.error("Failed to get calendar:", error);
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Failed to get calendar",
-              },
-            ],
-            isError: true,
-          };
-        }
-      }
-    );
-
-    server.tool(
-      "deleteCalendar",
-      "Remove a calendar connection. Use this when you want to: 1) Unlink a calendar 2) Stop automatic recordings 3) Remove calendar access 4) Clean up old integrations",
-      { uuid: z.string() },
-      async ({ uuid }: { uuid: string }) => {
-        try {
-          const success = await baasClient.deleteCalendar(uuid);
-          return {
-            content: [
-              {
-                type: "text",
-                text: success
-                  ? "Successfully deleted calendar"
-                  : "Failed to delete calendar",
-              },
-            ],
-          };
-        } catch (error) {
-          console.error("Failed to delete calendar:", error);
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Failed to delete calendar",
-              },
-            ],
-            isError: true,
-          };
-        }
-      }
-    );
-
-    server.tool(
-      "resyncAllCalendars",
-      "Refresh all calendar data to ensure it's up to date. Use this when you want to: 1) Update meeting schedules 2) Sync new calendar changes 3) Refresh calendar data 4) Fix sync issues",
-      {},
-      async () => {
-        try {
-          const result = await baasClient.resyncAllCalendars();
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Successfully resynced all calendars",
-              },
-            ],
-          };
-        } catch (error) {
-          console.error("Failed to resync calendars:", error);
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Failed to resync calendars",
-              },
-            ],
-            isError: true,
-          };
-        }
-      }
-    );
-
-    server.tool(
-      "botsWithMetadata",
-      "Search and filter through your meeting bots. Use this when you want to: 1) Find specific meetings 2) Filter by date range 3) Search by meeting name 4) View meeting history",
-      {
-        botName: z.string().optional(),
-        createdAfter: z.string().optional(),
-        createdBefore: z.string().optional(),
-        cursor: z.string().optional(),
-        filterByExtra: z.string().optional(),
-        limit: z.number().optional(),
-        meetingUrl: z.string().optional(),
-        sortByExtra: z.string().optional(),
-        speakerName: z.string().optional(),
-      },
-      async ({
-        botName,
-        createdAfter,
-        createdBefore,
-        cursor,
-        filterByExtra,
-        limit,
-        meetingUrl,
-        sortByExtra,
-        speakerName,
-      }: {
-        botName?: string;
-        createdAfter?: string;
-        createdBefore?: string;
-        cursor?: string;
-        filterByExtra?: string;
-        limit?: number;
-        meetingUrl?: string;
-        sortByExtra?: string;
-        speakerName?: string;
-      }) => {
-        try {
-          const bots = await baasClient.listRecentBots({
-            botName,
-            createdAfter,
-            createdBefore,
-            cursor,
-            filterByExtra,
-            limit,
-            meetingUrl,
-            sortByExtra,
-            speakerName,
-          });
-          return {
-            content: [
-              {
-                type: "text",
-                text: JSON.stringify(bots, null, 2),
-              },
-            ],
-          };
-        } catch (error) {
-          console.error("Failed to get bots with metadata:", error);
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Failed to get bots with metadata",
-              },
-            ],
-            isError: true,
-          };
-        }
-      }
-    );
-
-    server.tool(
-      "listEvents",
-      "View all events in a calendar. Use this when you want to: 1) See upcoming meetings 2) View past meetings 3) Check meeting schedules 4) Browse calendar events",
-      { calendarUuid: z.string() },
-      async ({ calendarUuid }: { calendarUuid: string }) => {
-        try {
-          const events = await baasClient.listEvents(calendarUuid);
-          return {
-            content: [
-              {
-                type: "text",
-                text: JSON.stringify(events, null, 2),
-              },
-            ],
-          };
-        } catch (error) {
-          console.error("Failed to list events:", error);
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Failed to list events",
-              },
-            ],
-            isError: true,
-          };
-        }
-      }
-    );
-
-    server.tool(
-      "scheduleRecordEvent",
-      "Schedule a bot to automatically record a future meeting. Use this when you want to: 1) Set up automatic recording 2) Schedule future transcriptions 3) Plan meeting recordings 4) Enable recurring recordings",
-      {
-        eventUuid: z.string(),
-        botName: z.string(),
-        extra: z.record(z.any()).optional(),
-      },
-      async ({
-        eventUuid,
-        botName,
-        extra,
-      }: {
-        eventUuid: string;
-        botName: string;
-        extra?: Record<string, any>;
-      }) => {
-        try {
-          const result = await baasClient.scheduleRecordEvent(eventUuid, {
-            botName,
-            extra,
-          });
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Successfully scheduled event recording",
-              },
-            ],
-          };
-        } catch (error) {
-          console.error("Failed to schedule event recording:", error);
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Failed to schedule event recording",
-              },
-            ],
-            isError: true,
-          };
-        }
-      }
-    );
-
-    server.tool(
-      "unscheduleRecordEvent",
-      "Cancel a scheduled recording for a meeting. Use this when you want to: 1) Stop automatic recording 2) Cancel future transcriptions 3) Remove scheduled recordings 4) Disable recurring recordings",
-      { eventUuid: z.string() },
-      async ({ eventUuid }: { eventUuid: string }) => {
-        try {
-          const result = await baasClient.unscheduleRecordEvent(eventUuid);
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Successfully unscheduled event recording",
-              },
-            ],
-          };
-        } catch (error) {
-          console.error("Failed to unschedule event recording:", error);
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Failed to unschedule event recording",
-              },
-            ],
-            isError: true,
-          };
-        }
-      }
-    );
-
-    server.tool(
-      "updateCalendar",
-      "Update calendar connection settings. Use this when you want to: 1) Refresh calendar access 2) Update calendar credentials 3) Change calendar settings 4) Fix connection issues",
-      {
-        uuid: z.string(),
-        oauthClientId: z.string().optional(),
-        oauthClientSecret: z.string().optional(),
-        oauthRefreshToken: z.string().optional(),
-        platform: z.enum(["Google", "Microsoft"]).optional(),
-        rawCalendarId: z.string().optional(),
-      },
-      async ({
-        uuid,
-        oauthClientId,
-        oauthClientSecret,
-        oauthRefreshToken,
-        platform,
-        rawCalendarId,
-      }: {
-        uuid: string;
-        oauthClientId?: string;
-        oauthClientSecret?: string;
-        oauthRefreshToken?: string;
-        platform?: "Google" | "Microsoft";
-        rawCalendarId?: string;
-      }) => {
-        try {
-          const calendar = await baasClient.updateCalendar(uuid, {
-            oauthClientId,
-            oauthClientSecret,
-            oauthRefreshToken,
-            platform: platform === "Google" ? "Google" : "Microsoft",
-            rawCalendarId,
-          });
-          return {
-            content: [
-              {
-                type: "text",
-                text: `Successfully updated calendar: ${JSON.stringify(
-                  calendar,
-                  null,
-                  2
-                )}`,
-              },
-            ],
-          };
-        } catch (error) {
-          console.error("Failed to update calendar:", error);
-          return {
-            content: [
-              {
-                type: "text",
-                text: "Failed to update calendar",
-              },
-            ],
-            isError: true,
-          };
-        }
-      }
-    );
-
-    // Add a simple echo tool for testing
-    server.tool("echo", { message: z.string() }, async ({ message }) => ({
-      content: [
-        {
-          type: "text",
-          text: `Tool echo: ${message}`,
-        },
-      ],
-    }));
+      );
+
+      // Keep the existing echo tool as an example
+      server.tool(
+        "echo",
+        { message: z.string() },
+        async ({ message }: { message: string }) => ({
+          content: [{ type: "text", text: `Tool echo: ${message}` }],
+        })
+      );
+    };
   },
   {
     capabilities: {
       tools: {
-        joinMeeting: {
-          description: "Join's a meeting using the MeetingBaas api",
-        },
-        leaveMeeting: {
-          description: "Leave a meeting using the MeetingBaas api",
-        },
-        getMeetingData: {
-          description: "Get meeting data using the MeetingBaas api",
-        },
-        deleteData: {
-          description: "Delete meeting data using the MeetingBaas api",
-        },
-        createCalendar: {
-          description: "Create a calendar using the MeetingBaas api",
-        },
-        listCalendars: {
-          description: "List calendars using the MeetingBaas api",
-        },
-        getCalendar: {
-          description: "Get calendar using the MeetingBaas api",
-        },
-        deleteCalendar: {
-          description: "Delete calendar using the MeetingBaas api",
-        },
-        resyncAllCalendars: {
-          description: "Resync all calendars using the MeetingBaas api",
-        },
-        botsWithMetadata: {
-          description: "Get bots with metadata using the MeetingBaas api",
-        },
-        listEvents: {
-          description: "List events using the MeetingBaas api",
-        },
-        scheduleRecordEvent: {
-          description: "Schedule a recording using the MeetingBaas api",
-        },
-        unscheduleRecordEvent: {
-          description: "Unschedule a recording using the MeetingBaas api",
-        },
-        updateCalendar: {
-          description: "Update calendar using the MeetingBaas api",
-        },
         echo: {
           description: "Echo a message",
         },
+        redis_test: {
+          description:
+            "Test Redis connection by storing and retrieving a key-value pair",
+        },
       },
     },
   }
 );
 
 export default handler;
diff --git a/package.json b/package.json
index f30ef71..2976c97 100644
--- a/package.json
+++ b/package.json
@@ -1,28 +1,28 @@
 {
   "name": "mcp-on-vercel",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
     "build": "tsc",
     "test:redis": "tsx scripts/test-redis.ts"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
-    "@meeting-baas/sdk": "^0.2.4",
+    "@meeting-baas/sdk": "^0.2.0",
     "@modelcontextprotocol/sdk": "^1.6.1",
     "content-type": "^1.0.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
     "@types/node": "^20.11.24",
     "tsx": "^4.7.1",
     "typescript": "^5.4.2"
   }
 }
diff --git a/scripts/test-client.mjs b/scripts/test-client.mjs
new file mode 100644
index 0000000..4d6485b
--- /dev/null
+++ b/scripts/test-client.mjs
@@ -0,0 +1,31 @@
+import { Client } from "@modelcontextprotocol/sdk/client/index.js";
+import { SSEClientTransport } from "@modelcontextprotocol/sdk/client/sse.js";
+
+const origin = process.argv[2] || "https://mcp-on-vercel.vercel.app";
+
+async function main() {
+  const transport = new SSEClientTransport(new URL(`${origin}/sse`));
+
+  const client = new Client(
+    {
+      name: "example-client",
+      version: "1.0.0",
+    },
+    {
+      capabilities: {
+        prompts: {},
+        resources: {},
+        tools: {},
+      },
+    }
+  );
+
+  await client.connect(transport);
+
+  console.log("Connected", client.getServerCapabilities());
+
+  const result = await client.listTools();
+  console.log(result);
+}
+
+main();
diff --git a/scripts/test-redis.ts b/scripts/test-redis.ts
new file mode 100644
index 0000000..d1de9b0
--- /dev/null
+++ b/scripts/test-redis.ts
@@ -0,0 +1,26 @@
+import { createClient } from "redis";
+
+async function testRedis() {
+  const redis = createClient({
+    url: process.env.REDIS_URL,
+  });
+
+  redis.on("error", (err) => console.error("Redis Client Error", err));
+
+  try {
+    await redis.connect();
+    console.log("Successfully connected to Redis");
+
+    // Test set/get operations
+    await redis.set("test-key", "Hello from MCP!");
+    const value = await redis.get("test-key");
+    console.log("Test value retrieved:", value);
+
+    await redis.quit();
+  } catch (error) {
+    console.error("Error testing Redis:", error);
+    process.exit(1);
+  }
+}
+
+testRedis();
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 3fef9853475ddac1855f0c2043f7bb11b2dc3c30
#KEY#COMMIT_DATE# 2025-04-23 11:31:41 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# try to better handle time out
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/server.ts

#KEY#DIFF_RANGE# FROM: c7aa469c1094d714d71c83b002b8a4fbee346cf9 TO: 3fef9853475ddac1855f0c2043f7bb11b2dc3c30
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/server.ts b/api/server.ts
index 1b24bb2..36337a4 100644
--- a/api/server.ts
+++ b/api/server.ts
@@ -1,250 +1,129 @@
-import type { BaasTypes } from "@meeting-baas/sdk";
 import { BaasClient, MpcClient } from "@meeting-baas/sdk";
 import { IncomingMessage } from "http";
 import { createClient } from "redis";
 import { z } from "zod";
 import { initializeMcpApiHandler } from "../lib/mcp-api-handler";
 
 // Initialize Redis client
 const redis = createClient({
   url: process.env.REDIS_URL,
 });
 
 redis.on("error", (err) => console.error("Redis Client Error", err));
 
 // Initialize MPC client for tool registration
 const mpcClient = new MpcClient({
   serverUrl: process.env.MPC_SERVER_URL || "",
 });
 
 interface ToolParameter {
   name: string;
   required?: boolean;
   schema?: {
     type: string;
   };
 }
 
 // Helper function to convert MPC parameter definition to Zod schema
 function convertToZodSchema(parameters: ToolParameter[]): z.ZodRawShape {
   const schema: z.ZodRawShape = {};
   for (const param of parameters) {
     if (param.required) {
       schema[param.name] = z.string();
     } else {
       schema[param.name] = z.string().optional();
     }
   }
   return schema;
 }
 
 // Helper to get BaaS client for each request
 function getBaasClient(req: IncomingMessage): BaasClient {
   const url = new URL(req.url || "", "https://example.com");
   const apiKey = url.searchParams.get("X-Meeting-BaaS-Key") || "";
   return new BaasClient({
     apiKey,
   });
 }
 
-// Type guard to check if an object has required properties
-function hasRequiredProperties<T extends object>(
-  obj: unknown,
-  required: (keyof T)[]
-): obj is T {
-  if (typeof obj !== "object" || obj === null) {
-    return false;
-  }
-  return required.every((prop) => prop in obj);
-}
-
 const handler = initializeMcpApiHandler(
   (server) => {
     return async (req: IncomingMessage) => {
       // Connect to Redis
       await redis.connect();
 
       // Get BaaS client for this request
       const baasClient = getBaasClient(req);
 
       // Register all Meeting BaaS tools automatically
       const tools = mpcClient.getRegisteredTools();
       for (const tool of tools) {
         const paramsSchema = convertToZodSchema(tool.parameters || []);
         server.tool(
           tool.name,
           paramsSchema,
           async (params: Record<string, string>) => {
-            // Transform string parameters to their proper types
-            const transformedParams = Object.entries(params).reduce(
-              (acc, [key, value]) => {
-                // Handle boolean parameters
-                if (value === "true" || value === "false") {
-                  acc[key] = value === "true";
-                }
-                // Handle number parameters
-                else if (!isNaN(Number(value))) {
-                  acc[key] = Number(value);
-                }
-                // Handle object parameters (like speechToText)
-                else if (value.startsWith("{")) {
-                  try {
-                    acc[key] = JSON.parse(value);
-                  } catch (e) {
-                    acc[key] = value;
-                  }
-                }
-                // Keep string parameters as is
-                else {
-                  acc[key] = value;
-                }
-                return acc;
-              },
-              {} as Record<string, any>
-            );
-
-            // Use the corresponding BaaS client method
-            const method = tool.name as keyof typeof baasClient;
-
-            // Type check based on the method
-            switch (method) {
-              case "joinMeeting":
-                if (
-                  !hasRequiredProperties<BaasTypes.JoinRequest>(
-                    transformedParams,
-                    ["botName", "meetingUrl", "reserved"]
-                  )
-                ) {
-                  throw new Error(
-                    "Missing required parameters for joinMeeting"
-                  );
-                }
-                break;
-              case "createCalendar":
-                if (
-                  !hasRequiredProperties<BaasTypes.CreateCalendarParams>(
-                    transformedParams,
-                    [
-                      "oauth_client_id",
-                      "oauth_client_secret",
-                      "oauth_refresh_token",
-                      "platform",
-                    ]
-                  )
-                ) {
-                  throw new Error(
-                    "Missing required parameters for createCalendar"
-                  );
-                }
-                break;
-              case "getMeetingData":
-                if (
-                  !hasRequiredProperties<BaasTypes.GetMeetingDataQuery>(
-                    transformedParams,
-                    ["bot_id"]
-                  )
-                ) {
-                  throw new Error(
-                    "Missing required parameters for getMeetingData"
-                  );
-                }
-                break;
-              case "deleteData":
-                if (
-                  !hasRequiredProperties<BaasTypes.BotIdParam>(
-                    transformedParams,
-                    ["bot_id"]
-                  )
-                ) {
-                  throw new Error("Missing required parameters for deleteData");
-                }
-                break;
-              case "listCalendars":
-                // No required parameters
-                break;
-              case "getCalendar":
-                if (
-                  !hasRequiredProperties<BaasTypes.CalendarUuidParam>(
-                    transformedParams,
-                    ["calendar_uuid"]
-                  )
-                ) {
-                  throw new Error(
-                    "Missing required parameters for getCalendar"
-                  );
-                }
-                break;
-              case "deleteCalendar":
-                if (
-                  !hasRequiredProperties<BaasTypes.CalendarUuidParam>(
-                    transformedParams,
-                    ["calendar_uuid"]
-                  )
-                ) {
-                  throw new Error(
-                    "Missing required parameters for deleteCalendar"
-                  );
-                }
-                break;
-              case "resyncAllCalendars":
-                // No required parameters
-                break;
+            // Handle tool execution here using the request-specific baasClient
+            try {
+              // Here you would use baasClient to make the actual calls to Meeting BaaS
+              // Example: await baasClient.someMethod(params);
+              return {
+                content: [
+                  {
+                    type: "text",
+                    text: `Tool ${tool.name} executed with Meeting BaaS`,
+                  },
+                ],
+              };
+            } catch (error) {
+              console.error(`Error executing tool ${tool.name}:`, error);
+              throw error;
             }
-
-            const result = await baasClient[method](transformedParams as any);
-            return {
-              content: [
-                {
-                  type: "text",
-                  text: JSON.stringify(result),
-                },
-              ],
-            };
           }
         );
       }
 
       // Add a Redis test tool
       server.tool(
         "redis_test",
         { key: z.string(), value: z.string() },
         async ({ key, value }: { key: string; value: string }) => {
           await redis.set(key, value);
           const result = await redis.get(key);
           return {
             content: [
               {
                 type: "text",
                 text: `Redis test: stored ${key}=${value}, retrieved ${result}`,
               },
             ],
           };
         }
       );
 
       // Keep the existing echo tool as an example
       server.tool(
         "echo",
         { message: z.string() },
         async ({ message }: { message: string }) => ({
           content: [{ type: "text", text: `Tool echo: ${message}` }],
         })
       );
     };
   },
   {
     capabilities: {
       tools: {
         echo: {
           description: "Echo a message",
         },
         redis_test: {
           description:
             "Test Redis connection by storing and retrieving a key-value pair",
         },
       },
     },
   }
 );
 
 export default handler;
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 45e931db2e1c9c2a0e565af6f5ba9c22560c636d
#KEY#COMMIT_DATE# 2025-04-23 11:31:41 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# feat: add Redis integration with Upstash
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/server.ts
- lib/mcp-api-handler.ts
- package.json
- vercel.json

#KEY#DIFF_RANGE# FROM: 3fef9853475ddac1855f0c2043f7bb11b2dc3c30 TO: 45e931db2e1c9c2a0e565af6f5ba9c22560c636d
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/server.ts b/api/server.ts
index 36337a4..76c840c 100644
--- a/api/server.ts
+++ b/api/server.ts
@@ -1,129 +1,100 @@
 import { BaasClient, MpcClient } from "@meeting-baas/sdk";
-import { IncomingMessage } from "http";
 import { createClient } from "redis";
 import { z } from "zod";
 import { initializeMcpApiHandler } from "../lib/mcp-api-handler";
 
 // Initialize Redis client
 const redis = createClient({
   url: process.env.REDIS_URL,
 });
 
 redis.on("error", (err) => console.error("Redis Client Error", err));
 
+// Initialize the BaaS client
+const baasClient = new BaasClient({
+  apiKey: process.env.MEETING_BAAS_API_KEY || "",
+});
+
 // Initialize MPC client for tool registration
 const mpcClient = new MpcClient({
   serverUrl: process.env.MPC_SERVER_URL || "",
 });
 
 interface ToolParameter {
   name: string;
   required?: boolean;
   schema?: {
     type: string;
   };
 }
 
 // Helper function to convert MPC parameter definition to Zod schema
 function convertToZodSchema(parameters: ToolParameter[]): z.ZodRawShape {
   const schema: z.ZodRawShape = {};
   for (const param of parameters) {
     if (param.required) {
-      schema[param.name] = z.string();
+      schema[param.name] = z.string(); // Default to string for now, can be expanded based on param.schema.type
     } else {
       schema[param.name] = z.string().optional();
     }
   }
   return schema;
 }
 
-// Helper to get BaaS client for each request
-function getBaasClient(req: IncomingMessage): BaasClient {
-  const url = new URL(req.url || "", "https://example.com");
-  const apiKey = url.searchParams.get("X-Meeting-BaaS-Key") || "";
-  return new BaasClient({
-    apiKey,
-  });
-}
-
 const handler = initializeMcpApiHandler(
-  (server) => {
-    return async (req: IncomingMessage) => {
-      // Connect to Redis
-      await redis.connect();
+  async (server) => {
+    // Connect to Redis
+    await redis.connect();
 
-      // Get BaaS client for this request
-      const baasClient = getBaasClient(req);
+    // Register all Meeting BaaS tools automatically
+    const tools = mpcClient.getRegisteredTools();
+    for (const tool of tools) {
+      const paramsSchema = convertToZodSchema(tool.parameters || []);
+      server.tool(tool.name, paramsSchema, async (params) => {
+        // Handle tool execution here
+        return {
+          content: [{ type: "text", text: `Tool ${tool.name} executed` }],
+        };
+      });
+    }
 
-      // Register all Meeting BaaS tools automatically
-      const tools = mpcClient.getRegisteredTools();
-      for (const tool of tools) {
-        const paramsSchema = convertToZodSchema(tool.parameters || []);
-        server.tool(
-          tool.name,
-          paramsSchema,
-          async (params: Record<string, string>) => {
-            // Handle tool execution here using the request-specific baasClient
-            try {
-              // Here you would use baasClient to make the actual calls to Meeting BaaS
-              // Example: await baasClient.someMethod(params);
-              return {
-                content: [
-                  {
-                    type: "text",
-                    text: `Tool ${tool.name} executed with Meeting BaaS`,
-                  },
-                ],
-              };
-            } catch (error) {
-              console.error(`Error executing tool ${tool.name}:`, error);
-              throw error;
-            }
-          }
-        );
+    // Add a Redis test tool
+    server.tool(
+      "redis_test",
+      { key: z.string(), value: z.string() },
+      async ({ key, value }) => {
+        await redis.set(key, value);
+        const result = await redis.get(key);
+        return {
+          content: [
+            {
+              type: "text",
+              text: `Redis test: stored ${key}=${value}, retrieved ${result}`,
+            },
+          ],
+        };
       }
+    );
 
-      // Add a Redis test tool
-      server.tool(
-        "redis_test",
-        { key: z.string(), value: z.string() },
-        async ({ key, value }: { key: string; value: string }) => {
-          await redis.set(key, value);
-          const result = await redis.get(key);
-          return {
-            content: [
-              {
-                type: "text",
-                text: `Redis test: stored ${key}=${value}, retrieved ${result}`,
-              },
-            ],
-          };
-        }
-      );
-
-      // Keep the existing echo tool as an example
-      server.tool(
-        "echo",
-        { message: z.string() },
-        async ({ message }: { message: string }) => ({
-          content: [{ type: "text", text: `Tool echo: ${message}` }],
-        })
-      );
-    };
+    // Keep the existing echo tool as an example
+    server.tool("echo", { message: z.string() }, async ({ message }) => ({
+      content: [{ type: "text", text: `Tool echo: ${message}` }],
+    }));
   },
   {
     capabilities: {
       tools: {
         echo: {
           description: "Echo a message",
         },
         redis_test: {
           description:
             "Test Redis connection by storing and retrieving a key-value pair",
         },
+        // Meeting BaaS tools will be automatically added to capabilities
       },
     },
   }
 );
 
 export default handler;
diff --git a/lib/mcp-api-handler.ts b/lib/mcp-api-handler.ts
index c569f29..1fa6759 100644
--- a/lib/mcp-api-handler.ts
+++ b/lib/mcp-api-handler.ts
@@ -1,351 +1,329 @@
-import { ServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
+import getRawBody from "raw-body";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
 import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
 import { IncomingHttpHeaders, IncomingMessage, ServerResponse } from "http";
-import { Socket } from "net";
-import getRawBody from "raw-body";
 import { createClient } from "redis";
+import { Socket } from "net";
 import { Readable } from "stream";
-
-// Increase max duration to match vercel.json
-const MAX_DURATION = 300;
-// Keep-alive interval in seconds
-const KEEP_ALIVE_INTERVAL = 30;
+import { ServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
+import vercelJson from "../vercel.json";
 
 interface SerializedRequest {
   requestId: string;
   url: string;
   method: string;
   body: string;
   headers: IncomingHttpHeaders;
 }
 
 export function initializeMcpApiHandler(
   initializeServer: (server: McpServer) => void,
   serverOptions: ServerOptions = {}
 ) {
-  const maxDuration = MAX_DURATION;
+  const maxDuration =
+    vercelJson?.functions?.["api/server.ts"]?.maxDuration || 800;
   const redisUrl = process.env.REDIS_URL || process.env.KV_URL;
   if (!redisUrl) {
     throw new Error("REDIS_URL environment variable is not set");
   }
   const redis = createClient({
     url: redisUrl,
   });
   const redisPublisher = createClient({
     url: redisUrl,
   });
   redis.on("error", (err) => {
     console.error("Redis error", err);
   });
   redisPublisher.on("error", (err) => {
     console.error("Redis error", err);
   });
   const redisPromise = Promise.all([redis.connect(), redisPublisher.connect()]);
 
   let servers: McpServer[] = [];
 
   let statelessServer: McpServer;
   const statelessTransport = new StreamableHTTPServerTransport({
     sessionIdGenerator: undefined,
   });
 
   return async function mcpApiHandler(
     req: IncomingMessage,
     res: ServerResponse
   ) {
     await redisPromise;
     const url = new URL(req.url || "", "https://example.com");
     if (url.pathname === "/mcp") {
       if (req.method === "GET") {
         console.log("Received GET MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       if (req.method === "DELETE") {
         console.log("Received DELETE MCP request");
         res.writeHead(405).end(
           JSON.stringify({
             jsonrpc: "2.0",
             error: {
               code: -32000,
               message: "Method not allowed.",
             },
             id: null,
           })
         );
         return;
       }
       console.log("Got new MCP connection", req.url, req.method);
 
       if (!statelessServer) {
         statelessServer = new McpServer(
           {
             name: "mcp-typescript server on vercel",
             version: "0.1.0",
           },
           serverOptions
         );
 
         initializeServer(statelessServer);
         await statelessServer.connect(statelessTransport);
       }
       await statelessTransport.handleRequest(req, res);
     } else if (url.pathname === "/sse") {
       console.log("Got new SSE connection");
 
-      // Set headers for SSE
-      res.writeHead(200, {
-        "Content-Type": "text/event-stream",
-        "Cache-Control": "no-cache",
-        Connection: "keep-alive",
-      });
-
-      // Send keep-alive comments periodically
-      const keepAliveInterval = setInterval(() => {
-        res.write(": keep-alive\n\n");
-      }, KEEP_ALIVE_INTERVAL * 1000);
-
       const transport = new SSEServerTransport("/message", res);
       const sessionId = transport.sessionId;
       const server = new McpServer(
         {
           name: "mcp-typescript server on vercel",
           version: "0.1.0",
         },
         serverOptions
       );
       initializeServer(server);
 
       servers.push(server);
 
       server.server.onclose = () => {
         console.log("SSE connection closed");
-        clearInterval(keepAliveInterval);
         servers = servers.filter((s) => s !== server);
       };
 
       let logs: {
         type: "log" | "error";
         messages: string[];
       }[] = [];
       // This ensures that we logs in the context of the right invocation since the subscriber
       // is not itself invoked in request context.
       function logInContext(severity: "log" | "error", ...messages: string[]) {
         logs.push({
           type: severity,
           messages,
         });
       }
 
       // Handles messages originally received via /message
       const handleMessage = async (message: string) => {
         console.log("Received message from Redis", message);
         logInContext("log", "Received message from Redis", message);
         const request = JSON.parse(message) as SerializedRequest;
 
         // Make in IncomingMessage object because that is what the SDK expects.
         const req = createFakeIncomingMessage({
           method: request.method,
           url: request.url,
           headers: request.headers,
           body: request.body,
         });
         const syntheticRes = new ServerResponse(req);
         let status = 100;
         let body = "";
         syntheticRes.writeHead = (statusCode: number) => {
           status = statusCode;
           return syntheticRes;
         };
         syntheticRes.end = (b: unknown) => {
           body = b as string;
           return syntheticRes;
         };
         await transport.handlePostMessage(req, syntheticRes);
 
         await redisPublisher.publish(
           `responses:${sessionId}:${request.requestId}`,
           JSON.stringify({
             status,
             body,
           })
         );
 
         if (status >= 200 && status < 300) {
           logInContext(
             "log",
             `Request ${sessionId}:${request.requestId} succeeded: ${body}`
           );
         } else {
           logInContext(
             "error",
             `Message for ${sessionId}:${request.requestId} failed with status ${status}: ${body}`
           );
         }
       };
 
       const interval = setInterval(() => {
         for (const log of logs) {
           console[log.type].call(console, ...log.messages);
         }
         logs = [];
       }, 100);
 
       await redis.subscribe(`requests:${sessionId}`, handleMessage);
       console.log(`Subscribed to requests:${sessionId}`);
 
       let timeout: NodeJS.Timeout;
       let resolveTimeout: (value: unknown) => void;
       const waitPromise = new Promise((resolve) => {
         resolveTimeout = resolve;
         timeout = setTimeout(() => {
           resolve("max duration reached");
         }, (maxDuration - 5) * 1000);
       });
 
       async function cleanup() {
-        clearInterval(keepAliveInterval);
         clearTimeout(timeout);
         clearInterval(interval);
         await redis.unsubscribe(`requests:${sessionId}`, handleMessage);
         console.log("Done");
+        res.statusCode = 200;
         res.end();
       }
       req.on("close", () => resolveTimeout("client hang up"));
 
       await server.connect(transport);
       const closeReason = await waitPromise;
       console.log(closeReason);
       await cleanup();
     } else if (url.pathname === "/message") {
       console.log("Received message");
 
       const body = await getRawBody(req, {
         length: req.headers["content-length"],
         encoding: "utf-8",
       });
 
       const sessionId = url.searchParams.get("sessionId") || "";
       if (!sessionId) {
         res.statusCode = 400;
         res.end("No sessionId provided");
         return;
       }
       const requestId = crypto.randomUUID();
       const serializedRequest: SerializedRequest = {
         requestId,
         url: req.url || "",
         method: req.method || "",
         body: body,
         headers: req.headers,
       };
 
       // Handles responses from the /sse endpoint.
       await redis.subscribe(
         `responses:${sessionId}:${requestId}`,
         (message) => {
           clearTimeout(timeout);
           const response = JSON.parse(message) as {
             status: number;
             body: string;
           };
           res.statusCode = response.status;
           res.end(response.body);
         }
       );
 
       // Queue the request in Redis so that a subscriber can pick it up.
       // One queue per session.
       await redisPublisher.publish(
         `requests:${sessionId}`,
         JSON.stringify(serializedRequest)
       );
       console.log(`Published requests:${sessionId}`, serializedRequest);
 
       let timeout = setTimeout(async () => {
         await redis.unsubscribe(`responses:${sessionId}:${requestId}`);
         res.statusCode = 408;
         res.end("Request timed out");
       }, 10 * 1000);
 
       res.on("close", async () => {
         clearTimeout(timeout);
         await redis.unsubscribe(`responses:${sessionId}:${requestId}`);
       });
     } else {
       res.statusCode = 404;
       res.end("Not found");
     }
   };
 }
 
 // Define the options interface
 interface FakeIncomingMessageOptions {
   method?: string;
   url?: string;
   headers?: IncomingHttpHeaders;
   body?: string | Buffer | Record<string, any> | null;
   socket?: Socket;
 }
 
 // Create a fake IncomingMessage
 function createFakeIncomingMessage(
   options: FakeIncomingMessageOptions = {}
 ): IncomingMessage {
   const {
     method = "GET",
     url = "/",
     headers = {},
     body = null,
     socket = new Socket(),
   } = options;
 
-  // Create a proper IncomingMessage instance
-  const req = Object.create(IncomingMessage.prototype);
-  Object.assign(req, new Readable(), {
-    method,
-    url,
-    headers,
-    socket,
-    // Add required IncomingMessage properties
-    httpVersion: "1.1",
-    httpVersionMajor: 1,
-    httpVersionMinor: 1,
-    aborted: false,
-    complete: true,
-    connection: socket,
-    // Bind necessary methods
-    _read: function () {},
-    push: function (chunk: any) {
-      if (chunk !== null) {
-        return Readable.prototype.push.call(this, chunk);
-      }
-      return false;
-    },
-  });
+  // Create a readable stream that will be used as the base for IncomingMessage
+  const readable = new Readable();
+  readable._read = (): void => {}; // Required implementation
 
-  // Add the body if provided
+  // Add the body content if provided
   if (body) {
     if (typeof body === "string") {
-      req.push(body);
+      readable.push(body);
     } else if (Buffer.isBuffer(body)) {
-      req.push(body);
+      readable.push(body);
     } else {
-      req.push(JSON.stringify(body));
+      readable.push(JSON.stringify(body));
     }
+    readable.push(null); // Signal the end of the stream
   }
-  req.push(null); // Signal end of stream
+
+  // Create the IncomingMessage instance
+  const req = new IncomingMessage(socket);
+
+  // Set the properties
+  req.method = method;
+  req.url = url;
+  req.headers = headers;
+
+  // Copy over the stream methods
+  req.push = readable.push.bind(readable);
+  req.read = readable.read.bind(readable);
+  req.on = readable.on.bind(readable);
+  req.pipe = readable.pipe.bind(readable);
 
   return req;
 }
diff --git a/package.json b/package.json
index 2976c97..11cb41a 100644
--- a/package.json
+++ b/package.json
@@ -1,28 +1,27 @@
 {
   "name": "mcp-on-vercel",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
     "build": "tsc",
     "test:redis": "tsx scripts/test-redis.ts"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
     "@meeting-baas/sdk": "^0.2.0",
     "@modelcontextprotocol/sdk": "^1.6.1",
     "content-type": "^1.0.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
     "@types/node": "^20.11.24",
-    "tsx": "^4.7.1",
-    "typescript": "^5.4.2"
+    "tsx": "^4.7.1"
   }
 }
diff --git a/vercel.json b/vercel.json
index ae8ba52..360f051 100644
--- a/vercel.json
+++ b/vercel.json
@@ -1,8 +1,8 @@
 {
   "rewrites": [{ "source": "/(.+)", "destination": "/api/server" }],
   "functions": {
     "api/server.ts": {
-      "maxDuration": 300
+      "maxDuration": 60
     }
   }
 }
#KEY#END_COMMIT#
#KEY#START_COMMIT#
=================================================================
#KEY#COMMIT_HASH# 88c3703c0b7aa3ab7035d107c58c64ff08860216
#KEY#COMMIT_DATE# 2025-04-23 11:31:40 +0200
#KEY#COMMIT_AUTHOR# Lazare Rossillon
#KEY#COMMIT_MESSAGE# feat: integrate Meeting-BaaS SDK and auto-register tools
#KEY#RELATED_PR_MR# None found

#KEY#CHANGED_FILES#
- api/server.ts
- package.json
- scripts/test-redis.ts

#KEY#DIFF_RANGE# FROM: 45e931db2e1c9c2a0e565af6f5ba9c22560c636d TO: 88c3703c0b7aa3ab7035d107c58c64ff08860216
=================================================================

#KEY#GIT_DIFF#

diff --git a/api/server.ts b/api/server.ts
index 76c840c..60aa960 100644
--- a/api/server.ts
+++ b/api/server.ts
@@ -1,100 +1,67 @@
 import { BaasClient, MpcClient } from "@meeting-baas/sdk";
-import { createClient } from "redis";
 import { z } from "zod";
 import { initializeMcpApiHandler } from "../lib/mcp-api-handler";
 
-// Initialize Redis client
-const redis = createClient({
-  url: process.env.REDIS_URL,
-});
-
-redis.on("error", (err) => console.error("Redis Client Error", err));
-
 // Initialize the BaaS client
 const baasClient = new BaasClient({
   apiKey: process.env.MEETING_BAAS_API_KEY || "",
 });
 
 // Initialize MPC client for tool registration
 const mpcClient = new MpcClient({
   serverUrl: process.env.MPC_SERVER_URL || "",
 });
 
 interface ToolParameter {
   name: string;
   required?: boolean;
   schema?: {
     type: string;
   };
 }
 
 // Helper function to convert MPC parameter definition to Zod schema
 function convertToZodSchema(parameters: ToolParameter[]): z.ZodRawShape {
   const schema: z.ZodRawShape = {};
   for (const param of parameters) {
     if (param.required) {
       schema[param.name] = z.string(); // Default to string for now, can be expanded based on param.schema.type
     } else {
       schema[param.name] = z.string().optional();
     }
   }
   return schema;
 }
 
 const handler = initializeMcpApiHandler(
   async (server) => {
-    // Connect to Redis
-    await redis.connect();
-
     // Register all Meeting BaaS tools automatically
     const tools = mpcClient.getRegisteredTools();
     for (const tool of tools) {
       const paramsSchema = convertToZodSchema(tool.parameters || []);
       server.tool(tool.name, paramsSchema, async (params) => {
         // Handle tool execution here
         return {
           content: [{ type: "text", text: `Tool ${tool.name} executed` }],
         };
       });
     }
 
-    // Add a Redis test tool
-    server.tool(
-      "redis_test",
-      { key: z.string(), value: z.string() },
-      async ({ key, value }) => {
-        await redis.set(key, value);
-        const result = await redis.get(key);
-        return {
-          content: [
-            {
-              type: "text",
-              text: `Redis test: stored ${key}=${value}, retrieved ${result}`,
-            },
-          ],
-        };
-      }
-    );
-
     // Keep the existing echo tool as an example
     server.tool("echo", { message: z.string() }, async ({ message }) => ({
       content: [{ type: "text", text: `Tool echo: ${message}` }],
     }));
   },
   {
     capabilities: {
       tools: {
         echo: {
           description: "Echo a message",
         },
-        redis_test: {
-          description:
-            "Test Redis connection by storing and retrieving a key-value pair",
-        },
         // Meeting BaaS tools will be automatically added to capabilities
       },
     },
   }
 );
 
 export default handler;
diff --git a/package.json b/package.json
index 11cb41a..5b4c25c 100644
--- a/package.json
+++ b/package.json
@@ -1,27 +1,26 @@
 {
   "name": "mcp-on-vercel",
   "version": "1.0.0",
   "description": "",
   "main": "index.js",
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
-    "build": "tsc",
-    "test:redis": "tsx scripts/test-redis.ts"
+    "build": "tsc"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "packageManager": "pnpm@8.15.7+sha512.c85cd21b6da10332156b1ca2aa79c0a61ee7ad2eb0453b88ab299289e9e8ca93e6091232b25c07cbf61f6df77128d9c849e5c9ac6e44854dbd211c49f3a67adc",
   "dependencies": {
     "@meeting-baas/sdk": "^0.2.0",
     "@modelcontextprotocol/sdk": "^1.6.1",
     "content-type": "^1.0.5",
     "raw-body": "^3.0.0",
     "redis": "^4.7.0",
     "zod": "^3.24.2"
   },
   "devDependencies": {
     "@types/node": "^20.11.24",
-    "tsx": "^4.7.1"
+    "@types/content-type": "^1.0.5"
   }
 }
#KEY#END_COMMIT#
